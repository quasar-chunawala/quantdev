{
  "hash": "2e8fddd060281f96544aac2322f5a897",
  "result": {
    "markdown": "---\ntitle: A crash course in Rust - I\nauthor: Quasar\ndate: '2025-11-17'\ncategories:\n  - Rust\nimage: Rust-4.png\ntoc: true\ntoc-depth: 3\n---\n\n# A crash course in Rust - I\n## Introduction\n\nI have been working through the excellent [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) and I summarize my learnings about Rust language features and code snippets I tried here.\n\n## Designing a basic linked list\n\nA linked list is a data-structure consisting of a collection of nodes which together form a sequence. In its most basic form, each node contains data and a reference (pointer or link) to the next node in the sequence. Consider defining a `List` as follows:\n\n```rust\npub enum List{\n    Empty,\n    Element(i32, List),\n}\n\npub fn main(){}\n```\n\nLet's go ahead and compile that. \n\n```shell\n[quantdev@quasar-arch ownership]$ rustc first.rs -o first.out\nerror[E0072]: recursive type `List` has infinite size\n --> first.rs:1:1\n  |\n1 | pub enum List{\n  | ^^^^^^^^^^^^^\n2 |     Empty,\n3 |     Element(i32, List),\n  |                  ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle                ---- recursive without indirection\n```\n\nIf we actually checkout the error message, we can see that `rustc` is actually telling us exactly how to solve this problem. \n\n```shell\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle                ---- recursive without indirection\n```\n\nAlright, `Box`. What's that? Let's google `rust box`. [\\texttt{std::boxed::Box<T,A>}](https://doc.rust-lang.org/std/boxed/struct.Box.html) module documentation states that `Box<T>` casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.\n\n### Examples\n\nMove a value from a stack to the heap by creating a `Box`:\n\n```rust\nlet val: u8 = 5;\nlet boxed:Box<u8> = Box::new(val);\n```\n\nMoving a value from a `Box` back to the stack by dereferencing it:\n\n```rust\nlet boxed: Box<u8> = Box::new(5);\nlet val: u8 = *boxed;\n```\n\nCreating a recursive data-structure\n\n```rust\n#[derive(Debug)]\npub enum List{\n    Empty,\n    Element(i32, Box<List>),\n}\n\npub fn main(){\n    let list : List = List::Element(1, Box::new(List::Element(2, Box::new(List::Empty))));\n    println!(\"{list:?}\");\n}\n```\n\nIf I compile and run this code, it gives me:\n\n```shell\n[quantdev@quasar-arch ownership]$ rustc first.rs -o first.out\n[quantdev@quasar-arch ownership]$ ./first.out\nElement(1, Element(2, Empty))\n```\nRecursive data-structures must be boxed, because if the definition of `List` looked like this:\n\n```shell\nElement(T, List)\n```\n\nit wouldn't work. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}