{
  "hash": "252e487076989d105640f8901b8e9a6d",
  "result": {
    "markdown": "---\ntitle: Python3 cheatsheet\nauthor: Quasar\ndate: '2025-11-29'\ncategories:\n  - Python\nimage: python.jpg\ntoc: true\ntoc-depth: 3\n---\n\n# Data Model\n\nObjects are Python's abstraction for data. All data in a Python program is reresented by objects or relations between objects. Even code is represented by objects.\n\n## Object values and Types\n\nEvery object has an identity, type and value. An object's *identity* never changes once it has been created; you may think of it as the object's address in memory. The `is` operator compares the identity of two objects, the `id()` function returns an integer representing its identity.\n\nFor CPython, `id(x)` is the memory address where `x` is stored.\n\nAn object's type determines the operations that the object supports (e.g. does it have a length?) and also defines the possible value for the objects of that type. The `type()` function returns an object's type (which is an object itself). \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nx = 42\nprint(f\"x = {x}\")\nprint(f\"type(x) = {type(x)}\")\nprint(f\"type(type(x)) = {type(type(x))}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 42\ntype(x) = <class 'int'>\ntype(type(x)) = <class 'type'>\n```\n:::\n:::\n\n\nThe value of some objects can change. Objects whose value can change are said to be *mutable*; objects whose value is unchangeable once they are created are called *immutable*. (The value of an immutable container object that contains a reference to mutable object can change when the latter's value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same thing as having an immuteable value, it is more subtle.) An object's mutability is determined by its type; for instance, numbers, strings, and tuples are immutable, while dictionaries and lists are considered mutable.\n\nImmutable types are always compared by identity. Mutable types are always compared by value. \n\nObjects are never explicitly destroyed; however when they become unreachable they may be garbage collected. CPython currently uses a reference counting scheme with delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. \n\nNote that, debug or tracing facilities may keep objects alive that would be normally collectable. `try...except` may keep objects alive. \n\nSome objects contain references to external resources such as open files and windows. It is understood that these resources are freed when the object is garbage collected, but since GC is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually some kind of `close()` method. The `try...finally` and `with` statement provide convenient ways to do this.\n\nSome objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. When we talk about the value of the container, we imply the value of the contained objects.\n\nFor immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after `a = 1; b = 1`, `a` and `b` may or may not refer to the same object with the value one, depending on the implementation. This is because int is an immutable type, so the reference to 1 can be reused. \n\n## Built-in Types in Python\n\nThere is a core set of built-in types natively supported by Python runtime. The standard library defines additional types. \n\n### `None`\n\nThis type has a single value. There is a single object with this value. It is used to signify the absence of a value in many situations. Its truth value is `False`.\n\n### `NotImplemented`\n\nThis type has a single value. Again, there is a single object with this value. \n\n### Ellipsis\n\nThis type also has a single value and there is single object with this value. The object is accessed through the literal `...`. Its truth value is `True`.\n\n### Numbers\n\nPython numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers. \n\nNumeric objects are immutable; once created their value never changes. Hence, they can be used as keys in a dictionary.\n\n#### Integers (`int`)\n\nThese represent numbers in an unlimited range, subject to available virtual memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of $2$'s complement, which gives the illusion of an infinite string of sign bits extending to the left.\n\nInteger-to-string conversion is limited to $4,300$ digits by default. This limitation aims to prevent DoS attacks that exploit the quadratic complexity of integer to string conversions.\n\n#### Booleans (`bool`)\n\nThese represent the truth values `False` and `True`. The two objects representing the values `False` and `True` are the only Boolean objects. \n\n#### Real numbers (`float`)\n\nThese represent IEEE-754 double-precision 64-bit floating point numbers. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport sys\nsys.float_info\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(f\"float_info.max = {sys.float_info.max}, float_info.min = {sys.float_info.min}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat_info.max = 1.7976931348623157e+308, float_info.min = 2.2250738585072014e-308\n```\n:::\n:::\n\n\nNote that `float` represents infinity as `inf`, which is considered larger than any numerical value.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(float('inf') > sys.float_info.max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n#### Complex numbers (`complex`)\n\nThese represent com plex numbers as a pair of double-precision floating-point numbers. The real and imaginary parts of a complex number `z` can be retrieved through the read-only attributes `z.real` and `z.imag`. \n\n### Sequences\n\nThese represent finite ordered sets indexed by non-negative numbers. The built-in function `len()` returns the number of items of a sequence. When the length of a sequence is $n$, the index set contains the numbers $0,1,\\ldots,n-1$. Item $i$ of a sequence $a$ is selected by $a[i]$. Some sequences including built-in sequences interpret negative subscripts by adding the sequence length. For example, `a[-2]` means `a[n-2]`, the second to last item of a sequence `a` of length `n`.\n\nSequences also support slicing. `a[i:j:k]` selects all items with index `x` where `x = i + nk`, $0 \\leq x < j$, $n \\geq 0$.\n\n#### Immutable sequences\n\nAn object of an immutable sequence type cannot change once it is created. (If an object contains references to other objects, these other objects may be mutable and may be changed; however the collection of objects directly referenced by an immutable object cannot change.)\n\n##### Strings\n\nA string is a sequence of values that represent unicode code points. Python doesn't have a `char` type. \n\n##### Tuples\n\nThe items of a `tuple` are arbitrary python objects. Tuple of two or more items are formed by comma separated list of expression. An empty tuple can be formed by a empty pair of parentheses.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport sys\n\ndef empty_tuple_example():\n    t = ()\n    print(f\"Empty tuple size = {sys.getsizeof(t)}\")\n    \nempty_tuple_example()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpty tuple size = 40\n```\n:::\n:::\n\n\n##### Bytes\n\nA bytes object is an immutable array. The items are $8$-bit bytes, represented in the range $0 \\leq x < 256$. Bytes literals like `b'abc'` and the `bytes()` constructor can be used to create bytes objects.\n\n#### Mutable sequences\n\nMutable sequences can be changed after they are created. The subscript and slicing notations can be used as a target of assignment and `del` (delete) statements.\n\nThere are currently two intrinsic mutable sequence types:\n\n- Lists : The items of a list are arbitrary Python objects. Lists are formed by a comma separated list of expressions inside square brackets. \n- Byte Arrays : A `bytearray` object is mutable array. It is created by the built-in `bytearray()` constructor. Aside from being mutable, byte arrays provide the same interface and functionality as immutable `bytes` objects.\n\nSince `list`s and `bytearray`s are mutable, they are unhashable.\n\n### Set types\n\nThese represent unorderd, finite sets of unique elements. As such they cannot be indexed by a subscript. However, they can be iterated over, and the built-in function `len()` returns the number of items in a set. Common uses of sets are fast membership testing, removing duplicates from a sequence, computing mathematicl operations such as intersection, union, difference and symmetric difference. \n\nNote that, if two numbers compare equal (e.g. `1` and `1.0`) only one of them can be contained in a set.\n\nThere are currently two intrinsic set types:\n\n#### Sets\n\nThey represent a mutable set. They are created by the `set()` constructor and can be modified by methods such as `add`.\n\n#### Frozen Sets\n\nThese represent an immutable set. They are created by the built-in `frozenset()` constructor. As a `frozenset` is immutable and hashable, it can be used again as an element of another set, or as a dictionary key.\n\n### Mappings\n\nThese represent finite sets of objects indexed by arbitrary index sets. The subscript notation `a[k]` selects the item indexed by `k` from the mapping `a`.\n\nThere is currently a single intrinsic mapping type: `dict`. \n\n#### Dictionaries\n\nThey represent key-value pairs $\\texttt{key}\\mapsto \\texttt{value}$ or a set of mappings. `key` can be any immutable type. Thus, numeric types (`int`, `bool`, `float`, `complex`), immutable sequence types (`str`, `tuple`, `bytes`) immutable set type (`frozenset`) can be used as dictionary keys. The only things not acceptable as keys are values  containing lists or dictionaries or other mutable types that are compared by value rather than object identity.  The reason for this is that an efficient implementation of dictionaries requires a key's hash vaue to remain constant. Numeric types used for keys obey normal rules for numeric comparision: if two numbers compare equal (e.g. `1` and `1.0`) then they can be used interchangeably.\n\nDictionaries preserve insertion order, meaning that keys will be produced in the same order they were added sequentially over the ddictionary. Replacing an existing key does not change the order. Removing a key and re-inserting it will add to the end instead of keeping its old place. \n\nDictionaries are mutable; they can be created by the `{}` noteation. \n\n### Callable types\n\nThese are the types to which the function call operation can be applied. \n\n#### User-defined functions\n\nA user-defined function object is created by a function definition. \n\n#### Instance methods\n\nAn instance method object combines a class, a class instance and any callable object(normally a user-defined function). \n\n#### Generator functions\n\nA function or method which uses the `yield` statement is called a *generator* function. Such a function, when called always returns an *iterator* object, which can then be used to execute the body of the function: calling the iterator's `iterator.__next__()` method will cause the function to execute until it provides a value using the `yield` statement. When the function executes the `return` statement or falls off the end, a `StopIteration` exception is raise and the iterator will have reached the end of the set of values to be returned.\n\n#### Coroutine functions\n\nA function or method which is defined using `async_def` is called a *coroutine function*. A coroutine is any function that can be paused in the middle. Such a function, when called, returns a **coroutine** object. It may contain `await` expressions, as well as `async_with` and `async_for` statements. \n\n#### Asynchronous generator functions\n\nA function or method which is defined using the `async_def` and which uses the `yield` statement is called a *asynchronous generator function.* Such a function, when called, returns an **asynchronous iterator** object which can be used in an `async_for` statement to execute the body of the function. \n\nCalling the asynchronous iterator's `aiterator.__anext__()` method will return an awaitable which when awaited will execute until it provides a value using the `yield` expression. When the function executes an empty `return` statement or falls off the end, a `StopAsyncIteration` exception is raised and the asynchronous iterator will have reached the end of the values to be yielded. \n\n#### Built-in functions\n\nA built-in function object is a wrapper around a C function. Examples of built-in unctions are `len()`, `zip()` etc. \n\n#### Built-in methods\n\nThis is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument. An example of a built-in method is `.append()` on a list object. \n\n#### Classes\n\nClasses are callable. These object normally act as factories for new instances of themselves, but variations are possible for class types that override `__new__()`. \n\n### Modules\n\nThe most basic organization unit of code in Python is a module. Python code in one module gains access to the code in another module by the process of importing it. \n\n# Modules and Packages\n\n## The `import` statement\n\n### `import <module_name>`\n\nWhen Python executes the statement\n\n```python\nimport foo\n```\n\nit searches for `foo.py` in a list of directories:\n\n- Module Cache `sys.modules`\n- Current directory\n- List of directories contained in the `PYTHONPATH` environment variable.\n\nNote that `import <module_name>` does not make the module contents directly accessible to the caller. A module creates a separate namespace. \n\nThe statement `import <module_name>` only places the `<module_name>` in the caller's symbol table. The objects that are defined in the module remain in the module's *private symnol table*.\n\nFrom the caller, objects in the module are only accessible when prefixed with the `<module_name>` using the dot notation.\n\nWhen a module is first imported, Python searches for the module and if found, it creates a module object, initializing it. If the named module cannot be found, a `ModuleNotFoundError` is raised. Python employs various strategies to search for the module when the `import` machinery is invoked. \n\n### `from <package_name> import <module_name>`\n\nAn alternate form of the `import` statement allows individual objects from the module to be imported directly into the caller's symbol table:\n\n```python\nfrom <package_name> import <module_name>\n```\n\n```python\n# mod.py\ns = \"Impossible is the word in the dictionary of fools.\"\n\ndef foo(arg):\n    print(f\"arg = {arg}\")\n\nclass Foo:\n    def __init__(self):\n        pass\n        \n# main.py\nfrom mod import s, foo\nprint(f\"s : {s}\")   \n# s : \"Impossible is the word in the dictionary of fools.\"\n\nprint(f\"{foo('qux')}\")\n# arg = qux\n\nfrom mod import Foo\nx = Foo()\nx\n# <mod.Foo object at 0x02E3AD50>\n```\n\nBecause this form of `import` places the object names directly into the caller's symbol table, any objects that already exist with the same name will be overwritten.\n\n```python\n# mod.py\na = [100, 200, 300]\n\n# main.py\na = ['foo','bar','baz']\nfrom mod import a\nprint(f\"a = {a}\")\n# a = [100, 200, 300]\n```\n\n### `import <module_name> as <alt_name>`\n\nYou can also import an entire module uner an alternate name:\n\n```python\nimport <module_name> as <alt_name>\n```\n\nFor example, if we do `import numpy as np` then any symbol such as `sum()` will be added to the caller's symbol table as `np.sum()`. \n\nModule contents can be imported from within a function definition. In that case, the `import` does not occur until the function is executed. \n\n## Namespaces\n\nA python namespace is a mapping from names to objects. It works like a dictionary where the keys are object names and values are the objects themselves. Namespaces let you use the same name in different contexts without collisions. \n\n### `dir()` function\n\nThe built-in function `dir()` returns a list of defined names in a namespace. \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndir()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n['In',\n 'Out',\n '_',\n '_2',\n '__',\n '___',\n '__builtin__',\n '__builtins__',\n '__name__',\n '_dh',\n '_i',\n '_i1',\n '_i2',\n '_i3',\n '_i4',\n '_i5',\n '_i6',\n '_ih',\n '_ii',\n '_iii',\n '_oh',\n 'empty_tuple_example',\n 'exit',\n 'get_ipython',\n 'ojs_define',\n 'open',\n 'quit',\n 'sys',\n 'x']\n```\n:::\n:::\n\n\nThere are $4$ different types of namespaces:\n\n- Built-in\n- Global\n- Local\n- Enclosing or non-local\n\nThese namespaces have differing lifetimes. As Python executes a program, it creates namespaces as necessary and removes them when it no longer needs them. Typically, many namespaces will exist at any given time.\n\nThe global, local and enclosing namespaces are implemented as dictionaries. In contrast, the built-in namespace isn't a dictionary, but a module called `builtins`.\n\n### `builtin` namespace\n\nThe **built-in** namespace contains the names of all Python's built-in objects. This namespace is available when the python interpreter is running. So, you can access the names in this namespace at any time in your code without explicitly importing them.\n\nYou can list the objects in the built-in namespace with the `dir()` function using `__builtins__` as an argument:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndir(__builtins__)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n['ArithmeticError',\n 'AssertionError',\n 'AttributeError',\n 'BaseException',\n 'BaseExceptionGroup',\n 'BlockingIOError',\n 'BrokenPipeError',\n 'BufferError',\n 'BytesWarning',\n 'ChildProcessError',\n 'ConnectionAbortedError',\n 'ConnectionError',\n 'ConnectionRefusedError',\n 'ConnectionResetError',\n 'DeprecationWarning',\n 'EOFError',\n 'Ellipsis',\n 'EncodingWarning',\n 'EnvironmentError',\n 'Exception',\n 'ExceptionGroup',\n 'False',\n 'FileExistsError',\n 'FileNotFoundError',\n 'FloatingPointError',\n 'FutureWarning',\n 'GeneratorExit',\n 'IOError',\n 'ImportError',\n 'ImportWarning',\n 'IndentationError',\n 'IndexError',\n 'InterruptedError',\n 'IsADirectoryError',\n 'KeyError',\n 'KeyboardInterrupt',\n 'LookupError',\n 'MemoryError',\n 'ModuleNotFoundError',\n 'NameError',\n 'None',\n 'NotADirectoryError',\n 'NotImplemented',\n 'NotImplementedError',\n 'OSError',\n 'OverflowError',\n 'PendingDeprecationWarning',\n 'PermissionError',\n 'ProcessLookupError',\n 'PythonFinalizationError',\n 'RecursionError',\n 'ReferenceError',\n 'ResourceWarning',\n 'RuntimeError',\n 'RuntimeWarning',\n 'StopAsyncIteration',\n 'StopIteration',\n 'SyntaxError',\n 'SyntaxWarning',\n 'SystemError',\n 'SystemExit',\n 'TabError',\n 'TimeoutError',\n 'True',\n 'TypeError',\n 'UnboundLocalError',\n 'UnicodeDecodeError',\n 'UnicodeEncodeError',\n 'UnicodeError',\n 'UnicodeTranslateError',\n 'UnicodeWarning',\n 'UserWarning',\n 'ValueError',\n 'Warning',\n 'ZeroDivisionError',\n '_IncompleteInputError',\n '__IPYTHON__',\n '__build_class__',\n '__debug__',\n '__doc__',\n '__import__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'abs',\n 'aiter',\n 'all',\n 'anext',\n 'any',\n 'ascii',\n 'bin',\n 'bool',\n 'breakpoint',\n 'bytearray',\n 'bytes',\n 'callable',\n 'chr',\n 'classmethod',\n 'compile',\n 'complex',\n 'copyright',\n 'credits',\n 'delattr',\n 'dict',\n 'dir',\n 'display',\n 'divmod',\n 'enumerate',\n 'eval',\n 'exec',\n 'execfile',\n 'filter',\n 'float',\n 'format',\n 'frozenset',\n 'get_ipython',\n 'getattr',\n 'globals',\n 'hasattr',\n 'hash',\n 'help',\n 'hex',\n 'id',\n 'input',\n 'int',\n 'isinstance',\n 'issubclass',\n 'iter',\n 'len',\n 'license',\n 'list',\n 'locals',\n 'map',\n 'max',\n 'memoryview',\n 'min',\n 'next',\n 'object',\n 'oct',\n 'open',\n 'ord',\n 'pow',\n 'print',\n 'property',\n 'range',\n 'repr',\n 'reversed',\n 'round',\n 'runfile',\n 'set',\n 'setattr',\n 'slice',\n 'sorted',\n 'staticmethod',\n 'str',\n 'sum',\n 'super',\n 'tuple',\n 'type',\n 'vars',\n 'zip']\n```\n:::\n:::\n\n\nThings like built-in exceptions, built-in functions, built-in data types live in this namespace. \n\n### The Global namespace\n\nThe global namespace contains names defined at the module level. Python creates a main global namespace when the main program's body starts. This namespace remains in existence until the interpreter terminates.\n\nEach module has its own global namespace. The interpreter creates a global namespace for any module your program loads with the `import` statement. \n\n## Packages\n\nTo help organize modules and provide a naming hierarchy, Python has a concept of packages. You can think of packages as the directories on a file sytem and modules as files within directories, but don't take this analogy too literally, since packages and modules need not originate from the file system. For the purposes of this blog note, we'll use this convenient analogy of directories and files. Like file system directories, packages are organized hierarchically, and packages may themselves contain subpackages as well as regular modules.\n\nIts important to keep in mind that all packages are modules, but not all modules are packages. Or put another way, packages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package. \n\nAll modules have a name. Subpackage names are separated from their parent package name by a dot, akin to Python's standard attribute access syntax.\n\n### Regular packages\n\nPython defines two types of packages : regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an `__init__.py` file. When a regular package is imported, this `__init__.py` is executed and the objects it defines are bound to the names in the package's namespace. \n\nConsider the following file-system layout that defines a top level `parent` package with three `subpackages`:\n\n```shell\nparent/\n    __init__.py\n    one/\n        __init__.py\n    two/\n        __init__.py\n    three/\n        __init__.py\n```\n\nImporting `parent.one` will implicitly execute `parent/__init__.py` and `/parent/one/__init__.py`. Subsequent imports of `parent.two` and `parent.three` will execute `parent/two/__init__.py` and `parent/three/__init__.py` respectively.\n\n### Namespace packages\n\nA namespace package is a composite of various portions where each portion contributes a subpackage to the parent package. Portions may reside in different locations of the file system.\n\n## Searching \n\nTo begin searching, Python needs the fully qualified name of the module (or package, but for the purposes of this blog note, the difference is immaterial) being imported. \n\nThe fully qualified name will be used in various phases of the import search, and it may be dotted path to the submodule e.g. `foo.bar.baz`. In this case, Python first tries to import `foo`, then `foo.bar` and then finally `foo.bar.baz`. If any of the intermediate imports fail, a `ModuleNotFoundError` is raised.\n\n### The module cache \n\nThe first place checked during import search is `sys.modules`. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So, if `foo.bar.baz` was previously imported, `sys.modules` will contain entries for `foo`, `foo.bar` and `foo.bar.baz`. Each key will have as its value the corresponding module object. \n\nIf module A imports module B, and module B then tries to import module A, Python won't re-import A. Since A's name is aleady present in `sys.modules` (even though module object is not fully loaded yet), the import system simply returns the existing (but partially initialized) module instead of loading it again.\n\n### Challenge puzzle 1\n\nWhat is printed when you run `python main.py`? Note that the comment delineate separate files. \n\n```python\n# alpha.py\nprint(\"alpha\", end=\"\")\nimport beta\nprint(\"X\", end=\"\")\n\n# beta.py\nprint(\"beta\", end=\"\")\nimport alpha\nprint(\"Y\",end=\"\")\n\n# main.py\nprint(\"main\", end=\"\")\nimport alpha\nprint(\"Z\", end=\"\")\n```\n\nFor more such puzzles, visit [getcracked.io](https://getcracked.io).\n\n\n## Flattening a `dict` of `dict`s\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nquote_types = {\n    'Bids' : {\n        1 : [10, 45],\n        2 : [25, 47.5],\n        3 : [30, 49.5]\n    },\n    'Offers' : {\n        1 : [30, 50.5],\n        2 : [25, 52.5],\n        3 : [10, 55]\n    }\n}\n\ndict_of_height_3 ={\n    'a' : {\n        'b' :{\n            'c' : 1,\n            'd' : 2,\n        },\n        'e' : {\n            'f' : 3,\n            'g' : 4,\n        }\n    },\n    'h' : {\n        'i' : {\n            'j' : 5,\n            'k' : 6,\n        },\n        'l' : {\n            'm' : 7,\n            'n' : 8,\n        },\n    }\n}\n\ndef flatten_dict(d : dict, parent_key = '', sep = '_'):\n    result = {}\n    for k,v in d.items():\n        if (type(v) is dict):\n            # Recursively flatten the child element\n            child_flat_dict = flatten_dict(v, parent_key=str(k))\n\n            # We now have a dict-of-dicts of height 2\n            for child_k, child_v in child_flat_dict.items():\n                key = parent_key + sep + child_k if parent_key > '' else child_k\n                result[key] = child_v\n        else:\n            key = parent_key + sep + str(k)\n            result[key] = v\n            \n    return result\n\nprint(\"flattening quotes\\n\")\nflatten_dict(quote_types)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nflattening quotes\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n{'Bids_1': [10, 45],\n 'Bids_2': [25, 47.5],\n 'Bids_3': [30, 49.5],\n 'Offers_1': [30, 50.5],\n 'Offers_2': [25, 52.5],\n 'Offers_3': [10, 55]}\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(\"dict_of_height_3\\n\")\nflatten_dict(dict_of_height_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_of_height_3\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n{'a_b_c': 1,\n 'a_b_d': 2,\n 'a_e_f': 3,\n 'a_e_g': 4,\n 'h_i_j': 5,\n 'h_i_k': 6,\n 'h_l_m': 7,\n 'h_l_n': 8}\n```\n:::\n:::\n\n\n## `list()` in Python\n\n`list`s are mutable sequences typically used to store collections of homogenous items.\n\n`list.append(x:Any)->None` adds a single-item to the end of the list, *in-place*. `list.extend(Iterable)->None` extends the list *in-place* by appending all items from the iterable, and returns `None`. \n\n`list.insert(i,x)->None` inserts an element `x` at the given index `i`. `list.remove(x)` removes the first item from the list who value is equal to `x`. `list.pop([i])` removes the item at the given position in the list and returns it. If no index is specified, `list.pop()` removes and returns the last element in the list.\n\n## Reverse a list\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfrom typing import List\nl = [1, 2, 3, 4, 5]\n\nl.reverse()  # reverse in place\nprint(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# recursive solution\ndef reverse(l : List, acc : List = []) -> List:\n    if(len(l) == 0):\n        return acc\n    \n    if(len(l) == 1):\n        l.extend(acc)\n        return l\n    \n    new_acc = [l[0]]\n    new_acc.extend(acc)\n    return reverse(l[1:], new_acc)\n\ndef reverse_iter(l : List) -> List:\n    result = []\n    for element in l:\n        result.insert(0, element)\n\n    return result\n\nitems = [2, 17, 42, 15, 3]\nreverse(items)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[3, 15, 42, 17, 2]\n```\n:::\n:::\n\n\n## Determine if the list is a palindrome\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfrom typing import List\ndef is_palindrome(l : List) -> bool:\n    n = len(l)\n    i = 0\n    j = n - 1\n\n    while(i <= j):\n        if(l[i] != l[j]):\n            return False\n        \n        i += 1\n        j = n - i - 1\n\n    return True\n\nprint(is_palindrome([1, 2, 3, 2, 1]))\nprint(is_palindrome([1, 2, 2, 1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n## Flatten a nested list\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef flatten_list(l : List):\n    result = []\n    for element in l:\n        if (type(element) is list):\n            simple_list = flatten_list(element)\n            result.extend(simple_list)\n        else:\n            result.append(element)\n    return result\n\nflatten_list(['a', ['b', ['c', 'd'], 'e']])\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n['a', 'b', 'c', 'd', 'e']\n```\n:::\n:::\n\n\n## Eliminate consecutive duplicates of list elements\n\nAlways use `key in my_dict` directly instead of `key in my_dict.keys()`,\nif you want to check the existence of a key in a `dict`. That will use \nthe dictionary's $O(1)$ hashing rather than $O(n)$. `my_dict.keys()`\nreturns a list of keys.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfrom typing import List\n\n# Remove duplicates from a nested-list while preserving the\n# the structure\ndef array_unique(l : List, unique_elements : dict={}) -> (List,dict):\n    result = []\n    for element in l:\n        if type(element) is list:\n            # get the list of unique children and append it to result\n            child_list, unique_elements = array_unique(element, unique_elements=unique_elements)\n            result.append(child_list)\n        else:\n            if element in unique_elements:\n                continue\n            else:\n                result.append(element)\n                unique_elements[element] = True\n\n    return result, unique_elements\n\nmy_array = [1, [1, 2, [1, 2, 3], 4, 5], [5, 6], 7]\nresult, _ = array_unique(my_array)\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[1, [2, [3], 4, 5], [6], 7]\n```\n:::\n:::\n\n\n## List comprehensions\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nsquares = [x**2 for x in range(5)]\nprint(squares)\ncombs = [(x,y,z) for x in range(2) for y in range(2) for z in range(2)]\nprint(combs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 4, 9, 16]\n[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]\n```\n:::\n:::\n\n\n## Nested List comprehensions\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nmatrix = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n]\n\n# Take the transpose of a matrix\n[[row[i] for row in matrix]for i in range(4)]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n:::\n:::\n\n\n## `tuple`s in Python\n\n`list`s are mutable wherease `tuple`s are immutable types. The contents of a tuple cannot be modified at run-time. They usually store a heterogenous collection of items.\n\n## `set`s in Python\n\nPython also includes a data-type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations such as union, intersection, difference and symmetric difference.\n\nCurly braces or `set()` is used to create sets.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\na = set('abracadabra')\nb = set('alcazam')\n\nprint(a)\nprint(a - b)\nprint(a | b)\nprint(a & b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'c', 'r', 'a', 'b', 'd'}\n{'d', 'r', 'b'}\n{'l', 'c', 'r', 'm', 'z', 'a', 'b', 'd'}\n{'c', 'a'}\n```\n:::\n:::\n\n\n## Python 3.8 walrus `:=` operator\n\n`:=` assigns a value to a variable and simultaneous returns the value. For example:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nmy_list = [1, 2, 3, 4, 5]\n\nif (n := len(my_list)):\n    print(f\"The list has non-zero length = {n}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe list has non-zero length = 5\n```\n:::\n:::\n\n\nAnother motivating use-case is when looping over fixed-length blocks in a protocol parser.\n\n```python\n# Loop over fixed length blocks\nwhile (block := f.read(256)) != '':\n    process(block)\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}