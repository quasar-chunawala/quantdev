{
  "hash": "2cf7f478196f0a06e78d2679e84f82ce",
  "result": {
    "markdown": "---\ntitle: Accelerated Python refresher\nauthor: Quasar\ndate: '2025-12-01'\ncategories:\n  - Python\nimage: python.jpg\ntoc: true\ntoc-depth: 3\n---\n\n# Data Model\n\nObjects are Python's abstraction for data. All data in a Python program is reresented by objects or relations between objects. Even code is represented by objects.\n\n## Object values and Types\n\nEvery object has an identity, type and value. An object's *identity* never changes once it has been created; you may think of it as the object's address in memory. The `is` operator compares the identity of two objects, the `id()` function returns an integer representing its identity.\n\nFor CPython, `id(x)` is the memory address where `x` is stored.\n\nAn object's type determines the operations that the object supports (e.g. does it have a length?) and also defines the possible value for the objects of that type. The `type()` function returns an object's type (which is an object itself). \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nx = 42\nprint(f\"x = {x}\")\nprint(f\"type(x) = {type(x)}\")\nprint(f\"type(type(x)) = {type(type(x))}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 42\ntype(x) = <class 'int'>\ntype(type(x)) = <class 'type'>\n```\n:::\n:::\n\n\nThe value of some objects can change. Objects whose value can change are said to be *mutable*; objects whose value is unchangeable once they are created are called *immutable*. (The value of an immutable container object that contains a reference to mutable object can change when the latter's value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same thing as having an immuteable value, it is more subtle.) An object's mutability is determined by its type; for instance, numbers, strings, and tuples are immutable, while dictionaries and lists are considered mutable.\n\nImmutable types are always compared by identity. Mutable types are always compared by value. \n\nObjects are never explicitly destroyed; however when they become unreachable they may be garbage collected. CPython currently uses a reference counting scheme with delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. \n\nNote that, debug or tracing facilities may keep objects alive that would be normally collectable. `try...except` may keep objects alive. \n\nSome objects contain references to external resources such as open files and windows. It is understood that these resources are freed when the object is garbage collected, but since GC is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually some kind of `close()` method. The `try...finally` and `with` statement provide convenient ways to do this.\n\nSome objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. When we talk about the value of the container, we imply the value of the contained objects.\n\nFor immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after `a = 1; b = 1`, `a` and `b` may or may not refer to the same object with the value one, depending on the implementation. This is because int is an immutable type, so the reference to 1 can be reused. \n\n## Built-in Types in Python\n\nThere is a core set of built-in types natively supported by Python runtime. The standard library defines additional types. \n\n### `None`\n\nThis type has a single value. There is a single object with this value. It is used to signify the absence of a value in many situations. Its truth value is `False`.\n\n### `NotImplemented`\n\nThis type has a single value. Again, there is a single object with this value. \n\n### Ellipsis\n\nThis type also has a single value and there is single object with this value. The object is accessed through the literal `...`. Its truth value is `True`.\n\n### Numbers\n\nPython numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers. \n\nNumeric objects are immutable; once created their value never changes. Hence, they can be used as keys in a dictionary.\n\n#### Integers (`int`)\n\nThese represent numbers in an unlimited range, subject to available virtual memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of $2$'s complement, which gives the illusion of an infinite string of sign bits extending to the left.\n\nCPython has a global limit for converting between `int` and `str` upto $4,300$ digits by default. This limitation aims to prevent DoS attacks that exploit the quadratic complexity of integer to string conversions. This limit only applies to decimal or other non-power of two number bases. Hexadecimal, octal and binary conversions are unlimited. \n\nThe `int` type in CPython is an arbitrary length number stored in the binary form(commonly known as `bignum`). There exists no algorithm that convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of $2$. Converting a large value such as `int('1' * 500_000)` can take over a second on a fast CPU. \n\nThe default limit is $4300$ digits as provided in `sys.int_info.default_max_str_digits`. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport sys\nassert sys.int_info.default_max_str_digits == 4300\n```\n:::\n\n\n#### Booleans (`bool`)\n\nThese represent the truth values `False` and `True`. The two objects representing the values `False` and `True` are the only Boolean objects. \n\n#### Real numbers (`float`)\n\nThese represent IEEE-754 double-precision 64-bit floating point numbers. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport sys\nsys.float_info\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(f\"float_info.max = {sys.float_info.max}, float_info.min = {sys.float_info.min}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat_info.max = 1.7976931348623157e+308, float_info.min = 2.2250738585072014e-308\n```\n:::\n:::\n\n\nNote that `float` represents infinity as `inf`, which is considered larger than any numerical value.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(float('inf') > sys.float_info.max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n#### Complex numbers (`complex`)\n\nThese represent com plex numbers as a pair of double-precision floating-point numbers. The real and imaginary parts of a complex number `z` can be retrieved through the read-only attributes `z.real` and `z.imag`. \n\n### Sequences\n\nThese represent finite ordered sets indexed by non-negative numbers. The built-in function `len()` returns the number of items of a sequence. When the length of a sequence is $n$, the index set contains the numbers $0,1,\\ldots,n-1$. Item $i$ of a sequence $a$ is selected by $a[i]$. Some sequences including built-in sequences interpret negative subscripts by adding the sequence length. For example, `a[-2]` means `a[n-2]`, the second to last item of a sequence `a` of length `n`.\n\nSequences also support slicing. `a[i:j:k]` selects all items with index `x` where `x = i + nk`, $0 \\leq x < j$, $n \\geq 0$.\n\n#### Immutable sequences\n\nAn object of an immutable sequence type cannot change once it is created. (If an object contains references to other objects, these other objects may be mutable and may be changed; however the collection of objects directly referenced by an immutable object cannot change.)\n\n##### Strings\n\nA string is a sequence of values that represent unicode code points. Python doesn't have a `char` type. \n\n##### Tuples\n\nThe items of a `tuple` are arbitrary python objects. Tuple of two or more items are formed by comma separated list of expression. An empty tuple can be formed by a empty pair of parentheses.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport sys\n\ndef empty_tuple_example():\n    t = ()\n    print(f\"Empty tuple size = {sys.getsizeof(t)}\")\n    \nempty_tuple_example()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpty tuple size = 40\n```\n:::\n:::\n\n\n##### Bytes\n\nA bytes object is an immutable array. The items are $8$-bit bytes, represented in the range $0 \\leq x < 256$. Bytes literals like `b'abc'` and the `bytes()` constructor can be used to create bytes objects.\n\n#### Mutable sequences\n\nMutable sequences can be changed after they are created. The subscript and slicing notations can be used as a target of assignment and `del` (delete) statements.\n\nThere are currently two intrinsic mutable sequence types:\n\n- Lists : The items of a list are arbitrary Python objects. Lists are formed by a comma separated list of expressions inside square brackets. \n- Byte Arrays : A `bytearray` object is mutable array. It is created by the built-in `bytearray()` constructor. Aside from being mutable, byte arrays provide the same interface and functionality as immutable `bytes` objects.\n\nSince `list`s and `bytearray`s are mutable, they are unhashable.\n\n### Set types\n\nThese represent unorderd, finite sets of unique elements. As such they cannot be indexed by a subscript. However, they can be iterated over, and the built-in function `len()` returns the number of items in a set. Common uses of sets are fast membership testing, removing duplicates from a sequence, computing mathematicl operations such as intersection, union, difference and symmetric difference. \n\nNote that, if two numbers compare equal (e.g. `1` and `1.0`) only one of them can be contained in a set.\n\nThere are currently two intrinsic set types:\n\n#### Sets\n\nThey represent a mutable set. They are created by the `set()` constructor and can be modified by methods such as `add`.\n\n#### Frozen Sets\n\nThese represent an immutable set. They are created by the built-in `frozenset()` constructor. As a `frozenset` is immutable and hashable, it can be used again as an element of another set, or as a dictionary key.\n\n### Mappings\n\nThese represent finite sets of objects indexed by arbitrary index sets. The subscript notation `a[k]` selects the item indexed by `k` from the mapping `a`.\n\nThere is currently a single intrinsic mapping type: `dict`. \n\n#### Dictionaries\n\nThey represent key-value pairs $\\texttt{key}\\mapsto \\texttt{value}$ or a set of mappings. `key` can be any immutable type. Thus, numeric types (`int`, `bool`, `float`, `complex`), immutable sequence types (`str`, `tuple`, `bytes`) immutable set type (`frozenset`) can be used as dictionary keys. The only things not acceptable as keys are values  containing lists or dictionaries or other mutable types that are compared by value rather than object identity.  The reason for this is that an efficient implementation of dictionaries requires a key's hash vaue to remain constant. Numeric types used for keys obey normal rules for numeric comparision: if two numbers compare equal (e.g. `1` and `1.0`) then they can be used interchangeably.\n\nDictionaries preserve insertion order, meaning that keys will be produced in the same order they were added sequentially over the ddictionary. Replacing an existing key does not change the order. Removing a key and re-inserting it will add to the end instead of keeping its old place. \n\nDictionaries are mutable; they can be created by the `{}` notation. \n\n:::{.callout-note}\nAn immutable container is hashable if all of its elements are hashable. For example, a list is mutable and therefore not hashable. A tuple `a=(1,)` is hashable. The tuple `b=(2,[1,2,3])` is not hashable, because it contains an unhashable type. \n:::\n\n### Callable types\n\nThese are the types to which the function call operation can be applied. \n\n#### User-defined functions\n\nA user-defined function object is created by a function definition. \n\n#### Instance methods\n\nAn instance method object combines a class, a class instance and any callable object(normally a user-defined function). \n\n#### Generator functions\n\nA function or method which uses the `yield` statement is called a *generator* function. Such a function, when called always returns an *iterator* object, which can then be used to execute the body of the function: calling the iterator's `iterator.__next__()` method will cause the function to execute until it provides a value using the `yield` statement. When the function executes the `return` statement or falls off the end, a `StopIteration` exception is raise and the iterator will have reached the end of the set of values to be returned.\n\n#### Coroutine functions\n\nA function or method which is defined using `async_def` is called a *coroutine function*. A coroutine is any function that can be paused in the middle. Such a function, when called, returns a **coroutine** object. It may contain `await` expressions, as well as `async_with` and `async_for` statements. \n\n#### Asynchronous generator functions\n\nA function or method which is defined using the `async_def` and which uses the `yield` statement is called a *asynchronous generator function.* Such a function, when called, returns an **asynchronous iterator** object which can be used in an `async_for` statement to execute the body of the function. \n\nCalling the asynchronous iterator's `aiterator.__anext__()` method will return an awaitable which when awaited will execute until it provides a value using the `yield` expression. When the function executes an empty `return` statement or falls off the end, a `StopAsyncIteration` exception is raised and the asynchronous iterator will have reached the end of the values to be yielded. \n\n#### Built-in functions\n\nA built-in function object is a wrapper around a C function. Examples of built-in unctions are `len()`, `zip()` etc. \n\n#### Built-in methods\n\nThis is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument. An example of a built-in method is `.append()` on a list object. \n\n#### Classes\n\nClasses are callable. These object normally act as factories for new instances of themselves, but variations are possible for class types that override `__new__()`. \n\n### Modules\n\nThe most basic organization unit of code in Python is a module. Python code in one module gains access to the code in another module by the process of importing it. \n\n## Special method names\n\nA class can implement certain operations that are invoked by special syntax (such as arithmetic operations, subscripting or slicing). This is Python's approach to operator overloading : allowing classes to define their own behavior w.r.t language operators. For example, if a class defines a method `__getitem__(self, pos)` and `x` is an instance of the class, `x[i]` is roughly equivalent to `x.__getitem__(pos)`. \n\nSetting a special method to `None` means that the operation is not available.\n\n### Basic customization\n\n#### `__new__(cls,...)`\n\nThis method is called to create a new instance of the class `cls`. `__new__()` is mainly intended to allow subclasses of immutable types(like `int`, `str`, `tuple`) to customize instance creation. If `__new__()` does not return an instance of `cls`, then the new instance's `__init__()` method won't be invoked.\n\nIf `__new__(cls,...)` is invoked during object construction and it returns an instance of `cls`, then the new instance's `.__init__()` method will be invoked like `__init__(self,...)` where `self` is the new instance and the remaining arguments are the same as were passed to the object constructor.\n\n#### `__init__(self,...)`\n\nThis method is called after the instance has been created by `__new__()`, but before it is returned to the caller. The arguments of `__init__()` are those passed to the class constructor and are typically used to initialize member-data of the class.\n\nIf a base class has an `__init__()` method, the derived class's `__init__()` method must explicitly call it to ensure proper initialization of the base class member data using `super().__init__([args...])`.\n\n#### `object.__del__(self)`\n\nThis method is called when the instance is about to be destroyed. This is also the so called finalizer or destructor. If a base class has a `__del__()` method, the derived class' `__del__()` method, if any, must explicitly call the base class' `__del__()`.\n\n:::{.callout-note}\n`del x` doesn't directly call `x.__del__()` - the former decrements the reference count for `x` by one, and the latter is only called when `x`'s reference count reaches zero.\n:::\n\n#### `object.__repr__(self)`\n\nThis method is called by the `repr()` built-in function to compute the official string representation of the object. \n\n#### `object.__str__(self)`\n\nThis method is called by the `str(object)`, the default `__format__()` implementation and the built-in function `print()`\n\n#### `object.__lt__(self, other)` and friends\n\nThese are the so-called rich-comparison methods. The correspondence between operator symbols and method names is as follows: `x<y` calls `x.__lt__(y)`, `x<=y` calls `x.__le__(y)`, `x==y` calls `x.__eq__(y)`, `x!=y` calls `x.__ne__(y)`, `x>y` calls `x.__gt__(y)`, and `x>=y` calls `x.__ge__(y)`.\n\n#### `object.__hash__(self)->int`\n\nThe `__hash__()` method should return an integer. Objects that compare equal in value, must have the same hash value.\n\nUser-defined classes have `__eq__()` and `__hash__()` methods by default (inherited from the `object` class); with them, all objects compare unequal (except themselves) and `x.__hash__()` returns an appropriate value such that `x == y` implies both that `x is y` and `hash(x) == hash(y)`.\n\n## Special attributes\n\n### `object.__dict__`\n\nA dictionary \n\n# Modules and Packages\n\n## The `import` statement\n\n### `import <module_name>`\n\nWhen Python executes the statement\n\n```python\nimport foo\n```\n\nit searches for `foo.py` in a list of directories:\n\n- Module Cache `sys.modules`\n- Current directory\n- List of directories contained in the `PYTHONPATH` environment variable.\n\nNote that `import <module_name>` does not make the module contents directly accessible to the caller. A module creates a separate namespace. \n\nThe statement `import <module_name>` only places the `<module_name>` in the caller's symbol table. The objects that are defined in the module remain in the module's *private symbol table*.\n\nFrom the caller, objects in the module are only accessible when prefixed with the `<module_name>` using the dot notation.\n\nWhen a module is first imported, Python searches for the module and if found, it creates a module object, initializing it. If the named module cannot be found, a `ModuleNotFoundError` is raised. Python employs various strategies to search for the module when the `import` machinery is invoked. \n\n### `from <package_name> import <module_name>`\n\nAn alternate form of the `import` statement allows individual objects from the module to be imported directly into the caller's symbol table:\n\n```python\nfrom <package_name> import <module_name>\n```\n\n```python\n# mod.py\ns = \"Impossible is the word in the dictionary of fools.\"\n\ndef foo(arg):\n    print(f\"arg = {arg}\")\n\nclass Foo:\n    def __init__(self):\n        pass\n        \n# main.py\nfrom mod import s, foo\nprint(f\"s : {s}\")   \n# s : \"Impossible is the word in the dictionary of fools.\"\n\nprint(f\"{foo('qux')}\")\n# arg = qux\n\nfrom mod import Foo\nx = Foo()\nx\n# <mod.Foo object at 0x02E3AD50>\n```\n\nBecause this form of `import` places the object names directly into the caller's symbol table, any objects that already exist with the same name will be overwritten.\n\n```python\n# mod.py\na = [100, 200, 300]\n\n# main.py\na = ['foo','bar','baz']\nfrom mod import a\nprint(f\"a = {a}\")\n# a = [100, 200, 300]\n```\n\n### `import <module_name> as <alt_name>`\n\nYou can also import an entire module under an alternate name:\n\n```python\nimport <module_name> as <alt_name>\n```\n\nFor example, if we do `import numpy as np` then any symbol such as `sum()` will be added to the caller's symbol table as `np.sum()`. \n\nModule contents can be imported from within a function definition. In that case, the `import` does not occur until the function is executed. \n\n### Executing a module as a script\n\nAny .py file that contains a module is also a python script and you can execute using `python <my_module>.py`. \n\nWe can distinguish between when the file is loaded as a module and when it is run as a standalone script. When a .py file is imported as a module, Python sets the special *dunder* variable `__name__` to the name of the module. However, if the file is run as a standalone script, `__name__` is set to the string `__main__`. \n\nModules are often designed with the capability to run as a standalone script for the purposes of testing the functionaility that is contained within the module. This is called *unit testing*. \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom typing import List\n\ndef sum_arr(arr: List[float]) -> float:\n    result = sum(x for x in arr)\n    return result\n    \nif __name__ == \"__main__\":\n    assert sum_arr([1,2,3,4,5]) == 15\n```\n:::\n\n\n## Namespaces\n\nA python namespace is a mapping from names to objects. A namespace is like a container that holds the currently defined symbolic names and the objects each name references. You can think of a namespace as a dictionary, in which the keys are the object names and the values are the objects themselves. Each key-value pair maps a name to its corresponding object. \n\nNamespaces let you use the same name in different contexts without collisions. It’s like giving everything its own little room in a well-organized house.  \n\n### `dir()` function\n\nThe built-in function `dir()` returns a list of defined names in a namespace. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndir()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n['In',\n 'List',\n 'Out',\n '_',\n '_3',\n '__',\n '___',\n '__builtin__',\n '__builtins__',\n '__name__',\n '_dh',\n '_i',\n '_i1',\n '_i2',\n '_i3',\n '_i4',\n '_i5',\n '_i6',\n '_i7',\n '_i8',\n '_ih',\n '_ii',\n '_iii',\n '_oh',\n 'empty_tuple_example',\n 'exit',\n 'get_ipython',\n 'ojs_define',\n 'open',\n 'quit',\n 'sum_arr',\n 'sys',\n 'x']\n```\n:::\n:::\n\n\nThere are $4$ different types of namespaces:\n\n- Built-in\n- Global\n- Local\n- Enclosing or non-local\n\nThese namespaces have differing lifetimes. As Python executes a program, it creates namespaces as necessary and removes them when it no longer needs them. Typically, many namespaces will exist at any given time.\n\nThe global, local and enclosing namespaces are implemented as dictionaries. In contrast, the built-in namespace isn't a dictionary, but a module called `builtins`.\n\n### `builtin` namespace\n\nThe **built-in** namespace contains the names of all Python's built-in objects. This namespace is available when the python interpreter is running. So, you can access the names in this namespace at any time in your code without explicitly importing them.\n\nYou can list the objects in the built-in namespace with the `dir()` function using `__builtins__` as an argument:\n\n```\ndir(__builtins__)\n```\n\nThings like built-in exceptions, built-in functions, built-in data types live in this namespace. \n\n### The Global namespace\n\nThe global namespace contains names defined at the module level. Python creates a main global namespace when the main program's body starts. This namespace remains in existence until the interpreter terminates.\n\nAdditionally, each module has its own global namespace. The interpreter creates a global namespace for any module your program loads with the `import` statement. \n\n### The local namespace\n\nThe python interpreter creates a new and dedicated namespace whenever you call a function. The namespace is local to the function and exists only until the function returns:\n\n```shell\n>>> def double_number(number: int) -> int:\n...     result = 2 * number\n...     print(dir())\n...     return result\n... \n>>> double_number(4)\n['number', 'result']\n8\n>>> result\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    result\nNameError: name 'result' is not defined\n```\n\n### The enclosing namespace\n\nYou can also define one function inside the other. In this case, you'd have what's known as an inner function.  In this case, you'd have what is known as an inner function. \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nglobal_variable = \"global\"\n\ndef outer_func():\n    # Non local scope\n    nonlocal_var = \"nonlocal\"\n    def inner_func():\n        # Local scope\n        local_variable = \"local\"\n        print(f\"Hi from the '{local_variable}' scope!\")\n        print(f\"Hi from the '{nonlocal_var}' scope!\")    \n        print(f\"Hi from the '{global_variable}' scope!\")            \n        \n    inner_func()\n    \nouter_func()        \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHi from the 'local' scope!\nHi from the 'nonlocal' scope!\nHi from the 'global' scope!\n```\n:::\n:::\n\n\nIn this example, we first created a global variable at the module level. Then, we defined a function called `outer_func()`. Inside this function, we have a `nonlocal_var`, which is local to `outer_func()`, but non-local to `inner_func()`. In `inner_func()`, we create another variable called `local_variable`, which is local to the function itself. \n\nEach of these namespaces remains in existence until the respective function returns. Python might not immediately reclaim the memory allocated for those namespaces, but all references to the objects become invalid. \n\n### Scope and LEGB rule\n\nThe existence of multiple, distinct namespaces allows you to have several different instances of a particular name simultaneously while a Python program runs. As long as each instance is in a different namespace, they're all maintained separately and won't interfere with one another. \n\nThat raises a question. Suppose you refer to the name `x` in your code, and `x` exists in several namespaces. How does Python know which one you mean each time?\n\nPython looks for `x` in the following order:\n\n$$\n\\text{Local} \\longrightarrow \\text{Enclosed} \\longrightarrow \\text{Global} \\longrightarrow \\text{Built-in}\n$$\n\nThe below code snip agree's with our intuitive understanding of global and local variables. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nx = 42\nprint(f\"x = {x}\")\n\ndef f():\n    x = 17\n    print(f\"x = {x}\")\n    \nf()\nprint(f\"x = {x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 42\nx = 17\nx = 42\n```\n:::\n:::\n\n\nIf we want to modify the value of the global variable `x` from within `f`, we can use the `global` keyword.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nx = 42\nprint(f\"x = {x}\")\n\ndef f():\n    global x\n    x = 17\n    print(f\"x = {x}\")\n    \nf()\nprint(f\"x = {x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 42\nx = 17\nx = 17\n```\n:::\n:::\n\n\nSimilarly, when we have nested functions, we can use the `nonlocal` keyword.\n\n## Packages\n\nTo help organize modules and provide a naming hierarchy, Python has a concept of packages. You can think of packages as the directories on a file sytem and modules as files within directories, but don't take this analogy too literally, since packages and modules need not originate from the file system. For the purposes of this blog note, we'll use this convenient analogy of directories and files. Like file system directories, packages are organized hierarchically, and packages may themselves contain subpackages as well as regular modules.\n\nIts important to keep in mind that all packages are modules, but not all modules are packages. Or put another way, packages are just a special kind of module. Specifically, any module that contains a `__path__` attribute is considered a package. \n\nAll modules have a name. Subpackage names are separated from their parent package name by a dot, akin to Python's standard attribute access syntax.\n\n`import pkg` only places the name `pkg` in the caller's symbol table and doesn't import any modules. \n\n### Package initialization\n\nIf a file named `__init__.py` is present in the package directory, it is invoked when the package or a module in the package is imported. `__init__.py` can be used to effect automatic importing of modules from a package. \n\nEarlier, we saw that the `import pkg` statement only places the name `pkg` in the caller's symbol table and doesn't import any modules. But, if `__init__.py` in the `pkg` directory contains the following:\n\n```python\n# __init__.py\nprint(f\"Invoking __init__.py for {__name__}\")\nimport pkg.mod1, pkg.mod2\n```\n\nThen when you execute `import pkg`, modules `mod1` and `mod2` are automatically imported.\n\n### Importing * from a package\n\nWhen `import *` is used for a module, all objects form the module are imported into the local symbol table, except those whose names begin with an underscore. \n\nThe analogous statement for a package is:\n\n```python\nfrom <package_name> import *\n```\n\nWhat does that do? Not much! Python follows the following convention. If the `__init__.py` file in the package directory contains a list name `__all__`, it taken to be a list of modules that should be imported when the statement `from <package_name> import *` is encountered.\n\n### Subpackages\n\nPackages can contain nested packages to arbitrary depth. Consider\n\n```\n/pkg\n    __init__.py\n    /sub_pkg_1\n        __init__.py\n        mod_in_sub_pkg_1.py\n    /sub_pkg_2\n        __init__.py\n        mod_in_sub_pkg_2.py\n```\n\nWe can use both absolute imports and relative imports. \n\n- Absolute imports use the fully qualified name.\n- `..` evaluates to the parent package\n- `...<some_sub_pkg>` evaluates to some sub-package of the parent package.\n\n\n### Regular packages\n\nPython defines two types of packages : regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an `__init__.py` file. When a regular package is imported, this `__init__.py` is executed and the objects it defines are bound to the names in the package's namespace. \n\nConsider the following file-system layout that defines a top level `parent` package with three `subpackages`:\n\n```shell\nparent/\n    __init__.py\n    one/\n        __init__.py\n    two/\n        __init__.py\n    three/\n        __init__.py\n```\n\nImporting `parent.one` will implicitly execute `parent/__init__.py` and `/parent/one/__init__.py`. Subsequent imports of `parent.two` and `parent.three` will execute `parent/two/__init__.py` and `parent/three/__init__.py` respectively.\n\n### Namespace packages\n\nA namespace package is a composite of various portions where each portion contributes a subpackage to the parent package. Portions may reside in different locations of the file system.\n\n## Searching \n\nTo begin searching, Python needs the fully qualified name of the module (or package, but for the purposes of this blog note, the difference is immaterial) being imported. \n\nThe fully qualified name will be used in various phases of the import search, and it may be dotted path to the submodule e.g. `foo.bar.baz`. In this case, Python first tries to import `foo`, then `foo.bar` and then finally `foo.bar.baz`. If any of the intermediate imports fail, a `ModuleNotFoundError` is raised.\n\n### The module cache \n\nThe first place checked during import search is `sys.modules`. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So, if `foo.bar.baz` was previously imported, `sys.modules` will contain entries for `foo`, `foo.bar` and `foo.bar.baz`. Each key will have as its value the corresponding module object. \n\nIf module A imports module B, and module B then tries to import module A, Python won't re-import A. Since A's name is aleady present in `sys.modules` (even though module object is not fully loaded yet), the import system simply returns the existing (but partially initialized) module instead of loading it again.\n\n### Challenge puzzle\n\nWhat is printed when you run `python main.py`? Note that the comment delineate separate files. \n\n```python\n# alpha.py\nprint(\"alpha\", end=\"\")\nimport beta\nprint(\"X\", end=\"\")\n\n# beta.py\nprint(\"beta\", end=\"\")\nimport alpha\nprint(\"Y\",end=\"\")\n\n# main.py\nprint(\"main\", end=\"\")\nimport alpha\nprint(\"Z\", end=\"\")\n```\n\nFor more such puzzles, visit [getcracked.io](https://getcracked.io).\n\n# Python Type Checking\n\n## Type systems\n\nAll programming languages include some kind of [type system](https://en.wikipedia.org/wiki/Type_system) that formalizes the categories of objects it can work with and how those categories are treated. \n\n### Dynamic typing\n\nPython is a *dynamically typed* language. This means that the Python interpreter does type checking only at runtime, and that the type of a variable is allowed to change over its lifetime. \n\n### Static type\n\nMany higher-level languages such as C, C++, Java are statically typed. The type and size of the variable are known at compile-time. \n\nPython will always remain a *dynamically typed* language. However, [PEP-484](https://www.python.org/dev/peps/pep-0484/) introduced type hints, which makes it possible to also do static type checking of Python code.\n\nUnlike how types work in most other statically typed languages, type hints by themselves don't cause Python to enforce types. As the name suggests, type hints just suggest types. There are other tools like `mypy` that perform static type checking using type hints.\n\n### Duck Typing\n\nAnother term that is often used when talking about Python is [duck typing](https://en.wikipedia.org/wiki/Duck_typing). This moniker comes from the phrase: *\"If it walks like a duck, and quacks like a duck, it must be a duck!\"*.\n\nDuck typing is a concept related to dynamic typing, where the type or class of the object is less important than the methods it defines. Using duck typing, you do not check the types at all. Instead you check, for the presence of a given method or attribute.\n\nFor example, if I define:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nclass TheHobbit:\n    def __len__(self):\n        return 1024\n\nthe_hobbit = TheHobbit()\nprint(f\"Length = len(the_hobbit)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLength = len(the_hobbit)\n```\n:::\n:::\n\n\nI would say that all strings, tuples, lists, dicts and instances of TheHobbit have a length.\n\n### `typing` module\n\nPython's `typing` module provides tools for adding type hints to your code. Type hints make your programs more readable, safer to refactor and helps static type checkers like `mypy` to catch errors before runtime.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nfrom typing import TypedDict\n\nclass Person(TypedDict):\n    name: str\n    age: int\n\ndef print_people(people: list[Person]) -> None:\n    for person in people:\n        print(f\"{person['name']} is {person['age']} years old\")\n        \nprint_people(\n    [{\"name\": \"Johannes Bernoulli\", \"age\": 50},\n     {\"name\": \"Carl Friedrich Gauss\", \"age\":60}]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJohannes Bernoulli is 50 years old\nCarl Friedrich Gauss is 60 years old\n```\n:::\n:::\n\n\n#### Features\n- Supports type hinting for variables, functions and classes\n- Allows for custom type creation using `TypeVar` and `NewType`\n- Supports defining reusable type aliases for better code readability\n- Enables complex type definitions\n- Supports defining structural subtyping interfaces with protocols\n\n#### Frequently used classes and functions\n\n| Object | Type | Description |\n|---|---|---|\n| [`typing.NamedTuple`](https://typing.python.org/en/latest/spec/namedtuples.html) | class | Creates tuple-like classes with named fields |\n| `typing.TypeDict` | class | Creates dictionary-like classes with fixed set of keys |\n| `typing.List` | class | Represents a list |\n| `typing.Callable` | class | Represents a callable with a specified signature |\n| `typing.Any` | |Represents a type that can be of any value |\n| `typing.TypeVar()` | Function | Creates a generic type variable |\n| `typing.NewType()` | Function | Creates a distinct type based on an existing one |\n| `typing.Protocol` | |Defines a structural subtyping interface that classes can implement |\n\n#### Examples\n\nDefine a class using `NamedTuple` and a function that takes it as an argument. \n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfrom typing import NamedTuple\nimport datetime as dt\n\nclass Employee(NamedTuple):\n    employee_id : int\n    name: str\n    date_of_joining : dt.date\n    \n\ndef greet_employee(employee: Employee) -> str:\n    return f\"Hi {employee.name}, employee_id : {employee.employee_id}, welcome to the firm!\"\n    \ngreet_employee(Employee(1, \"Alice\", dt.date(2025,1,1)))\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n'Hi Alice, employee_id : 1, welcome to the firm!'\n```\n:::\n:::\n\n\nWe can define a type alias to simplify complex type annotations:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport datetime as dt\nfrom typing import Dict, Union\nUserData = Dict[str, Union[str,int]]\n\ndef format_user(user: UserData) -> str:\n   return f\"{user[\"name\"]} has last login date {user[\"last_login\"]}\"\n   \nformat_user({\"name\": \"John Carmack\", \"last_login\": dt.date(2025,6,30)}) \n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n'John Carmack has last login date 2025-06-30'\n```\n:::\n:::\n\n\nCreate a protocol and implement it in a class:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfrom typing import Protocol\n\nclass Greeter(Protocol):\n    def greet(self) -> str:\n        ...\n        \nclass FriendlyGreeter:\n    def greet(self)-> str:\n        return \"Hello, friend!\"\n        \ndef welcome(greeter: Greeter) -> None:\n    print(greeter.greet())\n    \nwelcome(FriendlyGreeter())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, friend!\n```\n:::\n:::\n\n\n### Function Annotations\n\nFor functions you can annotate arguments and return value. This is done as follows:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport math\n\ndef area(radius: float) -> float:\n    return math.pi * radius**2\n```\n:::\n\n\nThere are special mypy expressions : `reveal_type()` and `reveal_locals()` that you can add to your code and mypy will report which types it has inferred. \n\n```python\n# reveal.py\n\nimport math\nreveal_type(math.pi)\n\nradius = 1\ncircumference = 2 * math.pi * radius\nreveal_locals()\n```\n\n```shell\n>>> mypy ./reveal.py                                                                               \nreveal.py:4: note: Revealed type is \"builtins.float\"\nreveal.py:8: note: Revealed local types are:\nreveal.py:8: note:     circumference: builtins.float\nreveal.py:8: note:     radius: builtins.int\nSuccess: no issues found in 1 source file\n```\n\n### Variable annotations\n\nWe can also annotate variable definitions just like function signatures.\n\n### Implementing a simple card game\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nimport random\nfrom typing import List, Tuple\n\nCard = Tuple[str, str]\nDeck = List[Card]\nHand = List[Card]\nPlayer = str\n\nsuits = \"♠ ♡ ♢ ♣\".split()\nranks = list(range(2,10)) + \"J Q K A\".split()\n\ndef create_deck(shuffle: bool = False) -> Deck:\n    \"\"\"Create a new deck of 52 cards\"\"\"\n    deck = [(s,r) for s in suits for r in ranks]\n    if shuffle:\n        random.shuffle(deck)\n    return deck\n\ndef deal_hands(deck : Deck) -> Tuple[Hand, Hand, Hand, Hand]:\n    \"\"\"Deal the cards in the deck into four hands\"\"\"\n    return (deck[0::4], deck[1::4], deck[2::4], deck[3::4])\n\ndef play():\n    \"\"\"Play a 4-player card game\"\"\"\n    deck: Deck = create_deck(shuffle=True)\n    players: List[Player] = \"P1 P2 P3 P4\".split()\n    hands: Dict[Player, Hand] = {player: hand for player, hand in zip(players, deal_hands(deck))}\n\n    for player, cards in hands.items():\n        card_str = [f\"{s}{r}\" for (s,r) in cards]\n        print(f\"{player}: {card_str}\")\n\nplay()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP1: ['♠5', '♣5', '♡9', '♢K', '♡7', '♠A', '♢A', '♠7', '♢Q', '♠2', '♣8', '♡2']\nP2: ['♢2', '♡Q', '♡3', '♠Q', '♠9', '♡K', '♠6', '♢7', '♣3', '♢5', '♡8', '♢9']\nP3: ['♢8', '♠K', '♣7', '♡J', '♡6', '♠8', '♣4', '♢6', '♣J', '♣9', '♠4', '♢J']\nP4: ['♠3', '♡A', '♣A', '♢3', '♣6', '♠J', '♡4', '♡5', '♢4', '♣2', '♣Q', '♣K']\n```\n:::\n:::\n\n\n### Type theory\n\n#### Subtypes\n\nOne important concept is that of subtypes. If `S` is a subtype of `T` written as $S <: T, S \\subseteq T$ it means that `S` can be safely used in any context where `T` is expected. The following two conditions must hold:\n\n- $\\forall s \\in S$, $s \\in T$.\n- If `S <: T`, `Callable[T, Any] <: Callable[S, Any]`\n\nFor example `bool <: int`, because `bool` takes values $0$, $1$ which also belong to set of values an `int` takes on. Every function from type `int` is also in the set of functions from type `bool`. \n\n#### Covariance\n\nConsider the following code snip:\n\n```python\n# covariance.py\nfrom typing import Tuple\n \nclass Animal:\n     ...\n\nclass Dog(Animal):\n     ...\n \nan_animal: Animal = Animal()\nlassie: Dog = Dog()\nsnoopy: Dog = Dog()\n \nanimals: Tuple[Animal,...] = (an_animal, lassie)\ndogs: Tuple[Dog, ...] = (lassie, snoopy)\n \ndogs = animals\n```\n\n```shell\n>>> mypy ./covariance.py                                                                           \ncovariance.py:16: error: Incompatible types in assignment \n(expression has type \"tuple[Animal, ...]\", \nvariable has type \"tuple[Dog, ...]\")  [assignment]\nFound 1 error in 1 file (checked 1 source file)\n```\n\nIf $S <: T$, then `Tuple[S,...] <: Tuple[T,...]`. This is because `Tuple` is covariant in all its arguments. Covariant types preserve orderding `<:` of types.\n\nIn Python, most immutable containers are covariant. `Union` is covariant in all its arguments. Callables are covariant in the return type.\n\n#### Contravariance\n\nLanguages with first-class functions have function types like a function expecting a `Dog` and returning an `Animal` (written `Callable[Dog, Animal]`(or `Dog -> Animal`). Those languages also need to specify when one function type is a subtype of another. It is safe to substitute a function `f` for a function `g` if `f` accepts a more general type of argument and returns a more specific type then `g`. For example, `Animal -> Dog`, `Dog -> Dog` and `Animal -> Animal` can be used wherever a `Dog -> Animal` is expected.  \n\n#### Invariance\n\nAn invariant type is neither covariant nore contravariant. Mutable containers like `List` are invariant. \n\n#### Gradual typing and consistent types\n\nPython supports gradual typing, where you can gradyally add type hints to your python code. Gradual typing iss essentially made possible by the `Any` type.\n\nSomehow `Any` sits both at the top and at the bottom of the type hierarchy of subtypes. Any type behaves as if it is a subtype of `Any`, and `Any` behaves as if it is a subtype of any other type. Looking at the definition of subtypes, this is not really possible. Instead, we talk about **consistent types**. \n\nThe type `T` is consistent with the type `U` if `T` is a subtype of `U` or either `T` or `U` is `Any`. \n\nThe type checker only complains about inconsistent types. The takeway is therefore that you will never see type errors arising from the `Any` type. \n\n### Type Variables\n\nA type variable is a special variable that can take on any type, depending on the situation. The syntax for `TypeVar` is straightforward:\n\n```python\nfrom typing import TypeVar\nT = TypeVar('T')\n```\n\nHere, `T` is the name of the type variable. You can use any name, but single uppercase letters like `T`. Let's create a simple generic function:\n\n```python\nfrom typing import TypeVar\n\nT = TypeVar('T')\n\ndef echo(value: T) -> T:\n    return value\n    \nprint(echo(42))\nprint(echo(\"Hello\"))\n```\n\n#### Generic Classes\n\n`TypeVar` defines a type variable, a placeholder, aka *a variable that stores a type*. `Generic` lets you use that type variable in a class.\n\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    def __init__(self, content:T):\n        self.content = content\n        \n    def get_content(self) -> T:\n        return self.content\n        \n    box = Box(123)\n    print(box.get_content())    # Outputs: 123\n```\n\nNow, you can create typ-e-sage boxes:\n\n```python\nint_box = Box[int](42)\nstr_box = Box[str](\"hello\")\n```\n\nAt runtime, `Generic` does almost nothing special - its mainly for type checkers (mypy, pyright etc.). Python doesn't enforce types at runtime.\n\nYou can have multiple type variables.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfrom typing import TypeVar, Generic\n\nK = TypeVar('K')\nV = TypeVar('V')\n\nclass Pair(Generic[K, V]):\n    def __init__(self, key: K, value: V):\n        self.key = key\n        self.value = value\n        \npair = Pair[str, int](\"age\", 30)\n```\n:::\n\n\n##### Constraints and Bounds\n\n`TypeVar`s can be constrained:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfrom typing import TypeVar, Generic\n\n# only allow int or float\nNumeric = TypeVar('Numeric', int, float)\n\nclass Calculator(Generic[Numeric]):\n    def add(self, a: Numeric, b: Numeric) -> Numeric:\n        return a + b\n```\n:::\n\n\nOr bounded(must be subclass of):\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nfrom typing import TypeVar\n\nT = TypeVar('T', bound=int)\n```\n:::\n\n\n#### Duck Types and Protocols\n\nRecall the following example from the introduction:\n\n```python\ndef len(obj):\n    return obj.__len__()\n```\n\n`len()` can return the length of any object that has implemented the `.__len__()` method. How can we add type hints to `len()` and in particular the `obj` argument?\n\nThe answer hides behind the academic sounding term *structural subtyping*. One way to categorize type systems is by whether they are **nominal** or **structural**:\n\n- In a **nominal** system, comparisons between types are based on names and declarations. The Python type system is mostly nominal, where an `int` can be used in place of a `float` because of their subtype relationship.\n- In a **structural** system, comparisons between types are based on structure. You could define a structual type `Sized` that includes all instances that define `.__len__()`, irrespective of their nominal type.\n\nThere is ongoing work to bring a full-fledged structural type system to Python through [PEP-544](https://peps.python.org/pep-0544/) which aims at adding a concept called protocols. Most of PEP 544 is already implemented in mypy though.\n\nA protocol specifies one or more methods that must be implemented. For example, all classes defining `.__len__()` fulfill the `typing.Sized` protocol. We can therefore annotate `len()` as follows:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfrom typing import Sized\n\ndef len(obj: Sized) -> int:\n    return obj.__len__()\n```\n:::\n\n\nOther examples of protocols defined in the `typing` module include `Container`, `Iterable` `Awaitable` and `ContextManager`.\n\nYou can also define your own protocols. This is done by inheriting from `Protocol` and defining the function signatures (with empty function bodies) that the protocol expects. The following example shows how `len()` and `Sized` could have been implemented:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfrom typing_extensions import Protocol\n\nclass Sized(Protocol):\n    def __len__(self) -> int:\n        ...\n\ndef len(obj: Sized) -> int:\n    return obj.__len__()\n```\n:::\n\n\n### How do you add type hints to a large python codebase?\n\nTODO\n\n### Challenge Puzzle\n\nGiven the snippet below, (i) Is this valid Python code and (ii) will mypy raise an error?\n\n```python\nimport random\n\ndef foo() -> None:\n    a: float | str\n    \n    a = random.random()\n    a = input()\n```\n\nIn Python, the syntax for variable annotations allows you to declare the expected type of a variable even before assigning a value. This feature was introduced in PEP 526 to improve the readability and static type checking without affecting run-time behavior. Declaring a variable with an annotation, but no initial value simply informs tools like mypy of the intended type, without actually creating the variable until its assigned later in the code. Moreover, its not a syntax error.\n\nFor more such puzzles, visit [getcracked.io](https://getcracked.io)\n\n# Control flow statements\n\nPython supports `if`, `for` and `while` statements.\n\nIn a `for` or `while` loop, the `break` statement may be paired with an `else` clause. If the loop finishes without executing the `break`, the `else` clause executes.\n\nIn either kind of loop, the `else` clause is not executed if the loop was terminated by a `break`. Other wiways of ending the loop early, such as `return` or raised exception will also skip the execution of the `else` clause.\n\nOne way to think of the `else` clause is to imagine it paired with the `if` inside the loop.\n\nThe `else` clause has more in common with the `else` clause of a `try` statement than it does with that of `if` statements: a `try` statements `else` clause runs when no exception occurs and loop's `else` clasue runs when no `break` occurs.\n\n## `match` statements\n\nA `match` statement takes an expression and compares its value to successive patterns given as one or more case blocks. This is similar to pattern matching in languages like Rust or Haskell. Only the first pattern that matches gets executed and it can also extract components(sequence elements or object attributes) from value into variables.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def where_is(point):\n        match point:\n            case Point(x=0, y=0):\n                print(\"Origin\")\n            case Point(x=0, y=y):\n                print(f\"Y={y}\")\n            case Point(x=x, y=0):\n                print(f\"X={x}\")\n            case Point(x=x, y=y):\n                print(f\"X={x}, Y={y}\")\n            case _:\n                raise ValueError(\"Not a point!\")\n```\n:::\n\n\nThere are several other key features of the assignment statement:\n\n- Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. \n- Sequence pattens support extended unpacking: `[x,y, *rest]` and `(x,y,*rest)` work similar to unpacking assignments. The name after `*` may also be `_`, so `(x,y, *_)` matches a sequence of atleast two items without binding the remaining items.\n\n### Examples \n\n#### Reverse a list\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef reverse(lst: List[T]) -> List[T]: \n    match lst:\n        case []: return lst\n        case [x]: return [x]\n        case [head, *tail]: return reverse(tail) + [head] \n        \nprint(reverse([1,2,3,4,5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n#### Find out whether a list is a palindrome\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef is_palindrome(lst: List[T]) -> bool:\n    match lst:\n        case []: return True\n        case [x]: return True\n        case [head, *tail]: \n            if head == tail[-1]:\n                return is_palindrome(tail[:-1])\n            else:\n                return False\n\nprint(is_palindrome([1,2,2,1]))\nprint(is_palindrome([1,2,3]))\nprint(is_palindrome([1,2,3,2,1]))\nprint(is_palindrome([1,1]))\nprint(is_palindrome([1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\n#### Flatten a nested list structure\n\n```python\n# Transform a list, possibly holding lists as elements into a flat \n# list replacing each list with its elements (recursively)\n# >>> flatten([a, [b, [c, d], e]]]\n# [a, b, c, d, e]\n```\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Traverse the list sequentially. We keep advancing the pointer to the\n# current element. We always have a dichotomy. \n# Either (1) the element is scalar-value (2) the element itself is a \n# list. If the element is a scalar-value, then append it to the result.\n# If the element itself is a nested list, flatten(element) will  \n# yield a 1-dimensional flat list. \n\nfrom typing import TypeVar, List, Any\n\nT = TypeVar('T')\n\ndef flatten(lst: List[Any], result=List[T]):\n    # print(f\"Input lst = {lst}\")\n    if type(lst) is list:\n        if len(lst) == 0:\n            return result\n        \n        head = lst[0]\n        tail = lst[1:]\n        \n        flatten(head, result)   # recursive call to flatten the head,\n                                # the 1D-output of this flattening will be\n                                # stored in `result`\n                                \n        flatten(tail, result)   # call flatten on the tail of the list\n        return result\n    else:\n        result.append(lst)\n        \n    # print(f\"result = {result}\")\n        \nprint(flatten([1, [2, [3, 4], 5], 6, [[[7]]]], []))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7]\n```\n:::\n:::\n\n\n# Functions in Python\n\nThe `def` keyword introduces a function definition. It must be followed by the function name and parenthesized list of parameters. The statements that form the body of the function start at the next line and must be indented. \n\nThe execution of a function introduces a new symbol table used for local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table. Variable references follow the LEGB rule: they first look in the local symbol table, then the enclosing symbol table, then the global symbol table and finally in the table of builtin names. \n\nThe actual arguments to a function call are passed by object reference.  That is, object references are passed by value. \n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nfrom typing import List\ndef multiply_by_two(x: int) -> None:\n    print(f\"multiply_by_two({x})\")\n    x = 2 * x\n    \ndef append_item(lst: List[int]) -> None:\n    print(f\"append_item({lst})\")\n    lst.append(5)\n    assert lst[-1] == 5\n    \ndef reassign_list(lst: List[int]) -> None:\n    print(f\"reassign_list({lst})\")\n    lst = list(range(1,6))\n    assert lst == [1,2,3,4,5]\n    \nx = 10\nprint(f\"x = {x}\")\nmultiply_by_two(x)\nprint(f\"x = {x}\")\n\nlst = list(range(0,11,2))\nprint(f\"lst = {lst}\")\n\nappend_item(lst)\nprint(f\"lst = {lst}\")\n\nreassign_list(lst)\nprint(f\"lst = {lst}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 10\nmultiply_by_two(10)\nx = 10\nlst = [0, 2, 4, 6, 8, 10]\nappend_item([0, 2, 4, 6, 8, 10])\nlst = [0, 2, 4, 6, 8, 10, 5]\nreassign_list([0, 2, 4, 6, 8, 10, 5])\nlst = [0, 2, 4, 6, 8, 10, 5]\n```\n:::\n:::\n\n\nA function definition associates the function name with the function object in the current symbol table. The interpreter recognizes the object pointed to by that name as a user-defined function. \n\n## Default argument values\n\nA default value can be specified for one or more arguments.\n\n```python\ndef norm(x: float = 0.0, y: float = 0.0)\n    return (x**2 + y**2)**0.50\n```\n\nThe default values are evaluated at the point of the function definition in the defining scope, so that:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ni = 5\n\ndef f(arg=i):\n    print(arg)\n\ni = 6\nf()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nThe default value is evaluated only once. This makes a difference when the default argument is a mutable object such as a list, a dictionary or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent function calls.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndef f(a, L=[]):\n    L.append(a)\n    return L\n\nprint(f(1))\nprint(f(2))\nprint(f(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]\n[1, 2]\n[1, 2, 3]\n```\n:::\n:::\n\n\nThe state of mutable default arguments is shared between function calls in Python. \n\n## Keyword arguments\n\nFunctions can also be called using keyword arguments of the form `kwarg=value`. Keyword arguments must follow positional arguments. All the keyword arguments passed must match one of the arguments accepted by the function, and their order is not important. No argument may receive a value more than once. \n\nWhen a final parameter of the form `**kwargs` is present, it receives a dictionary containing all keyword arguments except for those corresponding to a formal parameter. `*args` receives a tuple of all the positional arguments beyond the formal parameter list. \n\n`**kwargs` must be the final parameter in the parameter list.\n\n## Special parameters\n\nBy default, arguments may be passed to Python either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition\n\n# Exception handling\n\n## The `try` statement\n\nThe `try` statement specifies exception handlers and cleanup code for a group of statements. \n\nThe `except` clause specifies one or more exception handlers. When no exception occurs in the `try` clause, no execution handler is executed. When an excveption occurs in the `try` suit, a search for an exception handler is started. The search inspects the `except` clauses in turn until one is found that matches the exception. An exception-less `except` clause, if present, must be the last. \n\nFor an `except` clause with an expression, the expression must evaluate to an exception type or a tuple of exception types. \n\nIf no `except` clause matches the exception, the search for an exception handler continues in the surrounding code and on the call-stack.\n\nIf the evaluation of an expression in the header of an except clause raises an exception, the original search for a handler is canceled and asearch starts for the new exception. \n\n## `except*` clause\n\nThe `except*` clause specifies one or more handlers for groups of exeptions. A `try` statement can have either `except` or `except*` clauses, but not both. The exception type for matching is mandatory in the case of `except*`, so `except*:` is a syntax error. \n\nWhen an exception group is raised in the try block, each `except*` clause splits it into subgroups of matching and non-matching exceptions. If the matching subgroup is not empty, it becomes the handled exception and assigned to the target of `except*` clause. Then, the body of the `except*` clause executes. If the non-matching subgroup is non-empty, it is processed by the next `except*` in the same manner. This continues untill all exceptions in the group have been matched.\n\nAfter all `except*` clauses execute, the group of unhandled exceptions is merged with any exceptions that were raised or re-raised with `except*` clauses. This merged exception group propogates on.\n\n## `else` clause\n\nThe optional `else` clause is executed if the control flow leaves the `try` suite, no exception was raised, no `return`, `continue` or `break` statement was executed. \n\n## `finally` clause\n\nIf `finally` is present, it specifies a cleanup handler. It is always executed even when an exception is thrown. \n\n# OOPS \n\nOOPs is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. There are $4$ tenets of OOPs.\n\n- Encapsulation. Bundling data(attributes) and behaviors(methods) into a single unit. By defining methods to control access to attributes and its modificcation, encapsurlation helps maintain data integrity and promotes modular, secular code.\n- Inheritance. A child class inherits data-members and behaviors from the parent class promoting code reuse.\n- Abstraction. Hiding low-level implementation details. Only expose the essentials to the outside world.\n- Polymorphism. It allows you to treat objects of different types as instances of the base type.\n\n## Classes vs instances\n\nA class allows us to create a user-defined data type. Classes are like the blue-print for an object. An object is an instance of a class. All objects of a class have the same blueprint.\n\nWhen you call a class constructor, first `.__new__()` method is called to create a new instance of the class. This returns an empty object. Then, another special method, `.__init__()` is called that takes the result object and initializes it using constructor-args.\n\n###  Subclassing immutable built-in types\n\nLet's explore another use-case of `.__new__()` method that consists of subclassing an immutable built-in type. As an example, say you need to write a `Vector` class as a subclass of Python's `tuple` type. While this class doesn't have any additional attributes, it provides methods to perform component-wise vector addition, subtraction and scalar multiplication. \n\n```shell\n>>> class Vector(tuple):\n...     def __init__(self, value):\n...         super().__init__(value)\n... \n>>> Vector((1,2))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    Vector((1,2))\n    ~~~~~~^^^^^^^\n  File \"<stdin>\", line 3, in __init__\n    super().__init__(value)\n    ~~~~~~~~~~~~~~~~^^^^^^^\nTypeError: object.__init__() takes exactly one argument (the instance to initialize)\n>>> \n```\n\nThe problem is that `tuple.__init__(value)` calls `tuple.__new__(value)` and it doesn't take arguments the same way as `object.__new__()`. \n\nTo workaround this issue, we can initialize the object at creation time with `.__new__()` instead of overriding `.__init__()`. Here's how you can do this in practice:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nimport math \n\nclass Vector(tuple):\n    def __new__(cls, value):\n        instance = super().__new__(cls, value)\n        return instance\n    \n    def __add__(self, other):\n        result = ()\n        for e1, e2 in zip(self, other):\n            elem = e1 + e2\n            result = result + (elem,)\n        return Vector(result)\n    \n    def __sub__(self, other):\n        result = ()\n        for e1, e2 in zip(self, other):\n            elem = e1 - e2\n            result = result + (elem,)\n        return Vector(result)\n    \n    def dot(self, other) -> float:\n        result = 0.0\n        for e1, e2 in zip(self, other):\n            result += e1 * e2\n            \n        return result\n    \n    def length(self):\n        return math.sqrt(sum(x**2 for x in self))\n\nv1 = Vector((1,2))        \nv2 = Vector((3,4))\n\nv3 = v1 + v2\nprint(f\"v1 + v2 = {v3}\")\n\nv4 = v2 - v1\nprint(f\"v2 - v1 = {v4}\")\n\ninner_product = v1.dot(v2)\nprint(f\"Inner product = {inner_product}\")\n\nv1_norm = v1.length()\nv2_norm = v2.length()\nprint(f\"v1_norm = {v1_norm}\")\nprint(f\"v2_norm = {v2_norm}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nv1 + v2 = (4, 6)\nv2 - v1 = (2, 2)\nInner product = 11.0\nv1_norm = 2.23606797749979\nv2_norm = 5.0\n```\n:::\n:::\n\n\nIn this example, `.__new__()` runs the steps that you learned in the previous section. First, the method creates a new instance of the current class, `cls` by calling `super().__new__()`. This time, the call rolls back to `tuple.__new__()` which creates a new instance and initializes it using `value` as an argument. Then, we customize the new instance by adding additional attributes that we'd like. Finally, a new instance gets returned. \n\n:::{.callout-note}\nPEP-8 says:\n- Always use `self` for the first argument to instance methods.\n- Always use `cls` for the first argument to class methods\n:::\n\n### Writing a factory class\n\nWriting a factory class is often a requirement that can raise the need for a custom implementation of `.__new__()`. However, you should be careful, because in this case, Python skips the initialization step entirely. So, we have the responsibility of taking the newly created object into a valid state, before using it in our code.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nfrom random import choice\n\nclass Pet:\n    def __new__(cls):\n        other = choice([Dog, Cat, Python])\n        instance = super().__new__(other)\n        print(f\"I am a {type(instance).__name__}!\")\n        return instance\n\nclass Dog:\n    def communicate(self):\n        print(\"woof! woof!\")\n        \nclass Cat:\n    def communicate(self):\n        print(\"meow! meow!\")\n        \nclass Python:\n    def communicate(Self):\n        print(\"hiss! hiss!\")       \n```\n:::\n\n\nIn this example, `Pet` provides a `.__new__()` method that creates a new instance by randomly selecting a class from a list of existing classes.\n\nAlso, remember `.__init__()` of `Pet` is never called. That's because `Pet.__new__()` always returns objects of a different class rather than of `Pet` itself.\n\n### Allowing only a single instance of your class\n\nSometimes you need to implement a class that allows the creation of a single instance only. This type of class is commonly known as a singleton class. In this situation, the `__new__()` method comes in handy because it can help you restrict the number of instance that a given class can have. \n\n:::{.callout-note}\nMost experienced Python developers would argue that you don't need to implement the singleton design pattern in Python unless you already have a working class and need to add the pattern's functionality on top of it.\n:::\n\nHere's an example of coding a `Singleton` class with a `.__new__()` method that allows the creation of only one instance at a time. To do this, `.__new__()` checks the existence of previous instanced cached on a class attribute. \n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nclass Singleton(object):\n    _instance = None\n    \n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n        \nfirst = Singleton()\nsecond = Singleton()\nfirst is second\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\nTrue\n```\n:::\n:::\n\n\n## `@classmethod` vs `@staticmethod` \n## Inheritance and composition, `super` keyword\n## Providing multiple constructors in a Python class\n## Operator and function overloading\n## Python Decorators\n## Python metclasses\n# `dataclass` module\n# Implementing map/dict \n# Python closures\n# What are Mixin classes in Python?\n# Python bindings: Calling C or C++ with Python\n# `collections` module\n# `all` and `any` in Python\n\nConsider the following code snip\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nprint(bool(all([])), end=\"\")\nprint(bool(any([])), end=\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrueFalse\n```\n:::\n:::\n\n\n`all(iterable)` returns `True` if all elements in the iterable are truthy. For an empty iterable, there are no elements that violate the condition. In logic, this is called vacuously true: since there's nothing to falsify the statement, it's considered `True`. So, `bool(all([]))` is `True`\n\n`any(iterable)` returns `True` if atleast one element in the iterable is truthy. For an empty iterable, there are no elements at all, so the condition *atleast one is true* cannot be satsified. So, `any([])` is `False`. \n\n\n## Flattening a `dict` of `dict`s\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nquote_types = {\n    'Bids' : {\n        1 : [10, 45],\n        2 : [25, 47.5],\n        3 : [30, 49.5]\n    },\n    'Offers' : {\n        1 : [30, 50.5],\n        2 : [25, 52.5],\n        3 : [10, 55]\n    }\n}\n\ndict_of_height_3 ={\n    'a' : {\n        'b' :{\n            'c' : 1,\n            'd' : 2,\n        },\n        'e' : {\n            'f' : 3,\n            'g' : 4,\n        }\n    },\n    'h' : {\n        'i' : {\n            'j' : 5,\n            'k' : 6,\n        },\n        'l' : {\n            'm' : 7,\n            'n' : 8,\n        },\n    }\n}\n\ndef flatten_dict(d : dict, parent_key = '', sep = '_'):\n    result = {}\n    for k,v in d.items():\n        if (type(v) is dict):\n            # Recursively flatten the child element\n            child_flat_dict = flatten_dict(v, parent_key=str(k))\n\n            # We now have a dict-of-dicts of height 2\n            for child_k, child_v in child_flat_dict.items():\n                key = parent_key + sep + child_k if parent_key > '' else child_k\n                result[key] = child_v\n        else:\n            key = parent_key + sep + str(k)\n            result[key] = v\n            \n    return result\n\nprint(\"flattening quotes\\n\")\nflatten_dict(quote_types)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nflattening quotes\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n{'Bids_1': [10, 45],\n 'Bids_2': [25, 47.5],\n 'Bids_3': [30, 49.5],\n 'Offers_1': [30, 50.5],\n 'Offers_2': [25, 52.5],\n 'Offers_3': [10, 55]}\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nprint(\"dict_of_height_3\\n\")\nflatten_dict(dict_of_height_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_of_height_3\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n{'a_b_c': 1,\n 'a_b_d': 2,\n 'a_e_f': 3,\n 'a_e_g': 4,\n 'h_i_j': 5,\n 'h_i_k': 6,\n 'h_l_m': 7,\n 'h_l_n': 8}\n```\n:::\n:::\n\n\n## `list()` in Python\n\n`list`s are mutable sequences typically used to store collections of homogenous items.\n\n`list.append(x:Any)->None` adds a single-item to the end of the list, *in-place*. `list.extend(Iterable)->None` extends the list *in-place* by appending all items from the iterable, and returns `None`. \n\n`list.insert(i,x)->None` inserts an element `x` at the given index `i`. `list.remove(x)` removes the first item from the list who value is equal to `x`. `list.pop([i])` removes the item at the given position in the list and returns it. If no index is specified, `list.pop()` removes and returns the last element in the list.\n\n## Reverse a list\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nfrom typing import List\nl = [1, 2, 3, 4, 5]\n\nl.reverse()  # reverse in place\nprint(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# recursive solution\ndef reverse(l : List, acc : List = []) -> List:\n    if(len(l) == 0):\n        return acc\n    \n    if(len(l) == 1):\n        l.extend(acc)\n        return l\n    \n    new_acc = [l[0]]\n    new_acc.extend(acc)\n    return reverse(l[1:], new_acc)\n\ndef reverse_iter(l : List) -> List:\n    result = []\n    for element in l:\n        result.insert(0, element)\n\n    return result\n\nitems = [2, 17, 42, 15, 3]\nreverse(items)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n[3, 15, 42, 17, 2]\n```\n:::\n:::\n\n\n## Determine if the list is a palindrome\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nfrom typing import List\ndef is_palindrome(l : List) -> bool:\n    n = len(l)\n    i = 0\n    j = n - 1\n\n    while(i <= j):\n        if(l[i] != l[j]):\n            return False\n        \n        i += 1\n        j = n - i - 1\n\n    return True\n\nprint(is_palindrome([1, 2, 3, 2, 1]))\nprint(is_palindrome([1, 2, 2, 1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n## Flatten a nested list\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ndef flatten_list(l : List):\n    result = []\n    for element in l:\n        if (type(element) is list):\n            simple_list = flatten_list(element)\n            result.extend(simple_list)\n        else:\n            result.append(element)\n    return result\n\nflatten_list(['a', ['b', ['c', 'd'], 'e']])\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n['a', 'b', 'c', 'd', 'e']\n```\n:::\n:::\n\n\n## Eliminate consecutive duplicates of list elements\n\nAlways use `key in my_dict` directly instead of `key in my_dict.keys()`,\nif you want to check the existence of a key in a `dict`. That will use \nthe dictionary's $O(1)$ hashing rather than $O(n)$. `my_dict.keys()`\nreturns a list of keys.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nfrom typing import List\n\n# Remove duplicates from a nested-list while preserving the\n# the structure\ndef array_unique(l : List, unique_elements : dict={}) -> (List,dict):\n    result = []\n    for element in l:\n        if type(element) is list:\n            # get the list of unique children and append it to result\n            child_list, unique_elements = array_unique(element, unique_elements=unique_elements)\n            result.append(child_list)\n        else:\n            if element in unique_elements:\n                continue\n            else:\n                result.append(element)\n                unique_elements[element] = True\n\n    return result, unique_elements\n\nmy_array = [1, [1, 2, [1, 2, 3], 4, 5], [5, 6], 7]\nresult, _ = array_unique(my_array)\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n[1, [2, [3], 4, 5], [6], 7]\n```\n:::\n:::\n\n\n## List comprehensions\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nsquares = [x**2 for x in range(5)]\nprint(squares)\ncombs = [(x,y,z) for x in range(2) for y in range(2) for z in range(2)]\nprint(combs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 4, 9, 16]\n[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]\n```\n:::\n:::\n\n\n## Nested List comprehensions\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nmatrix = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n]\n\n# Take the transpose of a matrix\n[[row[i] for row in matrix]for i in range(4)]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n:::\n:::\n\n\n## `tuple`s in Python\n\n`list`s are mutable wherease `tuple`s are immutable types. The contents of a tuple cannot be modified at run-time. They usually store a heterogenous collection of items.\n\n## `set`s in Python\n\nPython also includes a data-type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations such as union, intersection, difference and symmetric difference.\n\nCurly braces or `set()` is used to create sets.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\na = set('abracadabra')\nb = set('alcazam')\n\nprint(a)\nprint(a - b)\nprint(a | b)\nprint(a & b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a', 'b', 'd', 'c', 'r'}\n{'b', 'r', 'd'}\n{'a', 'l', 'z', 'm', 'b', 'd', 'c', 'r'}\n{'c', 'a'}\n```\n:::\n:::\n\n\n## Python 3.8 walrus `:=` operator\n\n`:=` assigns a value to a variable and simultaneous returns the value. For example:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nmy_list = [1, 2, 3, 4, 5]\n\nif (n := len(my_list)):\n    print(f\"The list has non-zero length = {n}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe list has non-zero length = 5\n```\n:::\n:::\n\n\nAnother motivating use-case is when looping over fixed-length blocks in a protocol parser.\n\n```python\n# Loop over fixed length blocks\nwhile (block := f.read(256)) != '':\n    process(block)\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}