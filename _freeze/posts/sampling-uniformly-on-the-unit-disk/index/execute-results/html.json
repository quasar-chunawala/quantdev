{
  "hash": "1341710e84cd1f8d20b482c1080f5884",
  "result": {
    "markdown": "---\ntitle: Uniformly sampling from the unit disk\nauthor: Quasar\ndate: '2025-10-21'\ncategories:\n  - Quant Puzzles\nimage: image.jpg\ntoc: true\ntoc-depth: 3\n---\n\n# Uniformly sampling from the unit disk\n\nI was asked this puzzle in a recent quant interview and thought it would be interesting to solve this. We are asked to generate points that are uniformly distributed on the unit circle. This is a really elegant question. \n\nA first approach would be to generate points from the unit square distribution - that is pick $U_1 \\sim U[0,1]$ and $U_2 \\sim U[0,1]$, and apply the transform $U_1' = -1 + 2U_1$, $U_2' = -1 + 2U_2$, so that the transformed random variables are $U[-1,1]$. We then accept all points that satisfy $u_1'^2 + u_2'^2 \\leq 1$ and reject all points that violate this condition. However, this is not computationally efficient as we are wasting $\\frac{4 - \\pi}{4} \\approx 20\\%$ of the points.\n\nOne thing is, if you divide circle in concentric rings of size $\\Delta R$, note that the further you are away from the origin, the more area the ring contains. However, we would like a distant ring to have the same density \nas a ring closer to the origin. So, we need to pick more points in the outer ring then in the inner ring. If we pick points with a probability proportional to the square of the distance from the origin, we should end up with a uniform scattering.\n\nLet $u = F(r) = r^2$. So, $r = \\sqrt{u}$. Thus, $R \\stackrel{def}{=} F^{-1}(U) = \\sqrt{U}$ must have the CDF $F_R(r) = r^2$ and density $f_R(r) = 2r$. We also pick $\\Theta \\sim U[0,2\\pi]$. If we project the point $\\left(r, \\theta \\right)$ onto the $x$- and $y$-axis, then we have:\n\n$$\n\\begin{align*}\nX &= \\sqrt{U} \\cos \\Theta\\\\\nY &= \\sqrt{U} \\sin \\Theta\\\\\n\\end{align*}\n$$\n\nThen, we have:\n\n$$\n\\begin{align*}\nf_{X,Y}(x,y) &= f_{R,\\Theta}(r(x,y),\\theta(x,y)) \\frac{\\partial(r,\\theta)}{\\partial(x,y)}\\\\\n&= 2r \\cdot \\frac{1}{2\\pi} \\left|\\begin{matrix} \n\\frac{\\partial}{\\partial x} \\frac{1}{\\sqrt{x^2 + y^2}} & \\frac{\\partial}{\\partial y} \\frac{1}{\\sqrt{x^2 + y^2}} \\\\\n\\frac{\\partial}{\\partial x} \\arctan (y/x) & \\frac{\\partial}{\\partial y} \\arctan (y/x)\n\\end{matrix}\\right|\\\\\n&= 2\\sqrt{x^2 + y^2} \\cdot \\frac{1}{2\\pi} \\left|\\begin{matrix} \n\\frac{x}{\\sqrt{x^2 + y^2}} & \\frac{y}{\\sqrt{x^2 + y^2}} \\\\\n-\\frac{y}{x^2 + y^2} & \\frac{x}{x^2 + y^2}\n\\end{matrix}\\right|.\\\\\n& = \\frac{1}{\\pi} \n\\end{align*}\n$$\n\n## Numerical simulation\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\nu = np.random.uniform(low=0.0, high=1.0, size=10000)\nr = np.sqrt(u)\ntheta = 2*np.pi*np.random.uniform(low=0.0, high=1.0, size=10000)\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\n# Create fig and axes\nfig, ax = plt.subplots()\n\n# Use patches.Circle() to create the circle. The xy argument is a tuple for the center (x,y) and radius is a float\ncircle = patches.Circle((0.0, 0.0), radius = 1.0, fill=False)\n\n# Add the circle to the axes\nax.add_patch(circle)\n\n# Add the (x,y) samples to the axes using the 'scatter' method\nax.scatter(x, y, color='blue', s=2.5)\n\n# Ensure the aspect ratio is equal so the circle isn't distorted\nax.set_aspect('equal', adjustable='box')\n\n# Set the plot limits\nax.set_xlim(-1,1)\nax.set_ylim(-1,1)\n\nplt.title('Uniform sampling from the unit circle')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}