{
  "hash": "35f780ba5372ef8bb17914f13606df6c",
  "result": {
    "markdown": "---\ntitle: \"Generators, iterators and asynchronous programming\"\nauthor: \"Quasar\"\ndate: \"2025-11-24\"\ncategories: [Python]      \nimage: \"python.svg\"\ntoc: true\ntoc-depth: 3\n---\n\n# What is a generator?\n\nA generator is a function that uses the `yield` keyword to return an item. When a generator function is called, it returns a generator object, which is a type of iterator. Here is a simple generator, that produces a sequence of numbers:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef number_generator(n):\n    for i in range(n):\n        yield i\n\ngen = number_generator(1_000_000)\n\nprint(next(gen))\nprint(next(gen))\nprint(next(gen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\nThe state of the generator is saved between `yield` calls. The state of generator is the state of the local variables when the generator is suspended. This allows it to resume where it left off.\n\nThe main use of generators is to save memory - instead of having a very large list of elements in memory, holding everythinat once, we have an object that knows how to produce each particular element, one at a time. This enables lazy computations of heavy objects in memory\n\n# Example: Flattening a list of lists\n\nA common task is to flatten a list of lists into a single list. \n\nImagine you have a list of trades, where each trade has a list of associated cashflows. You want to process all cashflows from all trades.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Ref: bwrob.github.io/posts/python-academy-iteration \ntrades_cashflows = [\n    [10, 20, 30],   # Cashflows for trade 1\n    [15, 25],       # Cashflows for trade 2\n    [100, -10, 5],  # Cashflows for trade 3\n    110             # Simple payment doesn't need to be in a list\n]\n\ndef flatten(list_of_lists):\n    for item in list_of_lists:\n        if isinstance(item, list):\n            for subitem in item:\n                yield subitem\n        else:\n            yield item\n\n# The generator does not hold all cashflows in memory\nall_cashflows_generator = flatten(trades_cashflows)\n\nfor cf in all_cashflows_generator:\n    print(cf, end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 20 30 15 25 100 -10 5 110 \n```\n:::\n:::\n\n\nThis `flatten` generator is memory-efficient. It only needs to store one cashflow at a time, regardless of the total number of cashflows.\n\n# Example: Generating the fibonacci sequence\n\nThe Fibonacci sequence is defined by the recurrence relation: $F_n = F_{n-1} + F_{n-2}$ with seed values $F_0 = 0$ and $F_1 = 1$. A naive implementation of this in Python is a direct translation of the mathematical formula:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef fibonacci_recursive(n: int):\n    \"\"\"Calculate the nth Fibonacci number using a recursive approach.\"\"\"\n    if n < 0:\n        raise ValueError(\"Fibonacci is not defined for negative numbers\")\n    \n    if n < 2:\n        return n\n\n    return fibonacci_recursive(n) + fibonacci_recursive(n-1)\n```\n:::\n\n\nFor `n=40`, this already takes a long amount of time. We are doing lot of rework. Another way to solve this problem is to use an iterative approach.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef fibonacci_iterative(n: int):\n    \"\"\"Calculate the nth Fibonacci number using an iterative approach.\"\"\"\n    if n < 0:\n        raise ValueError(\"Fibonacci is not defined for negative numbers\")\n\n    if n < 2:\n        return n\n\n    a, b = 0, 1\n    for _ in range(n-1):\n        a, b = b, a + b\n    \n    return b\n```\n:::\n\n\nWe can also code up a generator to produce the fibonacci sequence.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef fibonacci_generator():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\ngen = fibonacci_generator()\n\nfor i in range(10):\n    print(f\"F_{i} = {next(gen)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nF_0 = 0\nF_1 = 1\nF_2 = 1\nF_3 = 2\nF_4 = 3\nF_5 = 5\nF_6 = 8\nF_7 = 13\nF_8 = 21\nF_9 = 34\n```\n:::\n:::\n\n\n# Generator expressions\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}