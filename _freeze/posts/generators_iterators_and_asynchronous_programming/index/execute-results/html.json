{
  "hash": "db9b58a2ef0f886141f689ec8f17e037",
  "result": {
    "markdown": "---\ntitle: \"Generators, iterators and asynchronous programming\"\nauthor: \"Quasar\"\ndate: \"2025-11-24\"\ncategories: [Python]      \nimage: \"python.svg\"\ntoc: true\ntoc-depth: 3\n---\n\n# What is a generator?\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n%load_ext itikz\n```\n:::\n\n\nA generator is a function that uses the `yield` keyword to return an item. When a generator function is called, it returns a generator object, which is a type of iterator. Here is a simple generator, that produces a sequence of numbers:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef number_generator(n):\n    for i in range(n):\n        yield i\n\ngen = number_generator(1_000_000)\n\nprint(next(gen))\nprint(next(gen))\nprint(next(gen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\nThe state of the generator is saved between `yield` calls. The state of generator is the state of the local variables when the generator is suspended. This allows it to resume where it left off.\n\nThe main use of generators is to save memory - instead of having a very large list of elements in memory, holding everything at once, we have an object that knows how to produce each particular element, one at a time. This enables lazy computations of heavy objects in memory.\n\n# Example: Flattening a list of lists\n\nA common task is to flatten a list of lists into a single list. \n\nImagine you have a list of trades, where each trade has a list of associated cashflows. You want to process all cashflows from all trades.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Ref: bwrob.github.io/posts/python-academy-iteration \ntrades_cashflows = [\n    [10, 20, 30],   # Cashflows for trade 1\n    [15, 25],       # Cashflows for trade 2\n    [100, -10, 5],  # Cashflows for trade 3\n    110             # Simple payment doesn't need to be in a list\n]\n\ndef flatten(list_of_lists):\n    for item in list_of_lists:\n        if isinstance(item, list):\n            for subitem in item:\n                yield subitem\n        else:\n            yield item\n\n# The generator does not hold all cashflows in memory\nall_cashflows_generator = flatten(trades_cashflows)\n\nfor cf in all_cashflows_generator:\n    print(cf, end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 20 30 15 25 100 -10 5 110 \n```\n:::\n:::\n\n\nThis `flatten` generator is memory-efficient. It only needs to store one cashflow at a time, regardless of the total number of cashflows.\n\n# Example: Generating the fibonacci sequence\n\nThe Fibonacci sequence is defined by the recurrence relation: $F_n = F_{n-1} + F_{n-2}$ with seed values $F_0 = 0$ and $F_1 = 1$. A naive implementation of this in Python is a direct translation of the mathematical formula:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef fibonacci_recursive(n: int):\n    \"\"\"Calculate the nth Fibonacci number using a recursive approach.\"\"\"\n    if n < 0:\n        raise ValueError(\"Fibonacci is not defined for negative numbers\")\n    \n    if n < 2:\n        return n\n\n    return fibonacci_recursive(n) + fibonacci_recursive(n-1)\n```\n:::\n\n\nFor `n=40`, this already takes a long amount of time. We are doing lot of rework. Another way to solve this problem is to use an iterative approach.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef fibonacci_iterative(n: int):\n    \"\"\"Calculate the nth Fibonacci number using an iterative approach.\"\"\"\n    if n < 0:\n        raise ValueError(\"Fibonacci is not defined for negative numbers\")\n\n    if n < 2:\n        return n\n\n    a, b = 0, 1\n    for _ in range(n-1):\n        a, b = b, a + b\n    \n    return b\n```\n:::\n\n\nWe can also code up a generator to produce the fibonacci sequence.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef fibonacci_generator():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\ngen = fibonacci_generator()\n\nfor i in range(10):\n    print(f\"F_{i} = {next(gen)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nF_0 = 0\nF_1 = 1\nF_2 = 1\nF_3 = 2\nF_4 = 3\nF_5 = 5\nF_6 = 8\nF_7 = 13\nF_8 = 21\nF_9 = 34\n```\n:::\n:::\n\n\n# Generator expressions\n\nList comprehensions are widely used in Python. However, many of the use-cases do not need to have the full list created in-memory. Instead, they only need to iterate over the elements one at a time. \n\nFor example, the following summation code will build a full list of squares in memory, iterate over those values, and when the reference is no longer needed, delete the list.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nsum([x**2 for x in range(10)])\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n285\n```\n:::\n:::\n\n\nMemory is conserved by using a generator expression instead.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nsum(x**2 for x in range(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n285\n```\n:::\n:::\n\n\nConsider taking the inner product of the vectors `x_vector` and `y_vector`:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nx_vector = [1,2,3,4,5]\ny_vector = [6,7,8,9,10]\n\nsum(x * y for x, y in zip(x_vector, y_vector))\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n130\n```\n:::\n:::\n\n\n# Iterators\n\nAn iterator is an object that represents a stream of data. It produces one item at a time, only when requested. This *lazy* evaluation is incredibly memory-efficient. The iterator protocol in Pythoon consists of two methods:\n\n- `__iter__()`: Returns the iterator object itself\n- `__next__()`: Returns the next item from the stream. When there are no more items, it raise a `StopIteration` exception.\n\nHaving these protocols in Python has an advantage: everyone know that Python will be familiar with this interface already, so there a sort of *standard contract*. \n\n# Example : Finding the implied volatility of European vanilla options using an iterative root-solver\n\nFor the purposes of this example, I will use the [bisection method](https://en.wikipedia.org/wiki/Bisection_method) to solve for the implied volatility of a European call option.\n\nThe bisection method makes use of the [intermediate value theorem](https://en.wikipedia.org/wiki/Intermediate_value_theorem)(IVT) from Real Analysis. The intermediate value theorem states that the image of a continuous function $f$ over an interval $(a,b)$ is an interval. If $f$ is a continuous function, it preserves intervals. If we take an interval and apply a continous function $f$ to it, the image is also an interval. It captures the intuitive notion, there are no gaps or jumps in a continuous curve. If $f$ is continuous and $f(a) < k <f(b)$, then there exists an element $c\\in(a,b)$, such that $f(c)=k$.\n\n## Iteration process \n\nWe start with an initial interval $[a,b]$, such that the function values $f(a)$ and $f(b)$ are of opposite sign. \n\n**Step 1**. We calculate the midpoint $m = (a + b)/2$. \n\n**Step 2**. Case I. If $f(a)$ and $f(m)$ have the same signs, the root must be in the right half $[m,b]$. So, we set $a=m$.\n\nCase II. If $f(m)$ and $f(b)$ have the same signs, the root must be in the left half $[a,m]$. So, we set $b=m$.\n\nWe iteratively perform steps (1) and (2) until the absolute or relative error is within a certain tolerance $\\epsilon$. \n\n:::{.text-center}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=backgrounds --implicit-standalone\n\n% Scenario 1: Root in left half\n\\begin{tikzpicture}[scale=1.2, background rectangle/.style={fill=white}, show background rectangle]\n    % Axes\n    \\draw[->] (-0.5,0) -- (5,0) node[right] {$x$};\n    \\draw[->] (0,-2.5) -- (0,2.5) node[above] {$y$};\n    \n    % Points\n    \\coordinate (a) at (0.5,0);\n    \\coordinate (b) at (4.5,0);\n    \\coordinate (m) at (2.5,0);\n    \n    % Function curve (convex)\n    \\draw[thick, blue, domain=0.5:4.5, samples=100] \n        plot (\\x, {0.3*(\\x-1.5)*(\\x-1.5) - 1.2});\n    \n    % Vertical lines and points\n    \\draw[dashed] (0.5,0) -- (0.5,{0.3*(0.5-1.5)*(0.5-1.5) - 1.2});\n    \\draw[dashed] (2.5,0) -- (2.5,{0.3*(2.5-1.5)*(2.5-1.5) - 1.2});\n    \\draw[dashed] (4.5,0) -- (4.5,{0.3*(4.5-1.5)*(4.5-1.5) - 1.2});\n    \n    % Function values\n    \\fill[red] (0.5,{0.3*(0.5-1.5)*(0.5-1.5) - 1.2}) circle (2pt) \n        node[below left] {$f(a) < 0$};\n    \\fill[red] (2.5,{0.3*(2.5-1.5)*(2.5-1.5) - 1.2}) circle (2pt) \n        node[below right] {$f(m) < 0$};\n    \\fill[red] (4.5,{0.3*(4.5-1.5)*(4.5-1.5) - 1.2}) circle (2pt) \n        node[above right] {$f(b) > 0$};\n    \n    % x-axis labels\n    \\fill (0.5,0) circle (1.5pt) node[below] {$a$};\n    \\fill (2.5,0) circle (1.5pt) node[below] {$m$};\n    \\fill (4.5,0) circle (1.5pt) node[below] {$b$};\n    \n    % Root indicator\n    \\draw[thick, red] (2.5,-0.3) -- (4.5,-0.3);\n    \\node[red] at (3.5,-0.6) {Root in $[m, b]$};\n    \n    % Title\n    \\node[align=center] at (2.5,3) {\\textbf{Scenario 1:} $f(a)$ and $f(m)$ have same sign};\n    \\node[align=center] at (2.5,2.5) {New interval: $[m, b]$};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](index_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n:::\n\n:::{.text-center}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=backgrounds --implicit-standalone\n\\begin{tikzpicture}[scale=1.2, background rectangle/.style={fill=white}, show background rectangle]\n    % Axes\n    \\draw[->] (-0.5,0) -- (5,0) node[right] {$x$};\n    \\draw[->] (0,-2.5) -- (0,2.5) node[above] {$y$};\n    \n    % Points\n    \\coordinate (a) at (0.5,0);\n    \\coordinate (b) at (4.5,0);\n    \\coordinate (m) at (2.5,0);\n    \n    % Function curve (convex)\n    \\draw[thick, blue, domain=0.5:4.5, samples=100] \n        plot (\\x, {0.3*(\\x-3.5)*(\\x-3.5) - 1.2});\n    \n    % Vertical lines and points\n    \\draw[dashed] (0.5,0) -- (0.5,{0.3*(0.5-3.5)*(0.5-3.5) - 1.2});\n    \\draw[dashed] (2.5,0) -- (2.5,{0.3*(2.5-3.5)*(2.5-3.5) - 1.2});\n    \\draw[dashed] (4.5,0) -- (4.5,{0.3*(4.5-3.5)*(4.5-3.5) - 1.2});\n    \n    % Function values\n    \\fill[red] (0.5,{0.3*(0.5-3.5)*(0.5-3.5) - 1.2}) circle (2pt) \n        node[above left] {$f(a) > 0$};\n    \\fill[red] (2.5,{0.3*(2.5-3.5)*(2.5-3.5) - 1.2}) circle (2pt) \n        node[above right] {$f(m) < 0$};\n    \\fill[red] (4.5,{0.3*(4.5-3.5)*(4.5-3.5) - 1.2}) circle (2pt) \n        node[below right] {$f(b) < 0$};\n    \n    % x-axis labels\n    \\fill (0.5,0) circle (1.5pt) node[below] {$a$};\n    \\fill (2.5,0) circle (1.5pt) node[below] {$m$};\n    \\fill (4.5,0) circle (1.5pt) node[below] {$b$};\n    \n    % Root indicator\n    \\draw[thick, red] (0.5,-0.3) -- (2.5,-0.3);\n    \\node[red] at (1.5,-0.6) {Root in $[a, m]$};\n\n    \n    % Title\n    \\node[align=center] at (2.5,3) {\\textbf{Scenario 2:} $f(m)$ and $f(b)$ have same sign};\n    \\node[align=center] at (2.5,2.5) {New interval: $[a, m]$};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](index_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\n:::\n\nA call option is the right to buy an asset at a future time $T$, at a pre-determined price $K$. A put option is the right to sell an asset at a future time $T$, at a pre-determined price $K$. \n\nVanilla options have two quote conventions - they can be quoted in terms of a price (in dollar terms) or in terms of the implied volatility. The Black-Scholes analytic formula used as a converter to convert an implied-vol quote to a price. \n\nLet $\\sigma$ be the market-implied volatility of the option. Then, the call option price is given by:\n\n$$\nC_{BS}(\\sigma) = S_t \\Phi(d_{+}) - K e^{-r(T-t)}\\Phi(d_{-})\n$$\n\nwhere \n\n$$\nd_{\\pm} = \\frac{\\log(S_t/K) + (r \\pm \\sigma^2/2)(T-t)}{\\sigma \\sqrt{T-t}}\n$$\n\nConversely, if we have the observed marker option quote $C_{BS}$, we can backout the implied volatility $\\sigma$, by solving for the root of the above equation. \n\nThus, we can define \n\n$$\nf(\\sigma) = S_t \\Phi(d_{+}) - K e^{-r(T-t)}\\Phi(d_{-}) - C_{BS}\n$$\n\nand find the root of $f$. Assume that the root lies in the interval $[0,1]$.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport math\nfrom typing import Callable\n\ndef d_plus(S, K, T, r, sigma):\n    \"\"\"d+ term of the Black formula\"\"\"\n    return (math.log(S / K) + (r + sigma**2/2) * T)/(sigma * math.sqrt(T))\n\ndef d_minus(S, K, T, r, sigma):\n    \"\"\"d- term of the Black formula\"\"\"\n    return (math.log(S / K) + (r - sigma**2/2) * T)/(sigma * math.sqrt(T))\n\ndef norm_cdf(x : float):\n    \"\"\"An approximation to standard normal CDF.\"\"\"\n    k = 1.0/(1.0 + 0.2316419*x);\n    k_sum = k*(0.319381530 + k*(-0.356563782 + k*(1.781477937 + k*(-1.821255978 + 1.330274429*k))));\n\n    if x >= 0.0:\n        return (1.0 - (1.0/(pow(2*3.14159,0.5)))*math.exp(-0.5*x*x) * k_sum);\n    else:\n        return 1.0 - norm_cdf(-x);\n  \n\ndef call_option_price(\n    S : float, K : float, r: float, T: float, sigma: float\n):\n    \"\"\"The price of European vanilla call option.\"\"\"\n    d_1 = d_plus(S, K, T, r, sigma)\n    d_2 = d_minus(S, K, T, r, sigma)\n    return S * norm_cdf(d_1) - K * math.exp(-r * T) * norm_cdf(d_2)\n\nclass BisectionSolver:\n    \"\"\"A solver that iteratively halves the search interval\"\"\"\n    def __init__(self, y_target: float,\n    a: float,\n    b: float,\n    epsilon: float,\n    g : callable):\n    \n        self.y_target = y_target\n        self.a = a\n        self.b = b\n        self.epsilon = epsilon\n        self.g = g\n        self.m = 0.5 * (self.a + self.b)\n        self.y = g(self.m)\n        self.i = 1\n\n    def __iter__(self):\n        \"\"\"Return the iterator object (self)\"\"\"\n        return self\n    \n    def __next__(self):\n        \"\"\"Advance one step to generate the next iterate\"\"\"\n        if abs(self.y - self.y_target) < self.epsilon:\n            raise StopIteration\n    \n        if self.y - self.y_target < 0:\n            self.a = self.m\n\n        if self.y - self.y_target > 0:\n            self.b = self.m\n\n        m = self.m\n        i = self.i\n        self.i += 1\n        self.m = 0.5 * (self.a + self.b)\n        self.y = self.g(self.m)\n        return (i,m)\n\nif __name__ == \"__main__\":\n    S=100\n    K=100\n    r=0.05\n    T=1.0\n    market_quote = 10.450577973198428\n\n    def g(sigma: float):\n        return call_option_price(S, K, r, T, sigma)\n\n    solver = BisectionSolver(market_quote, 0.0, 1.0, 0.5e-5, g)\n    \n    for iter in solver:\n        i, root = iter\n        print(f\"Iteration# : {i}, root estimate : {root}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration# : 1, root estimate : 0.5\nIteration# : 2, root estimate : 0.25\nIteration# : 3, root estimate : 0.125\nIteration# : 4, root estimate : 0.1875\nIteration# : 5, root estimate : 0.21875\nIteration# : 6, root estimate : 0.203125\nIteration# : 7, root estimate : 0.1953125\nIteration# : 8, root estimate : 0.19921875\nIteration# : 9, root estimate : 0.201171875\nIteration# : 10, root estimate : 0.2001953125\nIteration# : 11, root estimate : 0.19970703125\nIteration# : 12, root estimate : 0.199951171875\nIteration# : 13, root estimate : 0.2000732421875\nIteration# : 14, root estimate : 0.20001220703125\nIteration# : 15, root estimate : 0.199981689453125\nIteration# : 16, root estimate : 0.1999969482421875\nIteration# : 17, root estimate : 0.20000457763671875\nIteration# : 18, root estimate : 0.20000076293945312\nIteration# : 19, root estimate : 0.1999988555908203\nIteration# : 20, root estimate : 0.19999980926513672\nIteration# : 21, root estimate : 0.20000028610229492\n```\n:::\n:::\n\n\nWe see that a $1$-year call option struck at $K=100$ with the underlying spot at $100$, annualised interest rate $r=0.05$ with market price $C_{BS}=10.45$ corresponds to an implied volatility of $\\sigma_{BS}=0.20$. \n\nWhile this toy solver uses the Bisection algorithm, the bisection method has a slow rate of convergence. The [Brent-Dekker](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brentq.html) algorithm is considered the industry standard for root finding.\n\nMany numerical solvers for finding roots, finding solutions of ODEs and PDEs are iterative in nature.\n\n# Challenge question\n\nHere is a challenge question to test your understanding. Observe the code snippet below. What will `print(type(t))` output?\n\n```python\nlst = [1,2,3,4,5,6,7,8,9,10]\n\nl = [n ** n for n in lst]\ns = {n ** n for n in lst}\nd = {n : n **n for n in lst}\nt = (n ** n for n in lst)\n\nprint(type(l))\nprint(type(s))\nprint(type(d))\nprint(type(t))\n```\n\nFor more such questions, visit [getcracked.io](https://getcracked.io/). \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}