{
  "hash": "256165744590d3424116fa0349a476ed",
  "result": {
    "markdown": "---\ntitle: \"Generators, iterators and asynchronous programming\"\nauthor: \"Quasar\"\ndate: \"2025-11-24\"\ncategories: [Python]      \nimage: \"python.svg\"\ntoc: true\ntoc-depth: 3\n---\n\n# What is a generator?\n\nA generator is a function that uses the `yield` keyword to return an item. When a generator function is called, it returns a generator object, which is a type of iterator. Here is a simple generator, that produces a sequence of numbers:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef number_generator(n):\n    for i in range(n):\n        yield i\n\ngen = number_generator(1_000_000)\n\nprint(next(gen))\nprint(next(gen))\nprint(next(gen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\nThe state of the generator is saved between `yield` calls. This allows it to resume where it left off.\n\nThe main use of generators is to save memory - instead of having a very large list of elements in memory, holding everythinat once, we have an object that knows how to produce each particular element, one at a time. This enables lazy computations of heavy objects in memory\n\n# Example: Flattening a list of lists\n\nA common task is to flatten a list of lists into a single list. \n\nImagine you have a list of trades\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}