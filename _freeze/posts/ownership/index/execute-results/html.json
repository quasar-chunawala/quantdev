{
  "hash": "44c9d987e782ea4412d4da10522443cc",
  "result": {
    "markdown": "---\ntitle: Ownership\nauthor: Quasar\ndate: '2025-11-17'\ncategories:\n  - Rust\nimage: Rust-4.png\ntoc: true\ntoc-depth: 3\n---\n\n# Ownership\n## Introduction\n\nOwnership is the most important feature of Rust. It allows Rust to be memory-safe and efficient, while avoiding garbage collection. Consider the below mistake that all of us who have used a non-GC'd language have made at one point:\n\n```rust\nfn as_str(data: &u32) -> &str{\n    // Compute the string\n    let s = format!(\"{}\", data);\n\n    // Oh No! We returned a reference to something that\n    // only exists in this function.\n    // Dangling reference! Alas!\n    return &s;\n}\n\npub fn main(){\n    let x : u32 = 42;\n    as_str(&x);\n}\n```\n[Compiler Explorer](https://compiler-explorer.com/z/f36h87bn1)\n\n```shell\n[quantdev@quasar-arch ownership]$ rustc ./dangling_reference.rs -o ./dangling_reference\nerror[E0515]: cannot return reference to local variable `s`\n --> ./dangling_reference.rs:8:12\n  |\n8 |     return &s;\n  |            ^^ returns a reference to data owned by the current function\n\nerror: aborting due to 1 previous error\n```\n\n## References\n\nThere are two kinds of references:\n\n- Immutable reference `&`\n- Mutable reference `&mut`\n\nwhich obey the following rules:\n\n- A reference cannot outlive its referent.\n- A mutable reference cannot be aliased.\n\n## Aliasing\n\nConsider this simple function:\n\n```rust\nfn compute(input: &u32, output: &mut u32){\n    if *input > 10{\n        *output = 1;\n    }\n    if *input > 5{\n        *output *= 2;\n    }\n}\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}