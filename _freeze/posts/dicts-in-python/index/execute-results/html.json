{
  "hash": "1949c6cc45b4e724fdf36c0d950adef8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python list, dicts, tuples\"\nauthor: \"Quasar\"\ndate: \"2025-03-05\"\ncategories: [Python]      \nimage: \"python.jpeg\"\ntoc: true\ntoc-depth: 3\nformat:\n    html:\n        code-tools: true\n        code-block-border-left: true\n        code-annotations: below\n        highlight-style: pygments\n---\n\n\n\n\n## `dict` in Python\n\nPython `dict`s are a collection of key-value pairs implemented as hash tables. `dict`s can be updated in place and dictionaries can grow and shrink as needed.\n\n## Flattening a `dict` of `dict`s\n\n::: {#4702d81e .cell execution_count=1}\n``` {.python .cell-code}\nquote_types = {\n    'Bids' : {\n        1 : [10, 45],\n        2 : [25, 47.5],\n        3 : [30, 49.5]\n    },\n    'Offers' : {\n        1 : [30, 50.5],\n        2 : [25, 52.5],\n        3 : [10, 55]\n    }\n}\n\ndict_of_height_3 ={\n    'a' : {\n        'b' :{\n            'c' : 1,\n            'd' : 2,\n        },\n        'e' : {\n            'f' : 3,\n            'g' : 4,\n        }\n    },\n    'h' : {\n        'i' : {\n            'j' : 5,\n            'k' : 6,\n        },\n        'l' : {\n            'm' : 7,\n            'n' : 8,\n        },\n    }\n}\n\ndef flatten_dict(d : dict, parent_key = '', sep = '_'):\n    result = {}\n    for k,v in d.items():\n        if (type(v) is dict):\n            # Recursively flatten the child element\n            child_flat_dict = flatten_dict(v, parent_key=str(k))\n\n            # We now have a dict-of-dicts of height 2\n            for child_k, child_v in child_flat_dict.items():\n                key = parent_key + sep + child_k if parent_key > '' else child_k\n                result[key] = child_v\n        else:\n            key = parent_key + sep + str(k)\n            result[key] = v\n            \n    return result\n\nprint(\"flattening quotes\\n\")\nflatten_dict(quote_types)\n\nprint(\"dict_of_height_3\\n\")\nflatten_dict(dict_of_height_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nflattening quotes\n\ndict_of_height_3\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n{'a_b_c': 1,\n 'a_b_d': 2,\n 'a_e_f': 3,\n 'a_e_g': 4,\n 'h_i_j': 5,\n 'h_i_k': 6,\n 'h_l_m': 7,\n 'h_l_n': 8}\n```\n:::\n:::\n\n\n## `list()` in Python\n\n`list.append(x:Any)->None` adds a single-item to the end of the list, *in-place*. `list.extend(Iterable)->None` extends the list *in-place* by appending all items from the iterable, and returns `None`. \n\n`list.insert(i,x)->None` inserts an element `x` at the given index `i`. `list.remove(x)` removes the first item from the list who value is equal to `x`. `list.pop([i])` removes the item at the given position in the list and returns it. If no index is specified, `list.pop()` removes and returns the last element in the list.\n\n## Reverse a list\n\n::: {#1cae2b12 .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import List\nl = [1, 2, 3, 4, 5]\n\nl.reverse()  # reverse in place\nprint(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n::: {#b0fb531d .cell execution_count=3}\n``` {.python .cell-code}\n# recursive solution\ndef reverse(l : List, acc : List = []) -> List:\n    if(len(l) == 0):\n        return acc\n    \n    if(len(l) == 1):\n        l.extend(acc)\n        return l\n    \n    new_acc = [l[0]]\n    new_acc.extend(acc)\n    return reverse(l[1:], new_acc)\n\ndef reverse_iter(l : List) -> List:\n    result = []\n    for element in l:\n        result.insert(0, element)\n\n    return result\n\nitems = [2, 17, 42, 15, 3]\nreverse(items)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[3, 15, 42, 17, 2]\n```\n:::\n:::\n\n\n## Determine if the list is a palindrome\n\n::: {#6feb6b17 .cell execution_count=4}\n``` {.python .cell-code}\nfrom typing import List\ndef is_palindrome(l : List) -> bool:\n    n = len(l)\n    i = 0\n    j = n - 1\n\n    while(i <= j):\n        if(l[i] != l[j]):\n            return False\n        \n        i += 1\n        j = n - i - 1\n\n    return True\n\nis_palindrome([1, 2, 3, 2, 1])\nis_palindrome([1, 2, 2, 1])\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nTrue\n```\n:::\n:::\n\n\n## Flatten a nested list\n\n::: {#a617f2ef .cell execution_count=5}\n``` {.python .cell-code}\ndef flatten_list(l : List):\n    result = []\n    for element in l:\n        if (type(element) is list):\n            simple_list = flatten_list(element)\n            result.extend(simple_list)\n        else:\n            result.append(element)\n    return result\n\nflatten_list(['a', ['b', ['c', 'd'], 'e']])\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n['a', 'b', 'c', 'd', 'e']\n```\n:::\n:::\n\n\n## Eliminate consecutive duplicates of list elements\n\nAlways use `key in my_dict` directly instead of `key in my_dict.keys()`,\nif you want to check the existence of a key in a `dict`. That will use \nthe dictionary's $O(1)$ hashing rather than $O(n)$. `my_dict.keys()`\nreturns a list of keys.\n\n::: {#8d2db371 .cell execution_count=6}\n``` {.python .cell-code}\nfrom typing import List\n\n# Remove duplicates from a nested-list while preserving the\n# the structure\ndef array_unique(l : List, unique_elements : dict={}) -> (List,dict):\n    result = []\n    for element in l:\n        if type(element) is list:\n            # get the list of unique children and append it to result\n            child_list, unique_elements = array_unique(element, unique_elements=unique_elements)\n            result.append(child_list)\n        else:\n            if element in unique_elements:\n                continue\n            else:\n                result.append(element)\n                unique_elements[element] = True\n\n    return result, unique_elements\n\nmy_array = [1, [1, 2, [1, 2, 3], 4, 5], [5, 6], 7]\nresult, _ = array_unique(my_array)\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n[1, [2, [3], 4, 5], [6], 7]\n```\n:::\n:::\n\n\n## List comprehensions\n\n::: {#9f54992e .cell execution_count=7}\n``` {.python .cell-code}\nsquares = [x**2 for x in range(5)]\nsquares\ncombs = [(x,y,z) for x in range(2) for y in range(2) for z in range(2)]\ncombs\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n[(0, 0, 0),\n (0, 0, 1),\n (0, 1, 0),\n (0, 1, 1),\n (1, 0, 0),\n (1, 0, 1),\n (1, 1, 0),\n (1, 1, 1)]\n```\n:::\n:::\n\n\n## Nested List comprehensions\n\n::: {#e5d4b3d5 .cell execution_count=8}\n``` {.python .cell-code}\nmatrix = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n]\n\n# Take the transpose of a matrix\n[[row[i] for row in matrix]for i in range(4)]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}