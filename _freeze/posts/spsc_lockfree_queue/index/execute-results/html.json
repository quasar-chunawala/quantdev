{
  "hash": "4760a865353e1362edcd33326181b993",
  "result": {
    "markdown": "---\ntitle: \"Lock-free SPSC Queue\"\nauthor: \"Quasar\"\ndate: \"2025-12-05\"\ncategories: [C++]      \nimage: \"cpp.jpg\"\ntoc: true\ntoc-depth: 3\n---\n\n# Designing the `spsc_queue` data-structure\n\nI would like to present my implementation for an SPSC lock-free queue in this blog-post.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n%load_ext itikz\n```\n:::\n\n\n## What makes an operation atomic?\n\nWhen a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:\n\n- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). \n- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. \n\n## Setup - How the queue works\n\n- Bounded size. The elements are stored in a fixed-length buffer.\n- Single-producer, Single-consumer applications. \n- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.\n\nThe `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:\n\n- `m_head` - The index of the `front` element, if any.\n- `m_tail` - The index where a new element would be inserted at the back of the queue.\n\nIn an initially empty container, both the `m_head` and `m_tail` start at zero:\n\n:::{text-center}\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (Empty)}};\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    \n    % Pointers\n    \\draw[->, thick] (0, -3.2) -- (0, -2.8);\n    \\node[anchor=north] at (0, -3.2) {m\\_head = 0};\n    \\node[anchor=north] at (0, -3.6) {m\\_tail = 0};\n    \n    % Status\n    \\node[anchor=north] at (4, -4.2) {Status: Empty (m\\_head == m\\_tail)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](index_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n:::\n\nThen I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. \n\nFor example, if do `push_back(1)` the queue looks something like this. \n\n:::{text-center}\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (1 element)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (0, -0.8) {m\\_head = 0};\n    \\draw[->, thick] (0, -1.0) -- (0, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill first cell\n    \\fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);\n    \\node at (0, -2.5) {1};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (1, -3.2) -- (1, -2.8);\n    \\node[anchor=north] at (1, -3.2) {m\\_tail = 1};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 1 element (m\\_tail > m\\_head)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n:::\n\nHere's the queue with a few more elements added:\n\n:::{text-center}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (4 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (0, -0.8) {m\\_head = 0};\n    \\draw[->, thick] (0, -1.0) -- (0, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 0-3\n    \\fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\node at (0, -2.5) {1};\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (4, -3.2) -- (4, -2.8);\n    \\node[anchor=north] at (4, -3.2) {m\\_tail = 4};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 4 elements (m\\_tail > m\\_head)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n:::\n\nOnce I have got some elements into the queue, I can go ahead and call the `pop()` function, which is going to try to read and remove the first element from the front of the queue.\n\nIf the queue isn't empty, it :\n\n- Advances `m_head` thereby implicitly discard the element at the front of the queue\n\n:::{text-center}\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (3 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (1, -0.8) {m\\_head = 1};\n    \\draw[->, thick] (1, -1.0) -- (1, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 1-3\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (4, -3.2) -- (4, -2.8);\n    \\node[anchor=north] at (4, -3.2) {m\\_tail = 4};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 3 elements (m\\_tail > m\\_head)};\n    \\node[anchor=north] at (4, -4.2) {Note: Index 0 is now \"stale\" (logically removed)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n:::\n\nMost of the time, when we advance an index like this, it is a simple increment. But, as I stated earlier, the buffer slots are used in a a circular fashion. If that increment would place that `index` out of bounds, it wraps around to the zeroeth slot (that's what makes it a ring) of the queue buffer.\n\n:::{text-center}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (7 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (1, -0.8) {m\\_head = 1};\n    \\draw[->, thick] (1, -1.0) -- (1, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 1-7\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\fill[lightgray!30] (3.6, -2.2) rectangle (4.4, -2.8);\n    \\fill[lightgray!30] (4.6, -2.2) rectangle (5.4, -2.8);\n    \\fill[lightgray!30] (5.6, -2.2) rectangle (6.4, -2.8);\n    \\fill[lightgray!30] (6.6, -2.2) rectangle (7.4, -2.8);\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \\node at (4, -2.5) {8};\n    \\node at (5, -2.5) {13};\n    \\node at (6, -2.5) {21};\n    \\node at (7, -2.5) {34};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (0, -3.2) -- (0, -2.8);\n    \\node[anchor=north] at (0, -3.2) {m\\_tail = 0};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n:::\n\nAs we'll see, it turns out that the indices `m_head` and `m_tail` will need to be `atomic` objects. We'll understand why this is the case.\n\nThe storage for a ring buffer consists of a fixed-capacity array of elements and the indices for `head` and `tail`. We shall write `spsc_queue` as a templated class having the capacity as a template parameter. \n\n```cpp\ntemplate<typename T, size_t capacity>\nclass spsc_queue{\n    private:\n    // The capacity must be a power of two.\n    static_assert((capacity & (capacity - 1)) == 0);    \n    T m_buffer[capacity];\n    size_t m_head;\n    size_t m_tail;\n    public:\n        /* ... */\n};\n```\n\nWe would like to enforce the capacity to be a power of $2$ for efficiency reasons. Remember, that with this design, there's always atleast one unused element in the array, because `m_head == m_tail + 1` is the queue full condition. So, the effective capacity equals `capacity - 1`. \n\n## The `class` interface\n\nHere is the class interface:\n\n```cpp\ntemplate<typename T, size_t capacity>\nclass spsc_queue{\n    private:\n    // The capacity must be a power of two.\n    static_assert((capacity & (capacity - 1)) == 0);    \n    T m_buffer[capacity];\n    size_t m_head;\n    size_t m_tail;\n    public:\n        using value_type = T;\n        spsc_queue();\n        bool is_empty() const;\n        bool is_full() const;\n        bool push_back(value_type& item);\n        bool pop_front();\n};\n```\n\n# `push_back()` and `pop_front()` take 1\n\nHere's a first attempt at implementing `pop()`:\n\n```cpp\nsize_t next(size_t idx)\n{\n    if(++idx >= m_size)\n        idx = 0;\n    return idx;\n}\n\nbool pop_front()\n{\n    value_type v;\n    if(!is_empty()){\n        v = m_buffer[m_head];\n        m_head = next(m_head);\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n```\n\nUnfortunately, this section of code for advancing `m_head` has a couple of problems. The increment of `m_head` could be pre-empted in the middle. And that's a problem because the `push` thread also reads the `m_head` index in order to figure out, whether the queue is full. \n\nNote that, `push_back()` is always called by the producer thread while `pop_front()` is always called by the consumer thread. \n\nThat's why, the `spsc_queue`'s design depends on:\n\n- Reading and writing the indices non-pre-emptively.\n- Having only one producer thread and one consumer thread.\n\nif the consumer thread is pre-empted while writing `m_head`, the producer thread may read a half-written nonsense value.\n\n```cpp\nbool push_back(value_type& v)\n{\n    if(!is_full()){\n        m_buffer[m_tail] = v;\n        m_tail = next(m_tail);\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n```\n\nIf the producer thread is pre-empted while writing `m_tail`, the consumer thread may read a half-written nonsense value.\n\n## Using atomic indices\n\nThis is my implementation for SPSC lock-free queue with atomic indices. \n\n```cpp\n#include <atomic>\n#include <thread>\n\ntemplate<typename T, size_t capacity>\nclass spsc_queue{\n    private:\n    // The capacity must be a power of two.\n    static_assert((capacity & (capacity - 1)) == 0);    \n    T m_buffer[capacity];\n    alignas(std::hardware_destructive_interference_size) std::atomic<size_t> m_head;\n    alignas(std::hardware_destructive_interference_size) std::atomic<size_t> m_tail;\n\n    public:\n        using value_type = T;\n        spsc_queue()\n        : m_buffer{}\n        , m_head{0}\n        , m_tail{0}\n        {}\n\n        [[nodiscard]] bool is_empty() const{\n            return m_head.load()\n                == m_tail.load();\n        }\n\n        [[nodiscard]] bool is_full() const{\n            return m_tail.load() + 1 == m_head.load();\n        }\n\n        [[nodiscard]] size_t get_size(){\n            return m_tail.load() - m_head.load() + 1;\n        }\n\n        [[nodiscard]] size_t get_capacity(){\n            return capacity - 1;\n        }\n\n        [[nodiscard]] size_t next(size_t current_idx)\n        {\n            size_t next_idx = current_idx & (capacity - 1);\n            return next_idx;\n        }\n\n        bool push_back(value_type& item){\n            size_t tail = m_tail.load(std::memory_order_relaxed);\n            size_t next_write_index = next(tail);\n            if(next_write_index == m_head.load(std::memory_order_acquire))\n                return false;\n\n            m_buffer[tail] = item;\n            m_tail.store(next_write_index, std::memory_order_release);\n            return true;\n        }\n\n        bool pop_front(value_type& v){\n            size_t head = m_head.load(std::memory_order_relaxed);\n            if(head == m_tail.load(std::memory_order_acquire))\n                return false;\n\n            v = m_buffer[head];\n            size_t next_read_index = next(m_head);\n            m_head.store(next_read_index, std::memory_order_release);\n            return true;\n        }\n};\n```\n\n### Why do we use a power of $2$ buffer size?\n\nFor a buffer of fixed capacity $N$, with current index `idx`, the index to the next element can be calculated as:\n\n```cpp\nnext_idx = (curr_idx + 1) % N\n```\n\nThis is because our queue is a ring buffer, so after the last slot, we will go back to the zeroeth one, then the first one and so on. \n\nWe can use the above method to get the next index for any buffer size $N$. Why do we then only use capacity that are powers of $2$? The answer is easy: performance. The modulo (`%`) operator requires a division instruction, which is expensive. When the size $N$ is a power of $2$, we can just do the following:\n\n```cpp\nsize_t next_index = curr_index & (N - 1);\n```\n\n### Buffer access synchronization\n\n![Synchronization](diagram-20251206.png){fig-align=\"center\"}\n\nHere's what the actual execution order looks like after we make the indices atomic. \n\nIf we look at the push thread, the incremented value of the tail, `next_write_index` written to `m_tail` index is a release operation. Over on the pop thread, when we load the `m_tail` index (take a snapshot of it), this is an acquire operation. The combination of release and acquire on the same atomic variable implies that `m_tail` store in the push thread synchronizes with `m_tail` load on the pop thread. \n\nThe instruction `m_buffer[tail] = item` cannot be moved to after the release barrier in actual CPU execution order. The instrusction `v=m_buffer[head]` cannot be moved to before the acquire barrier in actual CPU exection order. So, we have happens-before relationship between these two instructions.\n\nThe release of `m_head` in the pop thread synchronizes with the acquire of `m_head` in the push thread. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}