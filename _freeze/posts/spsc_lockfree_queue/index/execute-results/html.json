{
  "hash": "0f6459118cb1767b268866ce4cdcbfe9",
  "result": {
    "markdown": "---\ntitle: \"Lock-free SPSC Queue\"\nauthor: \"Quasar\"\ndate: \"2025-12-05\"\ncategories: [C++]      \nimage: \"cpp.jpg\"\ntoc: true\ntoc-depth: 3\n---\n\n# Designing the `spsc_queue` data-structure\n\nI would like to present my implementation for an SPSC lock-free queue in this blog-post.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n%load_ext itikz\n```\n:::\n\n\n## What makes an operation atomic?\n\nWhen a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:\n\n- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). \n- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. \n\n## Setup - How the queue works\n\n- Bounded size. The elements are stored in a fixed-length buffer.\n- Single-producer, Single-consumer applications. \n- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.\n\nThe `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:\n\n- `m_head` - The index of the `front` element, if any.\n- `m_tail` - The index where a new element would be inserted at the back of the queue.\n\nIn an initially empty container, both the `m_head` and `m_tail` start at zero:\n\n:::{text-center}\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (Empty)}};\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    \n    % Pointers\n    \\draw[->, thick] (0, -3.2) -- (0, -2.8);\n    \\node[anchor=north] at (0, -3.2) {m\\_head = 0};\n    \\node[anchor=north] at (0, -3.6) {m\\_tail = 0};\n    \n    % Status\n    \\node[anchor=north] at (4, -4.2) {Status: Empty (m\\_head == m\\_tail)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](index_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n:::\n\nThen I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. \n\nFor example, if do `push_back(1)` the queue looks something like this. \n\n:::{text-center}\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (1 element)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (0, -0.8) {m\\_head = 0};\n    \\draw[->, thick] (0, -1.0) -- (0, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill first cell\n    \\fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);\n    \\node at (0, -2.5) {1};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (1, -3.2) -- (1, -2.8);\n    \\node[anchor=north] at (1, -3.2) {m\\_tail = 1};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 1 element (m\\_tail > m\\_head)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n:::\n\nHere's the queue with a few more elements added:\n\n:::{text-center}\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (4 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (0, -0.8) {m\\_head = 0};\n    \\draw[->, thick] (0, -1.0) -- (0, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 0-3\n    \\fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\node at (0, -2.5) {1};\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (4, -3.2) -- (4, -2.8);\n    \\node[anchor=north] at (4, -3.2) {m\\_tail = 4};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 4 elements (m\\_tail > m\\_head)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n:::\n\nOnce I have got some elements into the queue, I can go ahead and call the `pop()` function, which is going to try to read and remove the first element from the front of the queue.\n\nIf the queue isn't empty, it :\n\n- Advances `m_head` thereby implicitly discard the element at the front of the queue\n\n:::{text-center}\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (3 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (1, -0.8) {m\\_head = 1};\n    \\draw[->, thick] (1, -1.0) -- (1, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 1-3\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (4, -3.2) -- (4, -2.8);\n    \\node[anchor=north] at (4, -3.2) {m\\_tail = 4};\n    \n    % Status\n    \\node[anchor=north] at (4, -3.8) {Status: 3 elements (m\\_tail > m\\_head)};\n    \\node[anchor=north] at (4, -4.2) {Note: Index 0 is now \"stale\" (logically removed)};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n:::\n\nMost of the time, when we advance an index like this, it is a simple increment. But, as I stated earlier, the buffer slots are used in a a circular fashion. If that increment would place that `index` out of bounds, it wraps around to the zeroeth slot (that's what makes it a ring) of the queue buffer.\n\n:::{text-center}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show the code\"}\n%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone\n\\begin{tikzpicture}[font=\\small\\ttfamily]\n    \\fill[white] (-2, 0.5) rectangle (8.5, -4.8);\n    % Title\n    \\node[anchor=north] at (4, 0) {\\textbf{SPSC Ring Buffer (7 elements)}};\n    \n    % m_head pointer (above)\n    \\node[anchor=south] at (1, -0.8) {m\\_head = 1};\n    \\draw[->, thick] (1, -1.0) -- (1, -1.4);\n    \n    % Index labels\n    \\node[anchor=east] at (-0.2, -1.5) {Index:};\n    \\foreach \\i in {0,...,7} {\n        \\node at (\\i, -1.5) {\\i};\n    }\n    \n    % Buffer cells\n    \\node[anchor=east] at (-0.2, -2.5) {Buffer:};\n    \\foreach \\i in {0,...,7} {\n        \\draw (\\i-0.4, -2.2) rectangle (\\i+0.4, -2.8);\n    }\n    % Fill cells 1-7\n    \\fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);\n    \\fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);\n    \\fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);\n    \\fill[lightgray!30] (3.6, -2.2) rectangle (4.4, -2.8);\n    \\fill[lightgray!30] (4.6, -2.2) rectangle (5.4, -2.8);\n    \\fill[lightgray!30] (5.6, -2.2) rectangle (6.4, -2.8);\n    \\fill[lightgray!30] (6.6, -2.2) rectangle (7.4, -2.8);\n    \\node at (1, -2.5) {2};\n    \\node at (2, -2.5) {3};\n    \\node at (3, -2.5) {5};\n    \\node at (4, -2.5) {8};\n    \\node at (5, -2.5) {13};\n    \\node at (6, -2.5) {21};\n    \\node at (7, -2.5) {34};\n    \n    % m_tail pointer (below)\n    \\draw[->, thick] (0, -3.2) -- (0, -2.8);\n    \\node[anchor=north] at (0, -3.2) {m\\_tail = 0};\n\\end{tikzpicture}\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n:::\n\nAs we'll see, it turns out that the indices `m_head` and `m_tail` will need to be `atomic` objects. We'll understand why this is the case.\n\nThe storage for a ring buffer consists of a fixed-capacity array of elements and the indices for `head` and `tail`. We shall write `spsc_queue` as a templated class having the capacity as a template parameter. \n\n```cpp\ntemplate<typename T, size_t capacity>\nclass spsc_queue{\n    private:\n    // The capacity must be a power of two.\n    static_assert((capacity & (capacity - 1)) == 0);    \n    T m_buffer[capacity];\n    size_t m_head;\n    size_t m_tail;\n    public:\n        /* ... */\n};\n```\n\nWe would like to enforce the capacity to be a power of $2$ for efficiency reasons. Remember, that with this design, there's always atleast one unused element in the array, because `m_head == m_tail + 1` is the queue full condition. So, the effective capacity equals `capacity - 1`. \n\n## The `class` interface\n\nHere is the class interface:\n\n```cpp\ntemplate<typename T, size_t capacity>\nclass spsc_queue{\n    private:\n    // The capacity must be a power of two.\n    static_assert((capacity & (capacity - 1)) == 0);    \n    T m_buffer[capacity];\n    size_t m_head;\n    size_t m_tail;\n    public:\n        /* ... */\n};\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}