{
  "hash": "3f72954629293ccaa61b48a04748113b",
  "result": {
    "markdown": "---\ntitle: \"Lock-free SPSC Queue\"\nauthor: \"Quasar\"\ndate: \"2025-12-05\"\ncategories: [C++]      \nimage: \"cpp.jpg\"\ntoc: true\ntoc-depth: 3\n---\n\n# Designing the `spsc_queue` data-structure\n\nI would like to present my implementation for an SPSC lock-free queue in this blog-post.\n\n## What makes an operation atomic?\n\nWhen a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:\n\n- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). \n- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. \n\n## Setup - How the queue works\n\n- Bounded size. The elements are stored in a fixed-length buffer.\n- Single-producer, Single-consumer applications. \n- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.\n\nThe `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:\n\n- `m_head` - The index of the `front` element, if any.\n- `m_tail` - The index where a new element would be inserted at the back of the queue.\n\nIn an initially empty container, both the `m_head` and `m_tail` start at zero:\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                   SPSC Ring Buffer (Empty)                  │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│   Index:   0    1    2    3    4    5    6    7             │\n│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │\n│  Buffer: │    │    │    │    │    │    │    │    │          │\n│          └────┴────┴────┴────┴────┴────┴────┴────┘          │\n│            ▲                                                │\n│            │                                                │\n│        m_head = 0                                           │\n│        m_tail = 0                                           │\n│                                                             │\n│   Status: Empty (m_head == m_tail)                          │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\nThen I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. \n\nFor example, if do `push_back(1)` the queue looks something like this. \n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                 SPSC Ring Buffer (1 element)                │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│   Index:   0    1    2    3    4    5    6    7             │\n│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │\n│  Buffer: │ 1  │    │    │    │    │    │    │    │          │\n│          └────┴────┴────┴────┴────┴────┴────┴────┘          │\n│            ▲    ▲                                           │\n│            │    │                                           │\n│        m_head   m_tail = 1                                  │\n│         = 0                                                 │\n│                                                             │\n│   Status: 1 element (m_tail > m_head)                       │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\nHere's the queue with a few more elements added:\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                 SPSC Ring Buffer (4 elements)               │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│   Index:   0    1    2    3    4    5    6    7             │\n│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │\n│  Buffer: │ 1  │ 2  │ 3  │ 5  │    │    │    │    │          │\n│          └────┴────┴────┴────┴────┴────┴────┴────┘          │\n│            ▲                   ▲                            │\n│            │                   │                            │\n│        m_head = 0          m_tail = 4                       │\n│                                                             │\n│   Status: 4 elements (m_tail > m_head)                      │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Interactive SPSC Queue Demo\n\nYou can try the SPSC queue implementation in real-time using Compiler Explorer:\n\n\n```{html}\n<button onclick=\"compileCode()\">Compile & Run</button>\n<pre id=\"output\"></pre>\n\n<script>\nasync function compileCode() {\n    const code = `\n#include <iostream>\nint main() {\n    std::cout << \"Hello from SPSC Queue\\n\";\n    return 0;\n}\n    `;\n\n    const payload = {\n        source: code,\n        compiler: 'g121',  // GCC 12.1\n        options: '-O2 -std=c++20'\n    };\n\n    try {\n        const response = await fetch('https://godbolt.org/api/compile', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(payload)\n        });\n        \n        const result = await response.json();\n        document.getElementById('output').textContent = \n            result.stdout || result.stderr || result.code;\n    } catch (error) {\n        document.getElementById('output').textContent = 'Error: ' + error;\n    }\n}\n</script>\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}