{
  "hash": "e994e08a9241a75dd2126c15c08b4092",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Concurrency features in Python\"\nauthor: \"Quasar\"\ndate: \"2025-02-28\"\ncategories: [Python]      \nimage: \"cpp.jpg\"\ntoc: true\ntoc-depth: 3\nformat:\n    html:\n        code-tools: true\n        code-block-border-left: true\n        code-annotations: below\n        highlight-style: pygments\n---\n\n\n\n\n## Basics\n\nIn single-core processors, the machine can only perform one task at a time, but can switch between many tasks many times per second. By doing a bit of one task and then a bit of another and so on, it appears that the tasks are happening concureently. This is called *task switching*. Because the task switches are so fast, it provides an illusion of concurrency to both the user and the applications.\n\nOn a single-core maching doing task switching, chunks from each task are interleaved. But, they are also spaced out a bit; in order to do the interleaving, the operating system has to perform a *context switch* every time it changes from one task to another, and this takes time. In order to perform a context switch, the OS has to save the CPU state and the instruction pointer for the currently running task, work out which task to switch to, and reload the CPU state for the task being switched to.\n\nMulti-core processors are genuinely capable of running more than one task in parallel. This is called *hardware concurrency*. \n\n### Throughput and Latency \n\nThe rate of doing work (operations per second) is called *throughput*. The response time it takes for a system to process a request is called *latency*.\n\n### Synchronous vs Asynchronous\n\nSynchronous execution is sequential. \n\n::: {#b82de157 .cell execution_count=1}\n``` {.python .cell-code}\ndef foo():\n    print(f\"Inside foo.\")\n\ndef main():\n    print(f\"Starting work.\")\n    foo()\n    print(f\"Finishing work.\")\n\nmain()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting work.\nInside foo.\nFinishing work.\n```\n:::\n:::\n\n\nIn the `main()` code-path, the call to `foo()` is a blocking call, the execution jumps to `foo()` and `main()` resumes when `foo()` returns.\n\nAsynchronous(or *async*) execution refers to execution that doesn't block when invoking subroutines. It is a *fire-and-forget* technique. Any work package runs separately from the main application thread and notifies the calling thread of its completion, failure or progress. \n\nUsually, such methods return an entity called `future` or `promise` that is the representation of an in-progress computation. The calling thread can query for the status of the computation via the returned future or promise and retrieve the result once completed. \n\nAnother pattern is to pass a callback function to the asynchronous functional call, which is invoked with the results when the asynchronous function is done processing. \n\nAsynchronous programming is an execllent choice for applications that do extensive network or disk I/O and spend most of their time waiting.\n\n### I/O bound vs CPU bound\n\n#### CPU bound\n\nPrograms that are compute-intensive are called CPU bound programs. This could involve numerical optimizations, Monte-Carlo simulations, data-crunching etc.\n\n#### I/O bound\n\nI/O bound programs spend most of their time doing network or main memory and file I/O operations. Since the CPU and main memory are separate, a bus exists between the two to transfer bits. Similarly, data needs to moved from the NIC to CPU/memory. Even though these physical distances are small, the time taken to transfer the data can waste a few thousand CPU cycles. This is why I/O bound programs show relatively lower CPU utilization than CPU bound programs.\n\n### Data race-conditions and thread safety\n\nThe most common cause of bugs in concurrent code is a *race-condition*. \n\n::: {#ea52bd26 .cell execution_count=2}\n``` {.python .cell-code}\nimport concurrent.futures\nimport logging\nimport time\nimport concurrent\nimport threading\n\nclass Account:\n    def __init__(self):\n        self.value = 0\n\n    @property\n    def value(self):\n        return self._value\n    \n    @value.setter\n    def value(self, x):\n        self._value = x\n    \n    def credit(self, name : str, amount : float):\n        logging.info(\"Thread %s: starting update\", name)\n        \n        # ----- Critical section -----\n        local_copy = self.value     \n        local_copy += amount\n        time.sleep(0.1)\n        self.value = local_copy\n        # ----- End of critical section -----\n\n        logging.info(\"Thread %s: finishing update\", name)\n\nif __name__ == \"__main__\":\n    format = \"%(asctime)s: %(message)s\"\n    logging.basicConfig(format=format, level=logging.INFO, datefmt=\"%H:%M:%S\")\n    account = Account()\n    logging.info(\"Testing update. Starting value is %d.\", account.value)\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:\n        for index in range(2):\n            executor.submit(account.credit, index, 100)\n\n    logging.info(\"Testing update. Ending value is %d\", account.value)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n13:18:20: Testing update. Starting value is 0.\n13:18:20: Thread 0: starting update\n13:18:20: Thread 1: starting update\n13:18:20: Thread 0: finishing update\n13:18:20: Thread 1: finishing update\n13:18:20: Testing update. Ending value is 100\n```\n:::\n:::\n\n\nThe above logic can be made thread-safe by fencing off the critical section using a mutex and enforcing that only a single thread can enter at a time.\n\n### Deadlock, Liveness & Reentrant Locks\n\nImagine that you have a toy that comes in two parts, and you need both parts to play with it - a toy drum and a drumstick, for example. Now, imagine that you ave two small children, both of whom like playing with it. If one of them gets both the drum and the drumstick, that child can merrily play the drum until titing of it. If the other child wants to play, they have wait, however sad that makes them. Now, imagine one child  has the drum and other has the drumstick. They're stuck, unless one decides to be nice and let the other play, each will hold on to whatver they have and demand that they be given the other piece, so neither gets to play. This is a deadlock. \n\nImagine two threads arguing over locks on mutexes: each of a pair of threads needs to lock both of a pair of mutexes to perform some operation, and each thread has one mutex and is waiting for the other. Neither thread can proceed, because each is waiting for the other to release its mutex. This scenario is called *deadlock*.\n\n::: {#e1a527a4 .cell execution_count=3}\n``` {.python .cell-code}\nimport threading\nimport concurrent\nimport time\n\nif __name__ == \"__main__\":\n    drum = threading.Lock()\n    drumstick = threading.Lock()\n\n    def child1_plays_drums():\n        print(f\"Child-1 waiting for drums\")\n        drum.acquire()\n        print(f\"Child-1 acquired drums\")\n        time.sleep(1)\n        print(f\"Child-1 waiting for drumstick\")\n        drumstick.acquire()\n        print(f\"Child-1 is playing drums\")\n\n    def child2_plays_drums():\n        print(f\"Child-2 waiting for drumstick\")\n        drumstick.acquire()\n        print(f\"Child-2 acquired drumstick\")\n        time.sleep(1)\n        print(f\"Child-2 waiting for drums\")\n        drum.acquire()\n        print(f\"Child-2 acquired drums\")\n        print(f\"Child-2 is playing drums\")\n\n    t1 = threading.Thread(target=child1_plays_drums)\n    t2 = threading.Thread(target=child2_plays_drums)\n    \n    t1.start()\n    t2.start()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nChild-1 waiting for drumsChild-2 waiting for drumstick\nChild-2 acquired drumstick\n\nChild-1 acquired drums\n```\n:::\n:::\n\n\n### Mutexes and Semaphores\n\nA mutex is an programming construct that allows only a single thread to access a shared resource or critical section. Once a thread acquires a mutex, all other threads attempting to acquire the same mutex are blocked until the thread releases the mutex.\n\nA semaphore on the hand is used to limit access to a collection of resources. Think of semaphore as having a limited number of permits to give out. If a semaphore has given out all the permits it has, then any new thread that comes along requesting a permit will be blocked till an earlier thread with a permit returns it to the semaphore. A protoypical example is a `ConnectionPool` that hands out database connects to requesting threads.  \n\nA semaphore with a single permit is called a *binary semaphore*.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}