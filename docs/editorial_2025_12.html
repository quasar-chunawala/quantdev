<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quantdev.blog – editorial_2025_12</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="././symbol.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="./index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="coroutines" class="level1">
<h1>Coroutines</h1>
<p>You’ve likely heard about this new C++20 feature, <strong>coroutines</strong>. I think that this is a really important subject and there are several cool use-cases for coroutines. A <strong>coroutine</strong> in the simplest terms is just a function that you can pause in the middle. At a later point the caller will decide to resume the execution of the function right where you left off. Unlike a function therefore, coroutines are always stateful - you atleast need to remember where you left off in the function body.</p>
<p>Coroutines can simplify our code! Coroutines are a great tool, when it comes to implementing parsers.</p>
<section id="the-coroutine-return-type" class="level3">
<h3 class="anchored" data-anchor-id="the-coroutine-return-type">The coroutine return type</h3>
<p>The initial call to the coroutine function will produce this return object of a certain <code>ReturnType</code> and hand it back to the caller. The interface of this type is what is going to determine what the coroutine is capable of. Since coroutines are super-flexible, we can do a whole lot with this return object. If you have some coroutine, and you want to understand what it’s doing, the first thing you should look at is the <code>ReturnType</code>, and what it’s interface is. The important thing here is, we design this <code>ReturnType</code>. If you are writing a coroutine, you can decide, what goes into this interface.</p>
</section>
<section id="how-to-turn-a-function-into-a-coroutine" class="level3">
<h3 class="anchored" data-anchor-id="how-to-turn-a-function-into-a-coroutine">How to turn a function into a coroutine?</h3>
<p>The compiler looks for one of the three keywords in the implementation: <code>co_yield</code>, <code>co_await</code> and <code>co_return</code>.</p>
<table class="table">
<thead>
<tr class="header">
<th>Keyword</th>
<th>Action</th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>co_yield</code></td>
<td>Output</td>
<td>Suspended</td>
</tr>
<tr class="even">
<td><code>co_return</code></td>
<td>Output</td>
<td>Ended</td>
</tr>
<tr class="odd">
<td><code>co_await</code></td>
<td>Input</td>
<td>Suspended</td>
</tr>
</tbody>
</table>
<p>In the preceding table, we see that after <code>co_yield</code> and <code>co_await</code>, the coroutine suspends itself and after <code>co_return</code>, it is terminated (<code>co_return</code> is the equivalent of the <code>return</code> statement in the C++ function).</p>
</section>
<section id="use-cases-for-coroutines" class="level3">
<h3 class="anchored" data-anchor-id="use-cases-for-coroutines">Use-cases for coroutines</h3>
<p><strong>Asynchronous computation.</strong> Suppose we are tasked with designing a simple echo server. We listen for incoming data from a client socket and we simply send it back to the client. At some point in our code for the echo server, we will have a piece of logic like below:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dt">int</span> len <span class="op">=</span> sock<span class="op">.</span>read<span class="op">({</span>buffer<span class="op">});</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    sock<span class="op">.</span>write<span class="op">({</span>buffer<span class="op">,</span>len<span class="op">});</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    log<span class="op">(</span>buffer<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>we certainly don’t want to write a server like this. Say one of the clients requests communication and we are in a session. They say, they are ready to send the data, so we are blocking on the <code>read</code>, but maybe they send us this data in <span class="math inline">\(2\)</span> minutes, or <span class="math inline">\(5\)</span> minutes or even more. And other clients keep waiting.</p>
<p>One solution is to use an asynchronous framework and rewrite our code as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">struct</span> State<span class="op">{</span> Socket sock<span class="op">;</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span> <span class="op">};</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    </span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="co">// Heap allocate the state</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">auto</span> state <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>State<span class="op">&gt;(</span>sock<span class="op">,</span> buffer<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">auto</span> on_read_finished_callback <span class="op">=</span> <span class="op">[</span>state<span class="op">](</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        error_code ec<span class="op">,</span> </span>
<span id="cb2-9"><a href="#cb2-9"></a>        <span class="dt">size_t</span> len</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="op">)</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>        <span class="kw">auto</span> done <span class="op">=</span> <span class="op">[</span>state<span class="op">](</span>error_code ec<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">)</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>            <span class="cf">if</span><span class="op">(!</span>ec<span class="op">)</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>                log<span class="op">();</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>        <span class="cf">if</span><span class="op">(!</span>ec<span class="op">)</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>        <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>            <span class="co">// Perform an asynchronous write</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>            state<span class="op">-&gt;</span>socket<span class="op">.</span>async_write<span class="op">(</span> </span>
<span id="cb2-21"><a href="#cb2-21"></a>                state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb2-22"><a href="#cb2-22"></a>                done </span>
<span id="cb2-23"><a href="#cb2-23"></a>            <span class="op">);</span>    </span>
<span id="cb2-24"><a href="#cb2-24"></a>        <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>    <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26"></a></span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="co">// Perform an asynchronous read </span></span>
<span id="cb2-28"><a href="#cb2-28"></a>    state<span class="op">-&gt;</span>socket<span class="op">.</span>async_read<span class="op">(</span> state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb2-29"><a href="#cb2-29"></a>                             on_read_finished_callback <span class="op">);</span></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>So, the <code>session</code> makes two associations:</p>
<p><span class="math display">\[
\begin{align*}
\text{On finishing read} &amp;\mapsto \texttt{on\_finished\_read\_callback} \\
\text{On finishing write} &amp;\mapsto \texttt{done} \\
\text{Accepting a new client connection} &amp;\mapsto \texttt{session}
\end{align*}
\]</span></p>
<p>And implicitly there is a third association even though we cannot see it here - this entire function <code>session</code> is most likely a callback, in response to an event like <span class="math inline">\(\text{On client connection established}\)</span>. So, the server will be many different associations of events to callbacks at different levels.</p>
<p>Pay attention to the <code>state</code>. We said that, we wanted to allocate it on the heap and manage it through a <code>shared_ptr</code>. We pass this <code>shared_ptr&lt;State&gt;</code> by value to every single callback. This way, I make sure that the last one who touches this session turns off the lights and deallocates <code>state</code>.</p>
<p>While this is a toy-example, in real production code, there can be a long sequence of steps and calling lambdas inside lambdas can obfuscate the meaning of the code.</p>
<p>A coroutine implementation of the same echo’ing session would look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>Task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span> len <span class="op">=</span> <span class="cf">co_await</span> sock<span class="op">.</span>async_read<span class="op">({</span>buffer<span class="op">});</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="cf">co_await</span> sock<span class="op">.</span>async_write<span class="op">({</span>buffer<span class="op">,</span>len<span class="op">});</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    log<span class="op">(</span>buffer<span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This looks very similar to the sequential code, except that we use this <code>co_await</code> keyword. You have clear indication of the points where the coroutine will be suspended. Also, note that previously the function <code>session</code> returned <code>void</code>. Now, we are returning something - a <code>Task&lt;void&gt;</code>. This will be a handle to the coroutine and it’s how the outside world will be communicating with the coroutine.</p>
<p><strong>Suspended computation</strong>. A second use-case is that coroutines support lazy evaluation. Lazy evaluation doesn’t do any work unless it’s absolutely necessary. This can also potentially make your code more efficient. Lazy evaluation also supports programming with infinite lists.</p>
</section>
<section id="the-simplest-coroutine" class="level2">
<h2 class="anchored" data-anchor-id="the-simplest-coroutine">The simplest coroutine</h2>
<p>The following code is the simplest implementation of a coroutine:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">void</span> coro_func<span class="op">(){</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    coro_func<span class="op">();</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/W3GoWPoEs">Compiler Explorer</a></p>
<p>Our first coroutine will just return nothing. It will not do anything else. Sadly, the preceding code is too simple for a functional coroutine and it will not compile. When compiling with <code>gcc 15.2</code>, we get the following error:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb5-1"><a href="#cb5-1"></a>&lt;source&gt;: In function 'void coro_func()':</span>
<span id="cb5-2"><a href="#cb5-2"></a>&lt;source&gt;:4:5: error: unable to find the promise type for this coroutine</span>
<span id="cb5-3"><a href="#cb5-3"></a>    4 |     co_return;</span>
<span id="cb5-4"><a href="#cb5-4"></a>      |     ^~~~~~~~~</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Looking at C++ reference, we see that the return type of a coroutine must define a type named <code>promise_type</code>.</p>
<section id="the-promise_type" class="level3">
<h3 class="anchored" data-anchor-id="the-promise_type">The <code>promise_type</code></h3>
<p>Why do we need a promise? The <code>promise_type</code> is the second important piece in the coroutine mechanism. We can draw an analogy from futures and promises which are essential blocks for achieving asynchronous programming in C++. The future is the thing, that the function that does the asynchronous computation, hands out back to the caller, that the caller can use to retrieve the result by invoking the <code>get()</code> member function. The future has the role of the return object. But, you need something that remains on the producer-side. The asynchronous function holds on to the promise, and that’s where it puts the results that will be given to the caller, when it calls <code>get()</code> on the future. The idea behind the <code>promise_type</code> for coroutines is similar. The promise is where the coroutine’s return value is stored, and it provides functions to control the coroutine’s behavior at startup and completion of t he coroutine. The promise is the interface through which the caller interacts with the coroutine.</p>
<p>Following the reference advice, we can write a new version of our coroutine.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">struct</span> Task</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="op">};</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="op">};</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    coro_func<span class="op">();</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that the return type of a coroutine can have any name (I call it <code>Task</code>, so that it makes intuitive sense). Compiling the preceding code again gives us errors. All errors are about missing functions in the <code>promise_type</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>&lt;source&gt;: In function 'Task coro_func()':</span>
<span id="cb7-2"><a href="#cb7-2"></a>&lt;source&gt;:11:5: error: no member named 'return_void' in</span>
<span id="cb7-3"><a href="#cb7-3"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span>
<span id="cb7-4"><a href="#cb7-4"></a>   11 |     co_return;</span>
<span id="cb7-5"><a href="#cb7-5"></a>      |     ^~~~~~~~~</span>
<span id="cb7-6"><a href="#cb7-6"></a>&lt;source&gt;:10:6: error: no member named 'unhandled_exception' in</span>
<span id="cb7-7"><a href="#cb7-7"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span>
<span id="cb7-8"><a href="#cb7-8"></a>   10 | Task coro_func(){</span>
<span id="cb7-9"><a href="#cb7-9"></a>      |      ^~~~~~~~~</span>
<span id="cb7-10"><a href="#cb7-10"></a>&lt;source&gt;:10:6: error: no member named 'get_return_object' in</span>
<span id="cb7-11"><a href="#cb7-11"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the important functions of the <code>promise_type</code> is that it determines what happens at certain key points in the coroutine’s life. It determines, what happens at the startup and completion of execution of the coroutine.</p>
</section>
<section id="implementing-the-promise_type" class="level3">
<h3 class="anchored" data-anchor-id="implementing-the-promise_type">Implementing the <code>promise_type</code></h3>
<p>The first thing that the compiler expects from us the <code>get_return_object()</code> function. The return type of this function is the same as the return type of the coroutine.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>        Task get_return_object<span class="op">(){</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get_return_object()"</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>            <span class="cf">return</span> Task<span class="op">{</span> <span class="op">*</span><span class="kw">this</span> <span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>        <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="dt">void</span> return_void<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"return_void()"</span><span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>        <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a>        <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"unhandled_exception()"</span><span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>        <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>initial_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"initial_suspend()"</span><span class="op">);</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>        <span class="op">}</span></span>
<span id="cb8-23"><a href="#cb8-23"></a></span>
<span id="cb8-24"><a href="#cb8-24"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>final_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"final_suspend()"</span><span class="op">);</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>        <span class="op">}</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>    <span class="op">};</span></span>
<span id="cb8-29"><a href="#cb8-29"></a></span>
<span id="cb8-30"><a href="#cb8-30"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;){</span></span>
<span id="cb8-31"><a href="#cb8-31"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;)"</span><span class="op">);</span></span>
<span id="cb8-32"><a href="#cb8-32"></a>    <span class="op">}</span></span>
<span id="cb8-33"><a href="#cb8-33"></a></span>
<span id="cb8-34"><a href="#cb8-34"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb8-36"><a href="#cb8-36"></a>    <span class="op">}</span></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="op">};</span></span>
<span id="cb8-38"><a href="#cb8-38"></a></span>
<span id="cb8-39"><a href="#cb8-39"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb8-40"><a href="#cb8-40"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb8-41"><a href="#cb8-41"></a><span class="op">}</span></span>
<span id="cb8-42"><a href="#cb8-42"></a></span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb8-44"><a href="#cb8-44"></a>    coro_func<span class="op">();</span></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb9-1"><a href="#cb9-1"></a>get_return_object()</span>
<span id="cb9-2"><a href="#cb9-2"></a>Task(promise_type&amp;)</span>
<span id="cb9-3"><a href="#cb9-3"></a>initial_suspend()</span>
<span id="cb9-4"><a href="#cb9-4"></a>~Task()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>get_return_object()</code> method is implicitly called when the coroutine starts executing. Its upto the <code>promise_type</code> to provide an implementation of this method that constructs the return object that will be handed back to the caller. The <code>Task</code> object is stored on the heap. You don’t see this in the source code anywhere. When the coroutine reaches its first suspension point, and control flow is returned back to the caller, then the caller will receive this object.</p>
<p>The <code>return_void()</code> function is a customization point for handling what happens when we reach the <code>co_return</code> statement in the function body. There is also a corresponding <code>return_value()</code>, if you don’t have an empty <code>co_return</code> statement, but we’ll look at this at length later ahead.</p>
<p>The <code>unhandled_exception()</code> is similar to the <code>return_void()</code>, this function is a customization point for handling, what happens when the coroutine throws an exception. We leave it empty for now.</p>
<p>We need to implement two more functions <code>initial_suspend()</code> and <code>final_suspend()</code>. These are basically the customization points that allow us to execute some code, both when the coroutine first starts executing and shortly before the coroutine ends execution. Here, we are returning <code>std::suspend_always</code> which basically means that at these points, I want to go into suspension.</p>
<p>In a typical implementation, you either return <code>std::suspend_always</code>, which means you pause execution at this point and hand control back to the caller always, or you return <code>std::suspend_never</code>, which basically means you just go on and continue executing the coroutine.</p>
<p>Note that, <code>final_suspend()</code> is not printed in the output, because the coroutine is paused at <code>initial_suspend()</code> and since I never resumed it, I don’t see the output on the console.</p>
</section>
</section>
<section id="a-yielding-coroutine" class="level2">
<h2 class="anchored" data-anchor-id="a-yielding-coroutine">A yielding coroutine</h2>
<p>Let’s implement another coroutine that can send data back to the caller. In this second example, we implement a coroutine that produces a message. It will be the hello world of coroutines. The coroutine will say hello and the caller function will print the message received from the coroutine.</p>
<p>To implement this functionality, we need to establish a communication channel from the coroutine to the caller. This channel is the mechanism that allows the coroutine to pass values to the caller and receive information from it. This channel is established through the coroutine’s <code>promise_type</code> and the <em>coroutine handle</em>.</p>
<p>The <em>coroutine handle</em> is a type that gives access to the coroutine frame(the coroutine’s internal state) and allows the caller to resume or destroy the coroutine. The handle is what the caller can use to resume the coroutine after it has been suspended (for example after <code>co_await</code> or <code>co_yield</code>). The handle can also be used to check whether the coroutine is done or to clean up its resources.</p>
<p>The following code is the new version of both the caller function and the coroutine:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="cf">co_yield</span> <span class="st">"Hello world from the coroutine"</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">auto</span> task <span class="op">=</span> coro_func<span class="op">();</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">"task.get() = </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> task<span class="op">.</span>get<span class="op">());</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The coroutine <em>yields</em> and sends some data to the caller. The caller reads that data and prints it. When the compiler reads the <code>co_ yield</code> expression, it will generate a call to the <code>yield_value</code> function defined in the <code>promise_type</code>. Thus, we add the following code to the <code>promise_type</code> :</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>        <span class="bu">std::</span>string<span class="op"> </span>output_data<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="co">/* ... */</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>yield_value<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>            output_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="op">};</span></span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;){</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;)"</span><span class="op">);</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The function gets a <code>std::string</code> object and moves it to the <code>output_data</code> member variable of the promise type. But, this just keeps the data inside the <code>promise_type</code>. We still need a mechanism to get that data out of the coroutine.</p>
<section id="the-coroutine-handle" class="level3">
<h3 class="anchored" data-anchor-id="the-coroutine-handle">The coroutine handle</h3>
<p>Once we require a communication channel to and from a coroutine, we need a way to refer to a suspended or executing coroutine. The mechanism to refer to the coroutine object is through a pointer or handle called a <strong>coroutine handle</strong>. The C++ library header file <code>&lt;coroutine&gt;</code> defines a type <code>std::coroutine_handle</code> to work with coroutine handles.</p>
<p>Two functions are of interest to us in the <code>std::coroutine_handle</code> interface : <code>resume()</code> and <code>destroy()</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">struct</span> coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="co">/* ... */</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">void</span> resume<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="dt">void</span> destroy<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="at">static</span> coroutine_handle from_promise<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;);</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>What <code>resume()</code> does is simply, it resumes the suspended coroutine. It continues execution.</p>
<p>If we think of this coroutine frame or object living somewhere on the heap, where all of the state of execution is stored, one way to destroy this state is to let the coroutine run to completion. But, far more commonly, we would like to manage the lifetime externally and we can then just call the <code>destroy()</code> function which will then get rid of the coroutine state.</p>
<p>Note that, the <code>coroutine_handle</code> is not a smart pointer type. So, you have to call the <code>destroy()</code> explicitly.</p>
<p>There’s two more functions <code>.promise()</code> and <code>.from_promise()</code>. These are used to convert from a coroutine to a promise object and vice versa.</p>
<p>We add the following functionality to our return type to manage the coroutine handle:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>        <span class="bu">std::</span>string<span class="op"> </span>output_data<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>        <span class="co">/* ... */</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>yield_value<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>            output_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        <span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="op">};</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="co">// Coroutine handle member-variable</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> handle<span class="op">{};</span></span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">)</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>    <span class="op">:</span> handle <span class="op">{</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(</span>promise<span class="op">)</span> <span class="op">}</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="op">{</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;)"</span><span class="op">);</span></span>
<span id="cb13-17"><a href="#cb13-17"></a>    <span class="op">}</span></span>
<span id="cb13-18"><a href="#cb13-18"></a></span>
<span id="cb13-19"><a href="#cb13-19"></a>    <span class="co">// Destructor</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb13-22"><a href="#cb13-22"></a>        <span class="cf">if</span><span class="op">(</span>handle<span class="op">)</span></span>
<span id="cb13-23"><a href="#cb13-23"></a>            handle<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb13-24"><a href="#cb13-24"></a>    <span class="op">}</span></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The preceding code declares a coroutine handle of type <code>std::coroutine_handle&lt;promise_type&gt;</code> and creates the handle in the return type constructor. The handle is destroyed in the return type destructor.</p>
<p>Now, back to our yielding coroutine. The only missing bit is a <code>get()</code> function for the caller to be able to extract the resultant string out of the promise.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="bu">std::</span>string<span class="op"> </span>get<span class="op">(){</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="cf">if</span><span class="op">(!</span>handle<span class="op">.</span>done<span class="op">()){</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>        handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>handle<span class="op">.</span>promise<span class="op">().</span>output_data<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>get()</code> function resumes the coroutine if it has not terminated and return the result stored in the <code>output_data</code> member variable of the promise. The full source code listing is shown below:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>string_literals<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>        <span class="bu">std::</span>string<span class="op"> </span>output_data<span class="op">{};</span></span>
<span id="cb15-11"><a href="#cb15-11"></a></span>
<span id="cb15-12"><a href="#cb15-12"></a>        Task get_return_object<span class="op">(){</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get_return_object()"</span><span class="op">);</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>            <span class="cf">return</span> Task<span class="op">{</span> <span class="op">*</span><span class="kw">this</span> <span class="op">};</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>        <span class="op">}</span></span>
<span id="cb15-16"><a href="#cb15-16"></a></span>
<span id="cb15-17"><a href="#cb15-17"></a>        <span class="dt">void</span> return_void<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"return_void()"</span><span class="op">);</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>        <span class="op">}</span></span>
<span id="cb15-20"><a href="#cb15-20"></a></span>
<span id="cb15-21"><a href="#cb15-21"></a>        <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb15-22"><a href="#cb15-22"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"unhandled_exception()"</span><span class="op">);</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>        <span class="op">}</span></span>
<span id="cb15-24"><a href="#cb15-24"></a></span>
<span id="cb15-25"><a href="#cb15-25"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>initial_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb15-26"><a href="#cb15-26"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"initial_suspend()"</span><span class="op">);</span></span>
<span id="cb15-27"><a href="#cb15-27"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb15-28"><a href="#cb15-28"></a>        <span class="op">}</span></span>
<span id="cb15-29"><a href="#cb15-29"></a></span>
<span id="cb15-30"><a href="#cb15-30"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>final_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb15-31"><a href="#cb15-31"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"final_suspend()"</span><span class="op">);</span></span>
<span id="cb15-32"><a href="#cb15-32"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb15-33"><a href="#cb15-33"></a>        <span class="op">}</span></span>
<span id="cb15-34"><a href="#cb15-34"></a></span>
<span id="cb15-35"><a href="#cb15-35"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>yield_value<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb15-36"><a href="#cb15-36"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"yield_value(std::string)"</span><span class="op">);</span></span>
<span id="cb15-37"><a href="#cb15-37"></a>            output_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb15-38"><a href="#cb15-38"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb15-39"><a href="#cb15-39"></a>        <span class="op">}</span></span>
<span id="cb15-40"><a href="#cb15-40"></a>    <span class="op">};</span></span>
<span id="cb15-41"><a href="#cb15-41"></a></span>
<span id="cb15-42"><a href="#cb15-42"></a>    <span class="co">// Coroutine handle member-variable</span></span>
<span id="cb15-43"><a href="#cb15-43"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> handle<span class="op">{};</span></span>
<span id="cb15-44"><a href="#cb15-44"></a></span>
<span id="cb15-45"><a href="#cb15-45"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">)</span></span>
<span id="cb15-46"><a href="#cb15-46"></a>    <span class="op">:</span> handle <span class="op">{</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(</span>promise<span class="op">)</span> <span class="op">}</span></span>
<span id="cb15-47"><a href="#cb15-47"></a>    <span class="op">{</span></span>
<span id="cb15-48"><a href="#cb15-48"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;)"</span><span class="op">);</span></span>
<span id="cb15-49"><a href="#cb15-49"></a>    <span class="op">}</span></span>
<span id="cb15-50"><a href="#cb15-50"></a></span>
<span id="cb15-51"><a href="#cb15-51"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb15-52"><a href="#cb15-52"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb15-53"><a href="#cb15-53"></a>        <span class="cf">if</span><span class="op">(</span>handle<span class="op">)</span></span>
<span id="cb15-54"><a href="#cb15-54"></a>            handle<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb15-55"><a href="#cb15-55"></a>    <span class="op">}</span></span>
<span id="cb15-56"><a href="#cb15-56"></a></span>
<span id="cb15-57"><a href="#cb15-57"></a>    <span class="bu">std::</span>string<span class="op"> </span>get<span class="op">(){</span></span>
<span id="cb15-58"><a href="#cb15-58"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get()"</span><span class="op">);</span></span>
<span id="cb15-59"><a href="#cb15-59"></a>        <span class="cf">if</span><span class="op">(!</span>handle<span class="op">.</span>done<span class="op">())</span></span>
<span id="cb15-60"><a href="#cb15-60"></a>            handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb15-61"><a href="#cb15-61"></a></span>
<span id="cb15-62"><a href="#cb15-62"></a>        <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>handle<span class="op">.</span>promise<span class="op">().</span>output_data<span class="op">);</span></span>
<span id="cb15-63"><a href="#cb15-63"></a>    <span class="op">}</span></span>
<span id="cb15-64"><a href="#cb15-64"></a><span class="op">};</span></span>
<span id="cb15-65"><a href="#cb15-65"></a></span>
<span id="cb15-66"><a href="#cb15-66"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb15-67"><a href="#cb15-67"></a>    <span class="cf">co_yield</span> <span class="st">"Hello world from the coroutine"</span><span class="op">;</span></span>
<span id="cb15-68"><a href="#cb15-68"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb15-69"><a href="#cb15-69"></a><span class="op">}</span></span>
<span id="cb15-70"><a href="#cb15-70"></a></span>
<span id="cb15-71"><a href="#cb15-71"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb15-72"><a href="#cb15-72"></a>    <span class="kw">auto</span> task <span class="op">=</span> coro_func<span class="op">();</span></span>
<span id="cb15-73"><a href="#cb15-73"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> task<span class="op">.</span>get<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb15-74"><a href="#cb15-74"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb16-1"><a href="#cb16-1"></a>get_return_object()</span>
<span id="cb16-2"><a href="#cb16-2"></a>Task(promise_type&amp;)</span>
<span id="cb16-3"><a href="#cb16-3"></a>initial_suspend()</span>
<span id="cb16-4"><a href="#cb16-4"></a>get()</span>
<span id="cb16-5"><a href="#cb16-5"></a>yield_value(std::string)</span>
<span id="cb16-6"><a href="#cb16-6"></a>Hello world from the coroutine</span>
<span id="cb16-7"><a href="#cb16-7"></a>~Task()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output shows what is happening during the coroutine execution. The <code>Task</code> object is created after a call to <code>get_return_object</code>. The coroutine is initially suspended. The caller wants to get the message from the coroutine so <code>get()</code> is called, which resumes the coroutine. When the compiler sees <code>co_yield</code> statement in the coroutine, it generates an implicit called to <code>yield_value(std::string)</code>. <code>yield_value</code> is called and the message is copied to the resultant member variable <code>output_data</code> in the promise. Finally, the message is printed by the caller function, and the coroutine returns.</p>
</section>
</section>
<section id="a-waiting-coroutine" class="level2">
<h2 class="anchored" data-anchor-id="a-waiting-coroutine">A waiting coroutine</h2>
<p>We are now going to implement a coroutine that can wait for the input data sent by the caller. In our example, the coroutine will wait until it gets a <code>std::string</code> object and then print it. We say that the coroutine waits, we mean it is suspended (that is, not executed) until the data is received.</p>
<p>We start with changes to both the coroutine and the caller function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="cf">co_await</span> <span class="bu">std::</span>string<span class="op">{};</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="kw">auto</span> task <span class="op">=</span> coro_func<span class="op">();</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    task<span class="op">.</span>put<span class="op">(</span><span class="st">"To boldly go where no man has gone before"</span><span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the preceding code, the caller function calls the <code>put()</code> function(a method in the return type structure) and the coroutine calls <code>co_await</code> to wait for a <code>std::string</code> object from the caller.</p>
<p>The changes to the return type are simple, that is, just adding the <code>put()</code> function.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="dt">void</span> put<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">){</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    handle<span class="op">.</span>promise<span class="op">().</span>input_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="cf">if</span><span class="op">(!</span>handle<span class="op">.</span>done<span class="op">()){</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>        handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We need to add the <code>input_data</code> variable to the promise structure. But, just with those changes to our first example and the coroutine handle from the previous example, the code cannot be compiled.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>        <span class="bu">std::</span>string<span class="op"> </span>input_data<span class="op">{};</span></span>
<span id="cb19-9"><a href="#cb19-9"></a></span>
<span id="cb19-10"><a href="#cb19-10"></a>        Task get_return_object<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get_return_object"</span><span class="op">);</span></span>
<span id="cb19-12"><a href="#cb19-12"></a>            <span class="cf">return</span> Task<span class="op">{</span> <span class="op">*</span><span class="kw">this</span> <span class="op">};</span></span>
<span id="cb19-13"><a href="#cb19-13"></a>        <span class="op">}</span> </span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a>        <span class="dt">void</span> return_void<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-16"><a href="#cb19-16"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"return_void"</span><span class="op">);</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>        <span class="op">}</span></span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>initial_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"initial_suspend"</span><span class="op">);</span></span>
<span id="cb19-21"><a href="#cb19-21"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb19-22"><a href="#cb19-22"></a>        <span class="op">}</span></span>
<span id="cb19-23"><a href="#cb19-23"></a></span>
<span id="cb19-24"><a href="#cb19-24"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>final_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-25"><a href="#cb19-25"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"final_suspend"</span><span class="op">);</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb19-27"><a href="#cb19-27"></a>        <span class="op">}</span></span>
<span id="cb19-28"><a href="#cb19-28"></a>        <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-29"><a href="#cb19-29"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"unhandled_exception"</span><span class="op">);</span></span>
<span id="cb19-30"><a href="#cb19-30"></a>        <span class="op">}</span></span>
<span id="cb19-31"><a href="#cb19-31"></a></span>
<span id="cb19-32"><a href="#cb19-32"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>yield_value<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-33"><a href="#cb19-33"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"yield_value"</span><span class="op">);</span></span>
<span id="cb19-34"><a href="#cb19-34"></a>            <span class="co">//output_data = std::move(msg);</span></span>
<span id="cb19-35"><a href="#cb19-35"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb19-36"><a href="#cb19-36"></a>        <span class="op">}</span></span>
<span id="cb19-37"><a href="#cb19-37"></a>    <span class="op">};</span></span>
<span id="cb19-38"><a href="#cb19-38"></a></span>
<span id="cb19-39"><a href="#cb19-39"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> handle<span class="op">{};</span></span>
<span id="cb19-40"><a href="#cb19-40"></a></span>
<span id="cb19-41"><a href="#cb19-41"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">)</span></span>
<span id="cb19-42"><a href="#cb19-42"></a>    <span class="op">:</span> handle<span class="op">{</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(</span>promise<span class="op">)}</span></span>
<span id="cb19-43"><a href="#cb19-43"></a>    <span class="op">{</span></span>
<span id="cb19-44"><a href="#cb19-44"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;) ctor"</span><span class="op">);</span></span>
<span id="cb19-45"><a href="#cb19-45"></a>    <span class="op">}</span></span>
<span id="cb19-46"><a href="#cb19-46"></a></span>
<span id="cb19-47"><a href="#cb19-47"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb19-48"><a href="#cb19-48"></a>        <span class="cf">if</span><span class="op">(</span>handle<span class="op">)</span></span>
<span id="cb19-49"><a href="#cb19-49"></a>            handle<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb19-50"><a href="#cb19-50"></a></span>
<span id="cb19-51"><a href="#cb19-51"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb19-52"><a href="#cb19-52"></a>    <span class="op">}</span></span>
<span id="cb19-53"><a href="#cb19-53"></a></span>
<span id="cb19-54"><a href="#cb19-54"></a>    <span class="dt">void</span> put<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">){</span></span>
<span id="cb19-55"><a href="#cb19-55"></a>        handle<span class="op">.</span>promise<span class="op">().</span>input_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb19-56"><a href="#cb19-56"></a>        <span class="cf">if</span><span class="op">(!</span>handle<span class="op">.</span>done<span class="op">())</span></span>
<span id="cb19-57"><a href="#cb19-57"></a>            handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb19-58"><a href="#cb19-58"></a>    <span class="op">}</span></span>
<span id="cb19-59"><a href="#cb19-59"></a><span class="op">};</span></span>
<span id="cb19-60"><a href="#cb19-60"></a></span>
<span id="cb19-61"><a href="#cb19-61"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb19-62"><a href="#cb19-62"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="cf">co_await</span> <span class="bu">std::</span>string<span class="op">{};</span></span>
<span id="cb19-63"><a href="#cb19-63"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb19-64"><a href="#cb19-64"></a><span class="op">}</span></span>
<span id="cb19-65"><a href="#cb19-65"></a></span>
<span id="cb19-66"><a href="#cb19-66"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb19-67"><a href="#cb19-67"></a>    <span class="kw">auto</span> task <span class="op">=</span> coro_func<span class="op">();</span></span>
<span id="cb19-68"><a href="#cb19-68"></a>    task<span class="op">.</span>put<span class="op">(</span><span class="st">"To boldly go where no man has gone before"</span><span class="op">);</span></span>
<span id="cb19-69"><a href="#cb19-69"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-70"><a href="#cb19-70"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The compiler gives us the following error:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb20-1"><a href="#cb20-1"></a>&lt;source&gt;: In function 'Task coro_func()':</span>
<span id="cb20-2"><a href="#cb20-2"></a>&lt;source&gt;:62:18: error: no member named 'await_ready' in 'std::string' {aka 'std::__cxx11::basic_string&lt;char&gt;'}</span>
<span id="cb20-3"><a href="#cb20-3"></a>   62 |     std::cout &lt;&lt; co_await std::string{};</span>
<span id="cb20-4"><a href="#cb20-4"></a>      |                  ^~~~~~~~</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s explore more about what this error message means.</p>
</section>
<section id="what-is-an-awaitable" class="level2">
<h2 class="anchored" data-anchor-id="what-is-an-awaitable">What is an awaitable?</h2>
<p>An <em>awaitable</em> is any object, I can call <code>co_await</code> on. You can think of <code>co_await</code> like an operator, and its argument as an <em>awaitable</em>. The way to think about the operator <code>co_await</code> is that these are opportunities for suspension. These are the points where the coroutine can be paused. Similar to, how the <code>promise_type</code> provides hooks to control what happens at startup or when you return from the coroutine, the awaitable provides these hooks for what happens when we go into suspension.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> Awaitable<span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="dt">bool</span> await_ready<span class="op">();</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">void</span> await_suspend<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;);</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="dt">void</span> await_resume<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;);</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first function is <code>.await_ready()</code> which returns a <code>bool</code>. This determines whether we do actually go into suspension or we just say, <em>yeah, we are ready, and we don’t want to go into suspension</em>, we want to continue execution and in that case we just return <code>true</code>.</p>
<p>The next function is <code>.await_suspend()</code> and that is the customization point that will get executed shortly before the coroutine function goes to sleep.</p>
<p>The next function is <code>.await_resume()</code> and that is the customization point that will get execute just after the coroutine is resumed.</p>
<p>The following code shows our implementation of the <code>await_transform</code> function and the <code>Awaitable</code> struct:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">auto</span> await_transform<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>    <span class="kw">struct</span> Awaitable<span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>        <span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a>        <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>    <span class="co">// Says, yeah we are ready</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>                            <span class="co">// we don't need to sleep. Just go on.</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>        <span class="op">}</span></span>
<span id="cb22-9"><a href="#cb22-9"></a></span>
<span id="cb22-10"><a href="#cb22-10"></a>        <span class="bu">std::</span>string<span class="op"> </span>await_resume<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>            <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>promise<span class="op">.</span>input_data<span class="op">);</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>        <span class="op">}</span></span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a>        <span class="dt">void</span> await_suspend<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;)</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{}</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>    <span class="op">};</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a>    <span class="cf">return</span> Awaitable<span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the code for the full example of the waiting coroutine:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>        <span class="bu">std::</span>string<span class="op"> </span>input_data<span class="op">{};</span></span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a>        Task get_return_object<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-11"><a href="#cb23-11"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get_return_object"</span><span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>            <span class="cf">return</span> Task<span class="op">{</span> <span class="op">*</span><span class="kw">this</span> <span class="op">};</span></span>
<span id="cb23-13"><a href="#cb23-13"></a>        <span class="op">}</span> </span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a>        <span class="dt">void</span> return_void<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-16"><a href="#cb23-16"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"return_void"</span><span class="op">);</span></span>
<span id="cb23-17"><a href="#cb23-17"></a>        <span class="op">}</span></span>
<span id="cb23-18"><a href="#cb23-18"></a></span>
<span id="cb23-19"><a href="#cb23-19"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>initial_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-20"><a href="#cb23-20"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"initial_suspend"</span><span class="op">);</span></span>
<span id="cb23-21"><a href="#cb23-21"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb23-22"><a href="#cb23-22"></a>        <span class="op">}</span></span>
<span id="cb23-23"><a href="#cb23-23"></a></span>
<span id="cb23-24"><a href="#cb23-24"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>final_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-25"><a href="#cb23-25"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"final_suspend"</span><span class="op">);</span></span>
<span id="cb23-26"><a href="#cb23-26"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb23-27"><a href="#cb23-27"></a>        <span class="op">}</span></span>
<span id="cb23-28"><a href="#cb23-28"></a>        <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-29"><a href="#cb23-29"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"unhandled_exception"</span><span class="op">);</span></span>
<span id="cb23-30"><a href="#cb23-30"></a>        <span class="op">}</span></span>
<span id="cb23-31"><a href="#cb23-31"></a></span>
<span id="cb23-32"><a href="#cb23-32"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>yield_value<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-33"><a href="#cb23-33"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"yield_value"</span><span class="op">);</span></span>
<span id="cb23-34"><a href="#cb23-34"></a>            <span class="co">//output_data = std::move(msg);</span></span>
<span id="cb23-35"><a href="#cb23-35"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb23-36"><a href="#cb23-36"></a>        <span class="op">}</span></span>
<span id="cb23-37"><a href="#cb23-37"></a></span>
<span id="cb23-38"><a href="#cb23-38"></a>        <span class="kw">auto</span> await_transform<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-39"><a href="#cb23-39"></a>            <span class="kw">struct</span> Awaitable<span class="op">{</span></span>
<span id="cb23-40"><a href="#cb23-40"></a>                <span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">;</span></span>
<span id="cb23-41"><a href="#cb23-41"></a></span>
<span id="cb23-42"><a href="#cb23-42"></a>                <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-43"><a href="#cb23-43"></a>                    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>    <span class="co">// Says, yeah we are ready</span></span>
<span id="cb23-44"><a href="#cb23-44"></a>                                    <span class="co">// we don't need to sleep. Just go on.</span></span>
<span id="cb23-45"><a href="#cb23-45"></a>                <span class="op">}</span></span>
<span id="cb23-46"><a href="#cb23-46"></a></span>
<span id="cb23-47"><a href="#cb23-47"></a>                <span class="bu">std::</span>string<span class="op"> </span>await_resume<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-48"><a href="#cb23-48"></a>                    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>promise<span class="op">.</span>input_data<span class="op">);</span></span>
<span id="cb23-49"><a href="#cb23-49"></a>                <span class="op">}</span></span>
<span id="cb23-50"><a href="#cb23-50"></a></span>
<span id="cb23-51"><a href="#cb23-51"></a>                <span class="dt">void</span> await_suspend<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;)</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">{}</span></span>
<span id="cb23-52"><a href="#cb23-52"></a></span>
<span id="cb23-53"><a href="#cb23-53"></a>            <span class="op">};</span></span>
<span id="cb23-54"><a href="#cb23-54"></a>            </span>
<span id="cb23-55"><a href="#cb23-55"></a>            <span class="cf">return</span> Awaitable<span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb23-56"><a href="#cb23-56"></a>        <span class="op">}</span></span>
<span id="cb23-57"><a href="#cb23-57"></a>    <span class="op">};</span></span>
<span id="cb23-58"><a href="#cb23-58"></a></span>
<span id="cb23-59"><a href="#cb23-59"></a>    <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> handle<span class="op">{};</span></span>
<span id="cb23-60"><a href="#cb23-60"></a></span>
<span id="cb23-61"><a href="#cb23-61"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;</span> promise<span class="op">)</span></span>
<span id="cb23-62"><a href="#cb23-62"></a>    <span class="op">:</span> handle<span class="op">{</span> <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(</span>promise<span class="op">)}</span></span>
<span id="cb23-63"><a href="#cb23-63"></a>    <span class="op">{</span></span>
<span id="cb23-64"><a href="#cb23-64"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;) ctor"</span><span class="op">);</span></span>
<span id="cb23-65"><a href="#cb23-65"></a>    <span class="op">}</span></span>
<span id="cb23-66"><a href="#cb23-66"></a></span>
<span id="cb23-67"><a href="#cb23-67"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb23-68"><a href="#cb23-68"></a>        <span class="cf">if</span><span class="op">(</span>handle<span class="op">)</span></span>
<span id="cb23-69"><a href="#cb23-69"></a>            handle<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb23-70"><a href="#cb23-70"></a></span>
<span id="cb23-71"><a href="#cb23-71"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb23-72"><a href="#cb23-72"></a>    <span class="op">}</span></span>
<span id="cb23-73"><a href="#cb23-73"></a></span>
<span id="cb23-74"><a href="#cb23-74"></a>    <span class="dt">void</span> put<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>msg<span class="op">){</span></span>
<span id="cb23-75"><a href="#cb23-75"></a>        handle<span class="op">.</span>promise<span class="op">().</span>input_data <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>msg<span class="op">);</span></span>
<span id="cb23-76"><a href="#cb23-76"></a>        <span class="cf">if</span><span class="op">(!</span>handle<span class="op">.</span>done<span class="op">())</span></span>
<span id="cb23-77"><a href="#cb23-77"></a>            handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb23-78"><a href="#cb23-78"></a>    <span class="op">}</span></span>
<span id="cb23-79"><a href="#cb23-79"></a><span class="op">};</span></span>
<span id="cb23-80"><a href="#cb23-80"></a></span>
<span id="cb23-81"><a href="#cb23-81"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb23-82"><a href="#cb23-82"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="cf">co_await</span> <span class="bu">std::</span>string<span class="op">{};</span></span>
<span id="cb23-83"><a href="#cb23-83"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb23-84"><a href="#cb23-84"></a><span class="op">}</span></span>
<span id="cb23-85"><a href="#cb23-85"></a></span>
<span id="cb23-86"><a href="#cb23-86"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb23-87"><a href="#cb23-87"></a>    <span class="kw">auto</span> task <span class="op">=</span> coro_func<span class="op">();</span></span>
<span id="cb23-88"><a href="#cb23-88"></a>    task<span class="op">.</span>put<span class="op">(</span><span class="st">"To boldly go where no man has gone before"</span><span class="op">);</span></span>
<span id="cb23-89"><a href="#cb23-89"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-90"><a href="#cb23-90"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb24-1"><a href="#cb24-1"></a>get_return_object</span>
<span id="cb24-2"><a href="#cb24-2"></a>Task(promise_type&amp;) ctor</span>
<span id="cb24-3"><a href="#cb24-3"></a>initial_suspend</span>
<span id="cb24-4"><a href="#cb24-4"></a>To boldly go where no man has gone beforereturn_void</span>
<span id="cb24-5"><a href="#cb24-5"></a>final_suspend</span>
<span id="cb24-6"><a href="#cb24-6"></a>~Task()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="coroutine-generators" class="level2">
<h2 class="anchored" data-anchor-id="coroutine-generators">Coroutine Generators</h2>
<p>A <strong>generator</strong> is a coroutine that generates a sequence of elements by repeatedly resuming itself from the point that it was suspended.</p>
<p>A generator can be seen as an infinite list, because it can generate an arbitrary number of elements.</p>
<p>Implementing even the most basic coroutine in C++ requires a certain amount of code. C++23 introduced the <code>std::generator</code> template class. I present below the source code for a simple <code>FibonacciGenerator</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;generator&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="bu">std::</span>generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> makeFibonacciGenerator<span class="op">(){</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="dt">int</span> i1<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="dt">int</span> i2<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="cf">while</span><span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>        <span class="cf">co_yield</span> i1<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>        i1 <span class="op">=</span> <span class="bu">std::</span>exchange<span class="op">(</span>i2<span class="op">,</span> i1 <span class="op">+</span> i2<span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="op">}</span></span>
<span id="cb25-13"><a href="#cb25-13"></a></span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="kw">auto</span> fibo_gen <span class="op">=</span> makeFibonacciGenerator<span class="op">();</span></span>
<span id="cb25-16"><a href="#cb25-16"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"The first 10 numbers the Fibonacci sequence are : "</span><span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>    <span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb25-18"><a href="#cb25-18"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> f <span class="op">=</span> fibo_gen<span class="op">.</span>begin<span class="op">();</span> f<span class="op">!=</span>fibo_gen<span class="op">.</span>end<span class="op">();++</span>f<span class="op">){</span></span>
<span id="cb25-19"><a href="#cb25-19"></a>        <span class="cf">if</span><span class="op">(</span>i  <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb25-20"><a href="#cb25-20"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"F[</span><span class="sc">{}</span><span class="st">] = </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> <span class="op">*</span>f<span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22"></a>        <span class="op">++</span>i<span class="op">;</span></span>
<span id="cb25-23"><a href="#cb25-23"></a>    <span class="op">}</span></span>
<span id="cb25-24"><a href="#cb25-24"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-25"><a href="#cb25-25"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>