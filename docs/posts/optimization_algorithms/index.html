<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2024-06-10">

<title>quantdev.blog - Optimization Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Optimization Algorithms</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">Machine Learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 10, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#gradient-vector" id="toc-gradient-vector" class="nav-link active" data-scroll-target="#gradient-vector">Gradient vector</a>
  <ul class="collapse">
  <li><a href="#the-directional-derivative" id="toc-the-directional-derivative" class="nav-link" data-scroll-target="#the-directional-derivative">The directional derivative</a></li>
  <li><a href="#gradients-and-steepest-ascent" id="toc-gradients-and-steepest-ascent" class="nav-link" data-scroll-target="#gradients-and-steepest-ascent">Gradients and steepest ascent</a></li>
  </ul></li>
  <li><a href="#gradient-descent---naive-implementation" id="toc-gradient-descent---naive-implementation" class="nav-link" data-scroll-target="#gradient-descent---naive-implementation">Gradient Descent - Naive Implementation</a></li>
  <li><a href="#convergence." id="toc-convergence." class="nav-link" data-scroll-target="#convergence.">Convergence.</a>
  <ul class="collapse">
  <li><a href="#decomposing-the-error" id="toc-decomposing-the-error" class="nav-link" data-scroll-target="#decomposing-the-error">Decomposing the error</a></li>
  <li><a href="#choosing-a-step-size" id="toc-choosing-a-step-size" class="nav-link" data-scroll-target="#choosing-a-step-size">Choosing a step size</a></li>
  </ul></li>
  <li><a href="#stochastic-gradient-descentsgd" id="toc-stochastic-gradient-descentsgd" class="nav-link" data-scroll-target="#stochastic-gradient-descentsgd">Stochastic Gradient Descent(SGD)</a></li>
  <li><a href="#sgdoptimizer-class" id="toc-sgdoptimizer-class" class="nav-link" data-scroll-target="#sgdoptimizer-class"><code>SGDOptimizer</code> class</a></li>
  <li><a href="#learning-rate-decay" id="toc-learning-rate-decay" class="nav-link" data-scroll-target="#learning-rate-decay">Learning Rate Decay</a></li>
  <li><a href="#stochastic-gradient-descent-with-momentum" id="toc-stochastic-gradient-descent-with-momentum" class="nav-link" data-scroll-target="#stochastic-gradient-descent-with-momentum">Stochastic Gradient Descent with Momentum</a>
  <ul class="collapse">
  <li><a href="#the-dynamics-of-momentum" id="toc-the-dynamics-of-momentum" class="nav-link" data-scroll-target="#the-dynamics-of-momentum">The dynamics of Momentum</a></li>
  </ul></li>
  <li><a href="#adding-momentum-to-the-sgdoptimizer-class" id="toc-adding-momentum-to-the-sgdoptimizer-class" class="nav-link" data-scroll-target="#adding-momentum-to-the-sgdoptimizer-class">Adding momentum to the <code>SGDOptimizer</code> class</a></li>
  <li><a href="#adagrad" id="toc-adagrad" class="nav-link" data-scroll-target="#adagrad">AdaGrad</a></li>
  <li><a href="#rmsprop" id="toc-rmsprop" class="nav-link" data-scroll-target="#rmsprop">RMSProp</a>
  <ul class="collapse">
  <li><a href="#the-algorithm" id="toc-the-algorithm" class="nav-link" data-scroll-target="#the-algorithm">The Algorithm</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="gradient-vector" class="level2">
<h2 class="anchored" data-anchor-id="gradient-vector">Gradient vector</h2>
<p><em>Definition</em>. Let <span class="math inline">\(f:\mathbf{R}^n \to \mathbf{R}\)</span> be a scalar-valued function. The gradient vector of <span class="math inline">\(f\)</span> is defined as:</p>
<p><span class="math display">\[\begin{align*}
\nabla f(\mathbf{x}) = \left[\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\ldots,\frac{\partial f}{\partial x_n}\right]
\end{align*}\]</span></p>
<p>The graph of the function <span class="math inline">\(f:\mathbf{R}^n \to \mathbf{R}\)</span> is the <em>hypersurface</em> in <span class="math inline">\(\mathbf{R}^{n+1}\)</span> given by the equation <span class="math inline">\(x_{n+1}=f(x_1,\ldots,x_n)\)</span>.</p>
<p><em>Definition</em>. <span class="math inline">\(f\)</span> is said to be <em>differentiable</em> at <span class="math inline">\(\mathbf{a}\)</span> if all the partial derivatives <span class="math inline">\(f_{x_i}(\mathbf{a})\)</span> exist and if the function <span class="math inline">\(h(\mathbf{x})\)</span> defined by:</p>
<p><span class="math display">\[\begin{align*}
h(\mathbf{x}) = f(\mathbf{a}) + \nabla f(\mathbf{a})\cdot (\mathbf{x}-\mathbf{a})
\end{align*}\]</span></p>
<p>is a good linear approximation to <span class="math inline">\(f\)</span> near <span class="math inline">\(a\)</span>, meaning that:</p>
<p><span class="math display">\[\begin{align*}
L = \lim_{\mathbf{x} \to \mathbf{a}} \frac{f(\mathbf{x}) - h(\mathbf{x})}{||\mathbf{x} - \mathbf{a}||} = 0
\end{align*}\]</span></p>
<p>If <span class="math inline">\(f\)</span> is differentiable at <span class="math inline">\(\mathbf{a},f(\mathbf{a})\)</span>, then the hypersurface determined by the graph has a <em>tangent hyperplane</em> at <span class="math inline">\((\mathbf{a},f(\mathbf{a}))\)</span> given by the equation:</p>
<p><span class="math display">\[\begin{align*}
h(\mathbf{x}) = f(\mathbf{a}) + \nabla f(\mathbf{a})\cdot (\mathbf{x}-\mathbf{a})
\end{align*}\]</span></p>
<section id="the-directional-derivative" class="level3">
<h3 class="anchored" data-anchor-id="the-directional-derivative">The directional derivative</h3>
<p>Let <span class="math inline">\(f(x,y)\)</span> be a scalar-valued function of two variables. We understand the partial derivative <span class="math inline">\(\frac{\partial f}{\partial x}(a,b)\)</span> as the slope at the point <span class="math inline">\((a,b,f(a,b))\)</span> of the curve obtained as the intersection of the surface <span class="math inline">\(z=f(x,y)\)</span> and the plane <span class="math inline">\(y=b\)</span>. The other partial derivative has a geometric interpretation. However, the surface <span class="math inline">\(z=f(x,y)\)</span> contains infinitely many curves passing through <span class="math inline">\((a,b,f(a,b))\)</span> whose slope we might choose to measure. The directional derivative enables us to do this.</p>
<p>Intuitively, <span class="math inline">\(\frac{\partial f}{\partial x}(a,b)\)</span> is as the rate of change of <span class="math inline">\(f\)</span> as we move <em>infinitesimally</em> from <span class="math inline">\(\mathbf{a}=(a,b)\)</span> in the <span class="math inline">\(\mathbf{i}\)</span> direction.</p>
<p>Mathematically, by the definition of the derivative of <span class="math inline">\(f\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\frac{\partial f}{\partial x}(a,b) &amp;= \lim_{h \to 0} \frac{f(a+h,b) - f(a,b)}{h}\\
&amp;=\lim_{h \to 0} \frac{f((a,b) + (h,0)) - f(a,b)}{h}\\
&amp;=\lim_{h \to 0} \frac{f((a,b) + h(1,0)) - f(a,b)}{h}\\
&amp;=\lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{i}) - f(\mathbf{a})}{h}
\end{align*}\]</span></p>
<p>Similarly, we have:</p>
<p><span class="math display">\[\begin{align*}
\frac{\partial f}{\partial y}(a,b) = \lim_{h\to 0} \frac{f(\mathbf{a} + h\mathbf{j})-f(\mathbf{a})}{h}
\end{align*}\]</span></p>
<p>Writing partial derivatives as we have enables us to see that they are special cases of a more general type of derivative. Suppose <span class="math inline">\(\mathbf{v}\)</span> is a unit vector in <span class="math inline">\(\mathbf{R}^2\)</span>. The quantity:</p>
<p><span class="math display">\[\begin{align*}
\lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{v}) - f(\mathbf{a})}{h}
\end{align*}\]</span></p>
<p>is nothing more than the rate of change of <span class="math inline">\(f\)</span> as we move infinitesimally from <span class="math inline">\(\mathbf{a} = (a,b)\)</span> in the direction specified by <span class="math inline">\(\mathbf{v}=(A,B) = A\mathbf{i} + B\mathbf{j}\)</span>.</p>
<p><em>Definition</em>. Let <span class="math inline">\(\mathbf{v}\in \mathbf{R}^n\)</span> be any unit vector, then the <em>directional derivative</em> of <span class="math inline">\(f\)</span> at <span class="math inline">\(\mathbf{a}\)</span> in the direction of <span class="math inline">\(\mathbf{v}\)</span>, denoted <span class="math inline">\(D_{\mathbf{v}}f(\mathbf{a})\)</span> is:</p>
<p><span class="math display">\[\begin{align*}
D_{\mathbf{v}}f(\mathbf{a}) = \lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{v}) - f(\mathbf{a})}{h}
\end{align*}\]</span></p>
<p>Let’s define a new function <span class="math inline">\(F\)</span> of a single variable <span class="math inline">\(t\)</span>, by holding everything else constant:</p>
<p><span class="math display">\[\begin{align*}
F(t) = f(\mathbf{a} + t\mathbf{v})
\end{align*}\]</span></p>
<p>Then, by the definition of directional derivatives, we have:</p>
<p><span class="math display">\[\begin{align*}
D_{\mathbf{v}}f(\mathbf{a}) &amp;= \lim_{t\to 0} \frac{f(\mathbf{a} + t\mathbf{v}) - f(\mathbf{a})}{t}\\
&amp;= \lim_{t\to 0} \frac{F(t) - F(0)}{t - 0} \\
&amp;= F'(0)
\end{align*}\]</span></p>
<p>That is:</p>
<p><span class="math display">\[\begin{align*}
D_{\mathbf{v}}f(\mathbf{a}) = \frac{d}{dt} f(\mathbf{a} + t\mathbf{v})\vert_{t=0}
\end{align*}\]</span></p>
<p>Let <span class="math inline">\(\mathbf{x}(t) = \mathbf{a}+t\mathbf{v}\)</span>. Then, by the chain rule:</p>
<p><span class="math display">\[\begin{align*}
\frac{d}{dt} f(\mathbf{a} + t\mathbf{v}) &amp;= Df(\mathbf{x}) D\mathbf{x}(t) \\
&amp;= \nabla f(\mathbf{x}) \cdot \mathbf{v}
\end{align*}\]</span></p>
<p>This equation emphasizes the geometry of the situation. The directional derivative is just the dot product of the gradient vector and the direction vector <span class="math inline">\(\mathbf{v}\)</span>.</p>
<p><em>Theorem.</em> Let <span class="math inline">\(f:X\to\mathbf{R}\)</span> be differentiable at <span class="math inline">\(\mathbf{a}\in X\)</span>. Then, the directional derivative <span class="math inline">\(D_{\mathbf{v}}f(\mathbf{a})\)</span> exists for all directions <span class="math inline">\(\mathbf{v}\in\mathbf{R}^n\)</span> and moreover we have:</p>
<p><span class="math display">\[\begin{align*}
D_{\mathbf{v}}f(\mathbf{a}) = \nabla f(\mathbf{x})\cdot \mathbf{v}
\end{align*}\]</span></p>
</section>
<section id="gradients-and-steepest-ascent" class="level3">
<h3 class="anchored" data-anchor-id="gradients-and-steepest-ascent">Gradients and steepest ascent</h3>
<p>Suppose you are traveling in space near the planet Nilrebo and that one of your spaceship’s instruments measures the external atmospheric pressure on your ship as a function <span class="math inline">\(f(x,y,z)\)</span> of position. Assume quite reasonably that this function is differentiable. Then, the directional derivative exists and if you travel from point <span class="math inline">\(\mathbf{a}=(a,b,c)\)</span> in the direction of the unit vector <span class="math inline">\(\mathbf{u}=u\mathbf{i}+v\mathbf{j}+w\mathbf{k}\)</span>, the rate of change of pressure is given by:</p>
<p><span class="math display">\[\begin{align*}
D_{\mathbf{u}}f(\mathbf{a}) = \nabla f(\mathbf{a}) \cdot \mathbf{u} = ||\nabla f(\mathbf{a})|| \cdot ||\mathbf{u}|| \cos \theta
\end{align*}\]</span></p>
<p>where <span class="math inline">\(\theta\)</span> is the angle between <span class="math inline">\(\mathbf{u}\)</span> and the gradient vector <span class="math inline">\(\nabla f(\mathbf{a})\)</span>. Because, <span class="math inline">\(-1 \leq \cos \theta \leq 1\)</span>, and <span class="math inline">\(||\mathbf{u}||=1\)</span>, we have:</p>
<p><span class="math display">\[\begin{align*}
- ||\nabla f(\mathbf{a})|| \leq D_{\mathbf{u}}f(\mathbf{a}) \leq ||\nabla f(\mathbf{a})||
\end{align*}\]</span></p>
<p>Moreover, <span class="math inline">\(\cos \theta = 1\)</span> when <span class="math inline">\(\theta = 0\)</span> and <span class="math inline">\(\cos \theta = -1\)</span> when <span class="math inline">\(\theta = \pi\)</span>.</p>
<p><em>Theorem</em>. The directional derivative <span class="math inline">\(D_{\mathbf{u}}f(\mathbf{a})\)</span> is maximized, with respect to the direction, when <span class="math inline">\(\mathbf{u}\)</span> points in the direction of the gradient vector <span class="math inline">\(f(\mathbf{a})\)</span> and is minimized when <span class="math inline">\(\mathbf{u}\)</span> points in the opposite direction. Furthermore, the maximum and minimum values of <span class="math inline">\(D_{\mathbf{u}}f(\mathbf{a})\)</span> are <span class="math inline">\(||\nabla f(\mathbf{a})||\)</span> and <span class="math inline">\(-||\nabla f(\mathbf{a})||\)</span>.</p>
<p><em>Theorem</em> Let <span class="math inline">\(f:X \subseteq \mathbf{R}^n \to \mathbf{R}\)</span> be a function of class <span class="math inline">\(C^1\)</span>. If <span class="math inline">\(\mathbf{x}_0\)</span> is a point on the level set <span class="math inline">\(S=\{\mathbf{x} \in X | f(\mathbf{x}) = c\}\)</span>, then the gradient vector <span class="math inline">\(\nabla f(\mathbf{x}_0) \in \mathbf{R}^n\)</span> is perpendicular to <span class="math inline">\(S\)</span>.</p>
<p><em>Proof.</em> We need to establish the following: if <span class="math inline">\(\mathbf{v}\)</span> is any vector tangent to <span class="math inline">\(S\)</span> at <span class="math inline">\(\mathbf{x}_0\)</span>, then <span class="math inline">\(\nabla f(\mathbf{x}_0)\)</span> is perpendicular to <span class="math inline">\(\mathbf{v}\)</span> (i.e.&nbsp;<span class="math inline">\(\nabla f(\mathbf{x}_0) \cdot \mathbf{v} = 0\)</span>). By a tangent vector to <span class="math inline">\(S\)</span> at <span class="math inline">\(\mathbf{x}_0\)</span>, we mean that <span class="math inline">\(\mathbf{v}\)</span> is the velocity vector of a curve <span class="math inline">\(C\)</span> that lies in <span class="math inline">\(S\)</span> and passes through <span class="math inline">\(\mathbf{x}_0\)</span>.</p>
<p>Let <span class="math inline">\(C\)</span> be given parametrically by <span class="math inline">\(\mathbf{x}(t)=(x_1(t),\ldots,x_n(t))\)</span> where <span class="math inline">\(a &lt; t &lt; b\)</span> and <span class="math inline">\(\mathbf{x}(t_0) = \mathbf{x}_0\)</span> for some number <span class="math inline">\(t_0\)</span> in <span class="math inline">\((a,b)\)</span>.</p>
<p><span class="math display">\[\begin{align*}
\frac{d}{dt}[f(\mathbf{x}(t))] &amp;= Df(\mathbf{x}) \cdot \mathbf{x}'(t)\\
&amp;= \nabla f(\mathbf{x}) \cdot \mathbf{v}
\end{align*}\]</span></p>
<p>Evaluation at <span class="math inline">\(t = t_0\)</span>, yields:</p>
<p><span class="math display">\[\begin{align*}
\nabla f (\mathbf{x}(t_0)) \cdot \mathbf{x}'(t_0) = \nabla f(\mathbf{x}_0) \cdot \mathbf{v}
\end{align*}\]</span></p>
<p>On the other hand, since <span class="math inline">\(C\)</span> is contained in <span class="math inline">\(S\)</span>, <span class="math inline">\(f(\mathbf{x})=c\)</span>. So,</p>
<p><span class="math display">\[\begin{align*}
\frac{d}{dt}[f(\mathbf{x}(t))] &amp;= \frac{d}{dt}[c] = 0
\end{align*}\]</span></p>
<p>Putting the above two facts together, we have the desired result.</p>
</section>
</section>
<section id="gradient-descent---naive-implementation" class="level2">
<h2 class="anchored" data-anchor-id="gradient-descent---naive-implementation">Gradient Descent - Naive Implementation</h2>
<p>Beginning at <span class="math inline">\(\mathbf{x}_0\)</span>, optimization algorithms generate a sequence of iterates <span class="math inline">\(\{\mathbf{x}_k\}_{k=0}^{\infty}\)</span> that terminate when no more progress can be made or it seems a solution point has been approximated with sufficient accuracy. The <em>gradient descent method</em> is an optimization algorithm that moves along <span class="math inline">\(\mathbf{d}_k = -\nabla f(\mathbf{x}_k)\)</span> at every step. Thus,</p>
<p><span class="math display">\[\begin{align*}
\mathbf{x}_{k+1} = \mathbf{x}_k - \alpha_k \mathbf{d}_k
\end{align*}\]</span></p>
<p>It can choose the step length <span class="math inline">\(\alpha_k\)</span> in a variety of ways. One advantage of steepest descent is that it requires the calculation of the gradient <span class="math inline">\(\nabla f(\mathbf{x}_k)\)</span>, but not of the second derivatives. However, it can be excruciatingly slow on difficult problems.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">%</span>load_ext itikz</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> typing <span class="im">import</span> Callable</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">def</span> gradient_descent(</span>
<span id="cb2-6"><a href="#cb2-6"></a>    func: Callable[[<span class="bu">float</span>], <span class="bu">float</span>],</span>
<span id="cb2-7"><a href="#cb2-7"></a>    alpha: <span class="bu">float</span>,</span>
<span id="cb2-8"><a href="#cb2-8"></a>    xval_0: np.array,</span>
<span id="cb2-9"><a href="#cb2-9"></a>    epsilon: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-5</span>,</span>
<span id="cb2-10"><a href="#cb2-10"></a>    n_iter: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10000</span>,</span>
<span id="cb2-11"><a href="#cb2-11"></a>    debug_step: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>,</span>
<span id="cb2-12"><a href="#cb2-12"></a>):</span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="co">"""</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">    The gradient descent algorithm.</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co">    """</span></span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a>    xval_hist <span class="op">=</span> []</span>
<span id="cb2-18"><a href="#cb2-18"></a>    funcval_hist <span class="op">=</span> []</span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a>    xval_curr <span class="op">=</span> xval_0</span>
<span id="cb2-21"><a href="#cb2-21"></a>    error <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a>    <span class="cf">while</span> np.linalg.norm(error) <span class="op">&gt;</span> epsilon <span class="kw">and</span> i <span class="op">&lt;</span> n_iter:</span>
<span id="cb2-25"><a href="#cb2-25"></a>        <span class="co"># Save down x_curr and func(x_curr)</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>        xval_hist.append(xval_curr)</span>
<span id="cb2-27"><a href="#cb2-27"></a>        funcval_hist.append(func(xval_curr))</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a>        <span class="co"># Calculate the forward difference</span></span>
<span id="cb2-30"><a href="#cb2-30"></a>        bump <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>        num_dims <span class="op">=</span> <span class="bu">len</span>(xval_curr)</span>
<span id="cb2-32"><a href="#cb2-32"></a>        xval_bump <span class="op">=</span> xval_curr <span class="op">+</span> np.eye(num_dims) <span class="op">*</span> bump</span>
<span id="cb2-33"><a href="#cb2-33"></a>        xval_nobump <span class="op">=</span> np.full((num_dims, num_dims), xval_curr)</span>
<span id="cb2-34"><a href="#cb2-34"></a></span>
<span id="cb2-35"><a href="#cb2-35"></a>        grad <span class="op">=</span> np.array(</span>
<span id="cb2-36"><a href="#cb2-36"></a>            [</span>
<span id="cb2-37"><a href="#cb2-37"></a>                (func(xval_h) <span class="op">-</span> func(xval)) <span class="op">/</span> bump</span>
<span id="cb2-38"><a href="#cb2-38"></a>                <span class="cf">for</span> xval_h, xval <span class="kw">in</span> <span class="bu">zip</span>(xval_bump, xval_nobump)</span>
<span id="cb2-39"><a href="#cb2-39"></a>            ]</span>
<span id="cb2-40"><a href="#cb2-40"></a>        )</span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a>        <span class="co"># Compute the next iterate</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>        xval_next <span class="op">=</span> xval_curr <span class="op">-</span> alpha <span class="op">*</span> grad</span>
<span id="cb2-44"><a href="#cb2-44"></a></span>
<span id="cb2-45"><a href="#cb2-45"></a>        <span class="co"># Compute the error vector</span></span>
<span id="cb2-46"><a href="#cb2-46"></a>        error <span class="op">=</span> xval_next <span class="op">-</span> xval_curr</span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a>        <span class="cf">if</span> i <span class="op">%</span> debug_step <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-49"><a href="#cb2-49"></a>            <span class="bu">print</span>(</span>
<span id="cb2-50"><a href="#cb2-50"></a>                <span class="ss">f"x[</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">] = </span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">, f(</span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>func(xval_curr)<span class="sc">}</span><span class="ss">, f'(</span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>grad<span class="sc">}</span><span class="ss">, error=</span><span class="sc">{</span>error<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb2-51"><a href="#cb2-51"></a>            )</span>
<span id="cb2-52"><a href="#cb2-52"></a></span>
<span id="cb2-53"><a href="#cb2-53"></a>        xval_curr <span class="op">=</span> xval_next</span>
<span id="cb2-54"><a href="#cb2-54"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-55"><a href="#cb2-55"></a></span>
<span id="cb2-56"><a href="#cb2-56"></a>    <span class="cf">return</span> xval_hist, funcval_hist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One infamous test function is the <em>Rosenbrock function</em> defined as:</p>
<p><span class="math display">\[\begin{align*}
f(x,y) = (a-x)^2 + b(y-x^2)^2
\end{align*}\]</span></p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> rosenbrock(x):</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span><span class="op">*</span>(x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">def</span> f(x):</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="cf">return</span> x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is the plot of the Rosenbrock function with parameters <span class="math inline">\(a=1,b=100\)</span>.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb4-2"><a href="#cb4-2"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb4-3"><a href="#cb4-3"></a>\begin{axis}[</span>
<span id="cb4-4"><a href="#cb4-4"></a>     title<span class="op">=</span>{Plot of $f(x,y)<span class="op">=</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span>(y<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span>)<span class="op">^</span><span class="dv">2</span>$},</span>
<span id="cb4-5"><a href="#cb4-5"></a>]</span>
<span id="cb4-6"><a href="#cb4-6"></a>    \addplot3 [surf] {(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span><span class="op">*</span>(y<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span>)<span class="op">^</span><span class="dv">2</span>}<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>\end{axis}</span>
<span id="cb4-8"><a href="#cb4-8"></a>\end{tikzpicture}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="4">
<p><img src="index_files/figure-html/cell-5-output-1.svg" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>x_history, f_x_history <span class="op">=</span> gradient_descent(</span>
<span id="cb5-2"><a href="#cb5-2"></a>    func<span class="op">=</span>rosenbrock,</span>
<span id="cb5-3"><a href="#cb5-3"></a>    alpha<span class="op">=</span><span class="fl">0.001</span>,</span>
<span id="cb5-4"><a href="#cb5-4"></a>    xval_0<span class="op">=</span>np.array([<span class="op">-</span><span class="fl">2.0</span>, <span class="fl">2.0</span>]),</span>
<span id="cb5-5"><a href="#cb5-5"></a>    epsilon<span class="op">=</span><span class="fl">1e-7</span>,</span>
<span id="cb5-6"><a href="#cb5-6"></a>    debug_step<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb5-7"><a href="#cb5-7"></a>)</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="bu">print</span>(<span class="ss">f"x* = </span><span class="sc">{</span>x_history[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">, f(x*)=</span><span class="sc">{</span>f_x_history[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>x[0] = [-2.  2.], f([-2.  2.]) = 409.0, f'([-2.  2.]) = [-1603.9997999  -399.9      ], error=[1.6039998 0.3999   ]
x[1000] = [-0.34194164  0.12278388], f([-0.34194164  0.12278388]) = 1.804241076974863, f'([-0.34194164  0.12278388]) = [-1.8359394   1.27195859], error=[ 0.00183594 -0.00127196]
x[2000] = [0.59082668 0.34719456], f([0.59082668 0.34719456]) = 0.16777685109400048, f'([0.59082668 0.34719456]) = [-0.23242066 -0.27632251], error=[0.00023242 0.00027632]
x[3000] = [0.71914598 0.51617916], f([0.71914598 0.51617916]) = 0.0789773438798074, f'([0.71914598 0.51617916]) = [-0.06806067 -0.09835534], error=[6.80606659e-05 9.83553399e-05]
x[4000] = [0.7626568  0.58094326], f([0.7626568  0.58094326]) = 0.05638109494458334, f'([0.7626568  0.58094326]) = [-0.02638936 -0.04042575], error=[2.63893643e-05 4.04257465e-05]
x[5000] = [0.78028032 0.60825002], f([0.78028032 0.60825002]) = 0.04831123625687607, f'([0.78028032 0.60825002]) = [-0.01115051 -0.01747329], error=[1.11505139e-05 1.74732947e-05]
x[6000] = [0.78785296 0.62017375], f([0.78785296 0.62017375]) = 0.045035368749296534, f'([0.78785296 0.62017375]) = [-0.00487137 -0.00770719], error=[4.87136843e-06 7.70718502e-06]
x[7000] = [0.79118466 0.62545602], f([0.79118466 0.62545602]) = 0.04363059164103049, f'([0.79118466 0.62545602]) = [-0.00215834 -0.00342913], error=[2.1583377e-06 3.4291304e-06]
x[8000] = [0.79266536 0.62781071], f([0.79266536 0.62781071]) = 0.04301342477692797, f'([0.79266536 0.62781071]) = [-0.00096218 -0.00153153], error=[9.62177510e-07 1.53153219e-06]
x[9000] = [0.79332635 0.62886327], f([0.79332635 0.62886327]) = 0.042739342077472306, f'([0.79332635 0.62886327]) = [-0.0004301  -0.00068518], error=[4.30102710e-07 6.85176669e-07]
x* = [0.7936218  0.62933403], f(x*)=0.04261711392593988</code></pre>
</div>
</div>
</section>
<section id="convergence." class="level2">
<h2 class="anchored" data-anchor-id="convergence.">Convergence.</h2>
<p>When applying gradient descent in practice, we need to choose a value for the learning rate parameter <span class="math inline">\(\alpha\)</span>. An error surface <span class="math inline">\(E\)</span> is usually a convex function on the weight space <span class="math inline">\(\mathbf{w}\)</span>. Intuitively, we might expect that increasing the value of <span class="math inline">\(\alpha\)</span> should lead to bigger steps through the weight space and hence faster convergence. However, the successive steps oscillate back and forth across the valley, and if we increase <span class="math inline">\(\alpha\)</span> too much, these oscillations will become divergent. Because <span class="math inline">\(\alpha\)</span> must be kept sufficiently small to avoid divergent oscillations across the valley, progress along the valley is very slow. Gradient descent then takes many small steps to reach the minimum and is a very inefficient procedure.</p>
<p>We can gain deeper insight into this problem, by considering a quadratic approximation to the error function in the neighbourhood of the minimum. Let the error function be given by:</p>
<p><span class="math display">\[\begin{align*}
f(w) = \frac{1}{2}w^T A w - b^T w, \quad w\in\mathbf{R}^n
\end{align*}\]</span></p>
<p>where <span class="math inline">\(A\)</span> is symmetric and <span class="math inline">\(A \succ 0\)</span>.</p>
<p>Differentiating on both sides, the gradient of the error function is:</p>
<p><span class="math display">\[\begin{align*}
\nabla f(w) = Aw - b
\end{align*}\]</span></p>
<p>and the hessian is:</p>
<p><span class="math display">\[\begin{align*}
\nabla^2 f(w) = A
\end{align*}\]</span></p>
<p>The critical points of <span class="math inline">\(f\)</span> are given by:</p>
<p><span class="math display">\[\begin{align*}
\nabla f(w^*) &amp;= 0\\
Aw^{*} - b &amp;= 0\\
w^{*} &amp;= A^{-1}b
\end{align*}\]</span></p>
<p>and</p>
<p><span class="math display">\[\begin{align*}
f(w^{*}) &amp;= \frac{1}{2}(A^{-1}b)^T A (A^{-1}b) - b^T (A^{-1} b)\\
&amp;= \frac{1}{2}b^T A^{-1} A A^{-1} b -b^T A^{-1} b \\
&amp;= \frac{1}{2}b^T A^{-1} b - b^T A^{-1} b \\
&amp;= -\frac{1}{2}b^T A^{-1} b
\end{align*}\]</span></p>
<p>Therefore, the iterates of <span class="math inline">\(w\)</span> are:</p>
<p><span class="math display">\[\begin{align*}
w^{(k+1)} = w^{(k)} - \alpha(Aw^{(k)} - b)
\end{align*}\]</span></p>
<p>By the <em>spectral theorem</em>, every symmetric matrix <span class="math inline">\(A\)</span> is orthogonally diagonalizable. So, <span class="math inline">\(A\)</span> admits a factorization:</p>
<p><span class="math display">\[\begin{align*}
A = Q \Lambda Q^T
\end{align*}\]</span></p>
<p>where <span class="math inline">\(\Lambda = diag(\lambda_1,\ldots,\lambda_n)\)</span> and as per convention, we will assume that <span class="math inline">\(\lambda_i\)</span>are sorted from smallest <span class="math inline">\(\lambda_1\)</span> to biggest <span class="math inline">\(\lambda_n\)</span>.</p>
<p>Recall that <span class="math inline">\(Q=[q_1,\ldots,q_n]\)</span>, where <span class="math inline">\(q_i\)</span> are the eigenvectors of <span class="math inline">\(A\)</span> and <span class="math inline">\(Q\)</span> is the change of basis matrix from the standard basis to the eigenvector basis. So, if <span class="math inline">\(a \in \mathbf{R}^n\)</span> are the coordinates of a vector in the standard basis and <span class="math inline">\(b \in \mathbf{R}^n\)</span> are its coordinates in the eigenvector basis, then <span class="math inline">\(a = Qb\)</span> or <span class="math inline">\(b=Q^T a\)</span>.</p>
<p>Let <span class="math inline">\(x^{(k)}=Q^T(w^{(k)}-w^{*})\)</span>. Equivalently, <span class="math inline">\(w^{(k)} = Qx^{(k)} + w^{*}\)</span>. Thus, we are shifting the origin to <span class="math inline">\(w^{*}\)</span> and changing the axes to be aligned with the eigenvectors. In this new coordinate system,</p>
<p><span class="math display">\[\begin{align*}
Qx^{(k+1)} + w^{*} &amp;= Qx^{(k)} + w^{*} - \alpha(AQx^{(k)} + Aw^{*} - b)\\
Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)} + Aw^{*} - b)\\
Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)} + A(A^{-1}b) - b)\\
&amp; \quad \{\text{Substituting } w^{*}=A^{-1}b \}\\
Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)})\\
Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(Q\Lambda Q^T Qx^{(k)})\\
&amp; \quad \{\text{Substituting } A = Q\Lambda Q^T \}\\
Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(Q\Lambda x^{(k)})\\
&amp; \quad \{\text{Using } Q^T Q = I \}\\
x^{(k+1)} &amp;= x^{(k)} - \alpha\Lambda x^{(k)}
\end{align*}\]</span></p>
<p>The <span class="math inline">\(i\)</span>-th coordinate of this recursive system is given by:</p>
<p><span class="math display">\[\begin{align*}
x_i^{(k+1)} &amp;= x_i^{(k)} - \alpha\lambda_i x_i^{(k)}\\
&amp;= (1-\alpha \lambda_i)x_i^{(k)}\\
&amp;= (1-\alpha \lambda_i)^{k+1}x_i^{(0)}
\end{align*}\]</span></p>
<p>Moving back to our original space <span class="math inline">\(w\)</span>, we can see that:</p>
<p><span class="math display">\[\begin{align*}
w^{(k)} - w^{*} = Qx^{(k)} &amp;= \sum_i q_i x_i^{(k)}\\
&amp;= \sum_i q_i (1-\alpha \lambda_i)^{k+1} x_i^{(0)}
\end{align*}\]</span></p>
<p>and there we have it - gradient descent in the closed form.</p>
<section id="decomposing-the-error" class="level3">
<h3 class="anchored" data-anchor-id="decomposing-the-error">Decomposing the error</h3>
<p>The above equation admits a simple interpretation. Each element of <span class="math inline">\(x^{(0)}\)</span> is the component of the error in the initial guess in <span class="math inline">\(Q\)</span>-basis. There are <span class="math inline">\(n\)</span> such errors and each of these errors follow their own, solitary path to the minimum, decreasing exponentially with a compounding rate of <span class="math inline">\(1-\alpha \lambda_i\)</span>. The closer that number is to <span class="math inline">\(1\)</span>, the slower it converges.</p>
<p>For most step-sizes, the eigenvectors with the largest eigenvalues converge the fastest. This triggers an explosion of progress in the first few iterations, before things slow down, as the eigenvectors with smaller eigenvalues’ struggles are revealed. It’s easy to visualize this - look at the sequences of <span class="math inline">\(\frac{1}{2^k}\)</span> and <span class="math inline">\(\frac{1}{3^k}\)</span>.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb7-2"><a href="#cb7-2"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb7-3"><a href="#cb7-3"></a>\begin{axis}[</span>
<span id="cb7-4"><a href="#cb7-4"></a>     title<span class="op">=</span>{Comparison of the rates of convergence},</span>
<span id="cb7-5"><a href="#cb7-5"></a>     xlabel<span class="op">=</span>{$n$},</span>
<span id="cb7-6"><a href="#cb7-6"></a>     ylabel<span class="op">=</span>{$f(n)$}</span>
<span id="cb7-7"><a href="#cb7-7"></a>]</span>
<span id="cb7-8"><a href="#cb7-8"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">5</span>,samples<span class="op">=</span><span class="dv">400</span>,blue] {<span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">^</span>x)} node [midway,above] {$<span class="dv">2</span><span class="op">^</span>{<span class="op">-</span>n}$}<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">5</span>,samples<span class="op">=</span><span class="dv">400</span>,red] {<span class="dv">1</span><span class="op">/</span>(<span class="dv">3</span><span class="op">^</span>x)} node [midway,below] {$<span class="dv">3</span><span class="op">^</span>{<span class="op">-</span>n}$}<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>\end{axis}</span>
<span id="cb7-11"><a href="#cb7-11"></a>\end{tikzpicture}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<p><img src="index_files/figure-html/cell-7-output-1.svg" class="img-fluid"></p>
</div>
</div>
</section>
<section id="choosing-a-step-size" class="level3">
<h3 class="anchored" data-anchor-id="choosing-a-step-size">Choosing a step size</h3>
<p>The above analysis gives us immediate guidance as to how to set a step-size <span class="math inline">\(\alpha\)</span>. In order to converge, each <span class="math inline">\(|1-\alpha \lambda_i| &lt; 1\)</span>. All workable step-sizes, therefore, fall in the interval:</p>
<p><span class="math display">\[\begin{align*}
-1 &amp;\leq 1 - \alpha \lambda_i &amp;\leq 1 \\
-2 &amp;\leq - \alpha \lambda_i &amp;\leq 0 \\
0 &amp;\leq \alpha \lambda_i &amp;\leq 2
\end{align*}\]</span></p>
<p>Because <span class="math inline">\((1-\alpha \lambda_i)\)</span> could be either positive or negative, the overall convergence rate is determined by the slowest error component, which must be either <span class="math inline">\(\lambda_1\)</span> or <span class="math inline">\(\lambda_n\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\text{rate}(\alpha) = \max \{|1-\alpha \lambda_1|,|1-\alpha \lambda_n|\}
\end{align*}\]</span></p>
<p>The optimal learning rate is that which balances the convergence rate. Setting the convergence rate to be equal for the smallest and largest eigenvalues, we can solve for the optimal step size.</p>
<p><span class="math display">\[\begin{align*}
|1- \alpha \lambda_1| = |1- \alpha \lambda_n|
\end{align*}\]</span></p>
<p>Assuming <span class="math inline">\(\lambda_1 \neq \lambda_n\)</span>:</p>
<p><span class="math display">\[\begin{align*}
1 - \alpha \lambda_1 &amp;= -1 + \alpha \lambda_n\\
\alpha (\lambda_1 + \lambda_n) &amp;= 2\\
\alpha^* &amp;= \frac{2}{\lambda_1 + \lambda_n}
\end{align*}\]</span></p>
<p>So, the optimal convergence rate equals:</p>
<p><span class="math display">\[\begin{align*}
\max \{|1-\alpha \lambda_1|,|1-\alpha \lambda_n|\} &amp;= 1 - \frac{2\lambda_1}{\lambda_1 + \lambda_n} \\
&amp;= \frac{\lambda_n - \lambda_1}{\lambda_n + \lambda_1}\\
&amp;= \frac{\kappa - 1}{\kappa + 1}
\end{align*}\]</span></p>
<p>The ratio <span class="math inline">\(\kappa = \lambda_n / \lambda_1\)</span> determines the convergence rate of the problem. Recall that the level curves of the error surface are ellipsoids. Hence, a poorly conditioned Hessian results in stretching one of the axes of the ellipses, and taken to its extreme, the contours are almost parallel. Since gradient vectors are orthogonal to the level curves, the optimizer keeps pin-balling between parallel lines and takes forever to reach the center.</p>
</section>
</section>
<section id="stochastic-gradient-descentsgd" class="level2">
<h2 class="anchored" data-anchor-id="stochastic-gradient-descentsgd">Stochastic Gradient Descent(SGD)</h2>
<p>In machine learning applications, we typically want to minimize the loss function <span class="math inline">\(\mathcal{L}(w)\)</span> that has the form of a sum:</p>
<p><span class="math display">\[\begin{align*}
\mathcal{L}(w) = \frac{1}{n}\sum_i L_i(w)
\end{align*}\]</span></p>
<p>where the weights <span class="math inline">\(w\)</span> (and the biases) are to be estimated. Each summand function <span class="math inline">\(L_i\)</span> is typically associated with the <span class="math inline">\(i\)</span>-th sample in the data-set used for training.</p>
<p>When we minimize the above function with respect to the weights and biases, a standard gradient descent method would perform the following operations:</p>
<p><span class="math display">\[\begin{align*}
w_{k+1} := w_k - \alpha_k \nabla \mathcal{L}(w_{k}) = w_k - \frac{\alpha_k}{n}\sum_{i} \nabla L_i(w_{k})
\end{align*}\]</span></p>
<p>In the stochastic (or online) gradient descent algorithm, the true gradient of <span class="math inline">\(\mathcal{L}(w)\)</span> is approximated by the gradient at a single sample:</p>
<p><span class="math display">\[\begin{align*}
w_{k+1} := w_k - \alpha_k \nabla \mathcal{L}(w_{k}) = w_k - \alpha_k \nabla L_i(w_{k})
\end{align*}\]</span></p>
</section>
<section id="sgdoptimizer-class" class="level2">
<h2 class="anchored" data-anchor-id="sgdoptimizer-class"><code>SGDOptimizer</code> class</h2>
<p>We are now in a position to code the <code>SGDOptimizer</code> class.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># Global imports</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">import</span> nnfs</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="im">from</span> nnfs.datasets <span class="im">import</span> spiral_data</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="im">from</span> dense_layer <span class="im">import</span> DenseLayer</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="im">from</span> relu_activation <span class="im">import</span> ReLUActivation</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="im">from</span> softmax_activation <span class="im">import</span> SoftmaxActivation</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="im">from</span> loss <span class="im">import</span> Loss</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="im">from</span> categorical_cross_entropy_loss <span class="im">import</span> CategoricalCrossEntropyLoss</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="im">from</span> categorical_cross_entropy_softmax <span class="im">import</span> CategoricalCrossEntropySoftmax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="co"># Initialize the optimizer</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb9-5"><a href="#cb9-5"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="co"># Update the parameters</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb9-9"><a href="#cb9-9"></a>        layer.weights <span class="op">-=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb9-10"><a href="#cb9-10"></a>        layer.biases <span class="op">-=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> layer.dloss_dbiases</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s play around with our optimizer.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># Create dataset</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"># Create a DenseLayer with 2 input features and 64 neurons</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co"># Create ReLU Activation (to be used with DenseLayer 1)</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="co"># Create the second DenseLayer with 64 inputs and 3 output values</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>,<span class="dv">3</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co"># Create SoftmaxClassifer's combined loss and activation</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="co"># The next step is to create the optimizer object</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>optimizer <span class="op">=</span> SGDOptimizer()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we perform a <em>forward pass</em> of our sample data.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Perform a forward pass for our sample data</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>dense1.forward(X)</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># Performs a forward pass through the activation function</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>activation1.forward(dense1.output)</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co"># Performs a forward pass through the second DenseLayer</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>dense2.forward(activation1.output)</span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co"># Performs a forward pass through the activation/loss function</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="co"># takes the output of the second DenseLayer and returns the loss</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="co"># Let's print the loss value</span></span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="bu">print</span>(<span class="ss">f"Loss = </span><span class="sc">{</span>loss<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-17"><a href="#cb11-17"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="co"># Now we do our backward pass </span></span>
<span id="cb11-19"><a href="#cb11-19"></a>loss_activation.backward(loss_activation.output, y)</span>
<span id="cb11-20"><a href="#cb11-20"></a>dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb11-21"><a href="#cb11-21"></a>activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb11-22"><a href="#cb11-22"></a>dense1.backward(activation1.dloss_dz)</span>
<span id="cb11-23"><a href="#cb11-23"></a></span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="co"># Then finally we use our optimizer to update the weights and biases</span></span>
<span id="cb11-25"><a href="#cb11-25"></a>optimizer.update_params(dense1)</span>
<span id="cb11-26"><a href="#cb11-26"></a>optimizer.update_params(dense2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Loss = 1.0986526582562541</code></pre>
</div>
</div>
<p>This is everything we need to train our model!</p>
<p>But why would we only perform this optimization only once, when we can perform it many times by leveraging Python’s looping capabilities? We will repeatedly perform a forward pass, backward pass and optimization until we reach some stopping point. Each full pass through all of the training data is called an <em>epoch</em>.</p>
<p>In most deep learning tasks, a neural network will be trained for multiple epochs, though the ideal scenario would be to have a perfect model with ideal weights and biases after only one epoch. To add multiple epochs of our training into our code, we will initialize our model and run a loop around all the code performing the forward pass, backward pass and optimization calculations.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># Create dataset</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co"># Create ReLU Activation (to be used with the DenseLayer)</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co"># Create a second DenseLayer with 64 input features (as we take</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co"># output of the previous layer here) and 3 output values (output values)</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co"># Create optimizer</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>optimizer <span class="op">=</span> SGDOptimizer()</span>
<span id="cb13-19"><a href="#cb13-19"></a></span>
<span id="cb13-20"><a href="#cb13-20"></a><span class="co"># Train in loop</span></span>
<span id="cb13-21"><a href="#cb13-21"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb13-22"><a href="#cb13-22"></a></span>
<span id="cb13-23"><a href="#cb13-23"></a>    <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb13-24"><a href="#cb13-24"></a>    dense1.forward(X)</span>
<span id="cb13-25"><a href="#cb13-25"></a></span>
<span id="cb13-26"><a href="#cb13-26"></a>    <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb13-27"><a href="#cb13-27"></a>    <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb13-28"><a href="#cb13-28"></a>    activation1.forward(dense1.output)</span>
<span id="cb13-29"><a href="#cb13-29"></a></span>
<span id="cb13-30"><a href="#cb13-30"></a>    <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb13-31"><a href="#cb13-31"></a>    <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb13-32"><a href="#cb13-32"></a>    dense2.forward(activation1.output)</span>
<span id="cb13-33"><a href="#cb13-33"></a></span>
<span id="cb13-34"><a href="#cb13-34"></a>    <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb13-35"><a href="#cb13-35"></a>    <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb13-36"><a href="#cb13-36"></a>    loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb13-37"><a href="#cb13-37"></a></span>
<span id="cb13-38"><a href="#cb13-38"></a>    <span class="cf">if</span> <span class="kw">not</span> epoch <span class="op">%</span> <span class="dv">1000</span>:</span>
<span id="cb13-39"><a href="#cb13-39"></a>        <span class="bu">print</span>(<span class="ss">f"Epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">"</span>)</span>
<span id="cb13-40"><a href="#cb13-40"></a></span>
<span id="cb13-41"><a href="#cb13-41"></a>    <span class="co"># Backward pass</span></span>
<span id="cb13-42"><a href="#cb13-42"></a>    loss_activation.backward(loss_activation.output, y)</span>
<span id="cb13-43"><a href="#cb13-43"></a>    dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb13-44"><a href="#cb13-44"></a>    activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb13-45"><a href="#cb13-45"></a>    dense1.backward(activation1.dloss_dz)</span>
<span id="cb13-46"><a href="#cb13-46"></a></span>
<span id="cb13-47"><a href="#cb13-47"></a>    <span class="co"># Update the weights and the biases</span></span>
<span id="cb13-48"><a href="#cb13-48"></a>    optimizer.update_params(dense1)</span>
<span id="cb13-49"><a href="#cb13-49"></a>    optimizer.update_params(dense2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch: 0, Loss:  1.099
Epoch: 1000, Loss:  1.029
Epoch: 2000, Loss:  0.962
Epoch: 3000, Loss:  0.848
Epoch: 4000, Loss:  0.699
Epoch: 5000, Loss:  0.544
Epoch: 6000, Loss:  0.508
Epoch: 7000, Loss:  0.478
Epoch: 8000, Loss:  0.460
Epoch: 9000, Loss:  0.443
Epoch: 10000, Loss:  0.419</code></pre>
</div>
</div>
<p>Our neural network mostly stays stuck at around a loss of <span class="math inline">\(1.0\)</span> and later around <span class="math inline">\(0.85\)</span>-<span class="math inline">\(0.90\)</span> Given that this loss didn’t decrease much, we can assume that this learning rate being too high, also caused the model to get stuck in a <strong>local minimum</strong>, which we’ll learn more about soon. Iterating over more epochs, doesn’t seem helpful at this point, which tells us that we’re likely stuck with our optimization. Does this mean that this is the most we can get from our optimizer on this dataset?</p>
<p>Recall that we’re adjusting our weights and biases by applying some fraction, in this case <span class="math inline">\(1.0\)</span> to the gradient and subtracting this from the weights and biases. This fraction is called the <strong>learning rate</strong> (LR) and is the primary adjustable parameter for the optimizer as it decreases loss.</p>
</section>
<section id="learning-rate-decay" class="level2">
<h2 class="anchored" data-anchor-id="learning-rate-decay">Learning Rate Decay</h2>
<p>The idea of a <em>learning rate decay</em> is to start with a large learning rate, say <span class="math inline">\(1.0\)</span> in our case and then decrease it during training. There are a few methods for doing this. One option is program a <strong>decay rate</strong>, which steadily decays the learning rate per batch or per epoch.</p>
<p>Let’s plan to decay per step. This can also be referred to as <span class="math inline">\(1/t\)</span> <strong>decaying</strong> or <strong>exponential decaying</strong>. Basically, we’re going to update the learning rate each step by the reciprocal of the step count fraction. This fraction is a new hyper parameter that we’ll add to the optimizer, called the <strong>learning rate decay</strong>.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>initial_learning_rate <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>learning_rate_decay <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb15-3"><a href="#cb15-3"></a></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb15-5"><a href="#cb15-5"></a>    learning_rate <span class="op">=</span> initial_learning_rate <span class="op">*</span> <span class="fl">1.0</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> learning_rate_decay <span class="op">*</span> step)</span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="bu">print</span>(learning_rate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1.0
0.9090909090909091
0.8333333333333334
0.7692307692307692
0.7142857142857143
0.6666666666666666
0.625
0.588235294117647
0.5555555555555556
0.5263157894736842</code></pre>
</div>
</div>
<p>The derivative of the function <span class="math inline">\(\frac{1}{1+x}\)</span> is <span class="math inline">\(-\frac{1}{(1+x)^2}\)</span>.</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb17-2"><a href="#cb17-2"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb17-3"><a href="#cb17-3"></a>\begin{axis}[</span>
<span id="cb17-4"><a href="#cb17-4"></a>     title<span class="op">=</span>{Plot of $f(x)<span class="op">=-</span>\frac{<span class="dv">1</span>}{(<span class="dv">1</span><span class="op">+</span>x)<span class="op">^</span><span class="dv">2</span>}$},</span>
<span id="cb17-5"><a href="#cb17-5"></a>     xlabel<span class="op">=</span>{$x$},</span>
<span id="cb17-6"><a href="#cb17-6"></a>     ylabel<span class="op">=</span>{$f(x)$}</span>
<span id="cb17-7"><a href="#cb17-7"></a>]</span>
<span id="cb17-8"><a href="#cb17-8"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">1</span>,samples<span class="op">=</span><span class="dv">400</span>] {<span class="op">-</span><span class="dv">1</span><span class="op">/</span>(( <span class="dv">1</span> <span class="op">+</span> x)<span class="op">^</span><span class="dv">2</span>)}<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>\end{axis}</span>
<span id="cb17-10"><a href="#cb17-10"></a>\end{tikzpicture}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<p><img src="index_files/figure-html/cell-14-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>The learning rate drops fast initially, but the change in the learning rate lowers in each step. We can update our <code>SGDOptimizer</code> class to allow for the learning rate decay.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb18-6"><a href="#cb18-6"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb18-7"><a href="#cb18-7"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb18-8"><a href="#cb18-8"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb18-9"><a href="#cb18-9"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb18-10"><a href="#cb18-10"></a></span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb18-13"><a href="#cb18-13"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb18-14"><a href="#cb18-14"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb18-15"><a href="#cb18-15"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb18-16"><a href="#cb18-16"></a>            )</span>
<span id="cb18-17"><a href="#cb18-17"></a></span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="co"># Update parameters</span></span>
<span id="cb18-19"><a href="#cb18-19"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb18-20"><a href="#cb18-20"></a>        layer.weights <span class="op">+=</span> <span class="op">-</span><span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb18-21"><a href="#cb18-21"></a>        layer.biases <span class="op">+=</span> <span class="op">-</span><span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb18-22"><a href="#cb18-22"></a></span>
<span id="cb18-23"><a href="#cb18-23"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb18-24"><a href="#cb18-24"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s use a decay rate of <span class="math inline">\(0.01\)</span> and train our neural network again.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">def</span> train(decay):</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="co"># Create a dataset</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>    dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a>    <span class="co"># Create ReLU activation (to be used with the dense layer)</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>    activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb19-10"><a href="#cb19-10"></a></span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="co"># Create second DenseLayer with 64 input features (as we take output of the</span></span>
<span id="cb19-12"><a href="#cb19-12"></a>    <span class="co"># previous layer here) and 3 output values</span></span>
<span id="cb19-13"><a href="#cb19-13"></a>    dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a>    <span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb19-16"><a href="#cb19-16"></a>    loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb19-17"><a href="#cb19-17"></a></span>
<span id="cb19-18"><a href="#cb19-18"></a>    <span class="co"># Create optimizer</span></span>
<span id="cb19-19"><a href="#cb19-19"></a>    optimizer <span class="op">=</span> SGDOptimizer(learning_rate<span class="op">=</span><span class="fl">1.0</span>,decay<span class="op">=</span>decay)</span>
<span id="cb19-20"><a href="#cb19-20"></a></span>
<span id="cb19-21"><a href="#cb19-21"></a>    acc_vals <span class="op">=</span> []</span>
<span id="cb19-22"><a href="#cb19-22"></a>    loss_vals <span class="op">=</span> []</span>
<span id="cb19-23"><a href="#cb19-23"></a>    lr_vals <span class="op">=</span> []</span>
<span id="cb19-24"><a href="#cb19-24"></a></span>
<span id="cb19-25"><a href="#cb19-25"></a>    <span class="co"># Train in a loop</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb19-27"><a href="#cb19-27"></a>        <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb19-28"><a href="#cb19-28"></a>        dense1.forward(X)</span>
<span id="cb19-29"><a href="#cb19-29"></a></span>
<span id="cb19-30"><a href="#cb19-30"></a>        <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb19-31"><a href="#cb19-31"></a>        <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb19-32"><a href="#cb19-32"></a>        activation1.forward(dense1.output)</span>
<span id="cb19-33"><a href="#cb19-33"></a></span>
<span id="cb19-34"><a href="#cb19-34"></a>        <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb19-35"><a href="#cb19-35"></a>        <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb19-36"><a href="#cb19-36"></a>        dense2.forward(activation1.output)</span>
<span id="cb19-37"><a href="#cb19-37"></a></span>
<span id="cb19-38"><a href="#cb19-38"></a>        <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb19-39"><a href="#cb19-39"></a>        <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb19-40"><a href="#cb19-40"></a>        loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb19-41"><a href="#cb19-41"></a></span>
<span id="cb19-42"><a href="#cb19-42"></a>        <span class="co"># Calculate accuracy from output of activation2 and targets</span></span>
<span id="cb19-43"><a href="#cb19-43"></a>        <span class="co"># Calculate values along the first axis</span></span>
<span id="cb19-44"><a href="#cb19-44"></a>        predictions <span class="op">=</span> np.argmax(loss_activation.output, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-45"><a href="#cb19-45"></a>        <span class="cf">if</span> <span class="bu">len</span>(y.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb19-46"><a href="#cb19-46"></a>            y <span class="op">=</span> np.argmax(y, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-47"><a href="#cb19-47"></a></span>
<span id="cb19-48"><a href="#cb19-48"></a>        accuracy <span class="op">=</span> np.mean(predictions <span class="op">==</span> y)</span>
<span id="cb19-49"><a href="#cb19-49"></a></span>
<span id="cb19-50"><a href="#cb19-50"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-51"><a href="#cb19-51"></a>            <span class="bu">print</span>(</span>
<span id="cb19-52"><a href="#cb19-52"></a>                <span class="ss">f"epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb19-53"><a href="#cb19-53"></a><span class="ss">                acc : </span><span class="sc">{</span>accuracy<span class="sc">:.3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb19-54"><a href="#cb19-54"></a><span class="ss">                loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb19-55"><a href="#cb19-55"></a><span class="ss">                lr : </span><span class="sc">{</span>optimizer<span class="sc">.</span>current_learning_rate<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb19-56"><a href="#cb19-56"></a>            )</span>
<span id="cb19-57"><a href="#cb19-57"></a></span>
<span id="cb19-58"><a href="#cb19-58"></a>        acc_vals.append(accuracy)</span>
<span id="cb19-59"><a href="#cb19-59"></a>        loss_vals.append(loss)</span>
<span id="cb19-60"><a href="#cb19-60"></a>        lr_vals.append(optimizer.current_learning_rate)</span>
<span id="cb19-61"><a href="#cb19-61"></a></span>
<span id="cb19-62"><a href="#cb19-62"></a>        <span class="co"># Backward pass</span></span>
<span id="cb19-63"><a href="#cb19-63"></a>        loss_activation.backward(loss_activation.output, y)</span>
<span id="cb19-64"><a href="#cb19-64"></a>        dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb19-65"><a href="#cb19-65"></a>        activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb19-66"><a href="#cb19-66"></a>        dense1.backward(activation1.dloss_dz)</span>
<span id="cb19-67"><a href="#cb19-67"></a></span>
<span id="cb19-68"><a href="#cb19-68"></a>        <span class="co"># Update the weights and the biases</span></span>
<span id="cb19-69"><a href="#cb19-69"></a>        optimizer.pre_update_params()</span>
<span id="cb19-70"><a href="#cb19-70"></a>        optimizer.update_params(dense1)</span>
<span id="cb19-71"><a href="#cb19-71"></a>        optimizer.update_params(dense2)</span>
<span id="cb19-72"><a href="#cb19-72"></a>        optimizer.post_update_params()</span>
<span id="cb19-73"><a href="#cb19-73"></a></span>
<span id="cb19-74"><a href="#cb19-74"></a>    <span class="cf">return</span> acc_vals, loss_vals, lr_vals</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">0.01</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch: 0,                 acc : 0.333,                 loss:  1.099,                 lr : 1.0
epoch: 1000,                 acc : 0.477,                 loss:  1.066,                 lr : 0.09099181073703366
epoch: 2000,                 acc : 0.457,                 loss:  1.065,                 lr : 0.047641734159123386
epoch: 3000,                 acc : 0.453,                 loss:  1.065,                 lr : 0.03226847370119393
epoch: 4000,                 acc : 0.450,                 loss:  1.064,                 lr : 0.02439619419370578
epoch: 5000,                 acc : 0.440,                 loss:  1.064,                 lr : 0.019611688566385566
epoch: 6000,                 acc : 0.443,                 loss:  1.063,                 lr : 0.016396130513198885
epoch: 7000,                 acc : 0.447,                 loss:  1.063,                 lr : 0.014086491055078181
epoch: 8000,                 acc : 0.447,                 loss:  1.063,                 lr : 0.012347203358439314
epoch: 9000,                 acc : 0.447,                 loss:  1.062,                 lr : 0.010990218705352238
epoch: 10000,                 acc : 0.447,                 loss:  1.062,                 lr : 0.009901970492127933</code></pre>
</div>
</div>
<div class="cell" data-execution_count="17">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a>epochs <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10000</span>,<span class="dv">10001</span>)</span>
<span id="cb22-3"><a href="#cb22-3"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb22-5"><a href="#cb22-5"></a>plt.plot(epochs,acc_vals)</span>
<span id="cb22-6"><a href="#cb22-6"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-18-output-1.png" width="597" height="429"></p>
</div>
</div>
<div class="cell" data-execution_count="18">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb23-3"><a href="#cb23-3"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb23-4"><a href="#cb23-4"></a>plt.plot(epochs,loss_vals)</span>
<span id="cb23-5"><a href="#cb23-5"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-19-output-1.png" width="606" height="430"></p>
</div>
</div>
<div class="cell" data-execution_count="19">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb24-2"><a href="#cb24-2"></a>plt.ylabel(<span class="st">"Learning rate"</span>)</span>
<span id="cb24-3"><a href="#cb24-3"></a>plt.xlabel(<span class="st">"Epochs"</span>)</span>
<span id="cb24-4"><a href="#cb24-4"></a>plt.plot(epochs, lr_vals)</span>
<span id="cb24-5"><a href="#cb24-5"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-20-output-1.png" width="589" height="429"></p>
</div>
</div>
<p>The optimization algorithm appears to be stuck and the reason is because the learning rate decayed far too quickly and became too small, trapping the optimizer in some local minimum. We can, instead, try to decay a bit slower by making our decay a smaller number. For example, let’s go with <span class="math inline">\(10^{-3}\)</span>.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch: 0,                 acc : 0.327,                 loss:  1.099,                 lr : 1.0
epoch: 1000,                 acc : 0.410,                 loss:  1.066,                 lr : 0.5002501250625312
epoch: 2000,                 acc : 0.413,                 loss:  1.055,                 lr : 0.33344448149383127
epoch: 3000,                 acc : 0.457,                 loss:  1.014,                 lr : 0.25006251562890724
epoch: 4000,                 acc : 0.527,                 loss:  0.968,                 lr : 0.2000400080016003
epoch: 5000,                 acc : 0.547,                 loss:  0.935,                 lr : 0.16669444907484582
epoch: 6000,                 acc : 0.563,                 loss:  0.918,                 lr : 0.1428775539362766
epoch: 7000,                 acc : 0.573,                 loss:  0.900,                 lr : 0.12501562695336915
epoch: 8000,                 acc : 0.577,                 loss:  0.882,                 lr : 0.11112345816201799
epoch: 9000,                 acc : 0.590,                 loss:  0.860,                 lr : 0.1000100010001
epoch: 10000,                 acc : 0.603,                 loss:  0.845,                 lr : 0.09091735612328393</code></pre>
</div>
</div>
<div class="cell" data-execution_count="21">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb27-2"><a href="#cb27-2"></a>epochs <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10000</span>,<span class="dv">10001</span>)</span>
<span id="cb27-3"><a href="#cb27-3"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb27-4"><a href="#cb27-4"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb27-5"><a href="#cb27-5"></a>plt.plot(epochs,acc_vals)</span>
<span id="cb27-6"><a href="#cb27-6"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-22-output-1.png" width="597" height="429"></p>
</div>
</div>
<div class="cell" data-execution_count="22">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb28-2"><a href="#cb28-2"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb28-3"><a href="#cb28-3"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb28-4"><a href="#cb28-4"></a>plt.plot(epochs,loss_vals)</span>
<span id="cb28-5"><a href="#cb28-5"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-23-output-1.png" width="597" height="429"></p>
</div>
</div>
<div class="cell" data-execution_count="23">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb29-2"><a href="#cb29-2"></a>plt.ylabel(<span class="st">"Learning rate"</span>)</span>
<span id="cb29-3"><a href="#cb29-3"></a>plt.xlabel(<span class="st">"Epochs"</span>)</span>
<span id="cb29-4"><a href="#cb29-4"></a>plt.plot(epochs, lr_vals)</span>
<span id="cb29-5"><a href="#cb29-5"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-24-output-1.png" width="589" height="429"></p>
</div>
</div>
</section>
<section id="stochastic-gradient-descent-with-momentum" class="level2">
<h2 class="anchored" data-anchor-id="stochastic-gradient-descent-with-momentum">Stochastic Gradient Descent with Momentum</h2>
<p>Momentum proposes a small tweak to gradient descent. We give gradient descent a short-term memory. Let’s define the updated velocity <span class="math inline">\(z^{k+1}\)</span> to be weighted and controlled by the mass <span class="math inline">\(\beta\)</span>. When <span class="math inline">\(\beta\)</span> is high, we simply use the velocity from the last time, that is, we are entirely driven by momentum. When <span class="math inline">\(\beta=0\)</span>, the momentum is zero.</p>
<p><span class="math display">\[\begin{align*}
z^{(k+1)} &amp;= \beta z^{(k)} + \nabla f(w^{(k)})\\
w^{k+1} &amp;= w^k - \alpha z^{k+1}
\end{align*}\]</span></p>
<p><span class="math inline">\(z^{(k+1)}\)</span> is called the <em>velocity</em>. It accumulates the past gradients similar to how a heavy ball rolling down the error function landscape integrates over past forces. To see what’s happening in more detail, we can recursively write out:</p>
<p><span class="math display">\[\begin{align*}
z^{(k)} &amp;= \beta z^{k-1} + \nabla f(w^{(k-1)}) \\
&amp;= \beta(\beta z^{k-2} + \nabla f(w^{(k-2)})) + \nabla f(w^{(k-1)})\\
&amp;= \beta^2 z^{k-2} + \beta \nabla f(w^{(k-2)}) + \nabla f(w^{(k-1)})\\
&amp;= \beta^2 (\beta z^{k-3} + \nabla f(w^{(k-3)}) ) + \beta \nabla f(w^{(k-2)}) + \nabla f(w^{(k-1)})\\
&amp;= \sum_{t=0}^{k} \beta^t \nabla f(w^{(k-1-t)})
\end{align*}\]</span></p>
<p>The new gradient replacement no longer points into the direction of steepest descent on a particular instance any longer but rather in the direction of an exponentially weighted average of past gradients.</p>
<section id="the-dynamics-of-momentum" class="level3">
<h3 class="anchored" data-anchor-id="the-dynamics-of-momentum">The dynamics of Momentum</h3>
<p>Since <span class="math inline">\(\nabla f(w^k) = Aw^k - b\)</span>, the update on the quadratic is:</p>
<p><span class="math display">\[\begin{align*}
z^{k+1} &amp;= \beta z^k + (Aw^k - b)\\
w^{k+1} &amp;= w^k - \alpha z^{k+1}
\end{align*}\]</span></p>
<p>We go through the same motions as before with the change of basis <span class="math inline">\((w^k - w^{*})=Qx^k\)</span> and <span class="math inline">\(z^k = Q y^k\)</span> to yield the update rule:</p>
<p><span class="math display">\[\begin{align*}
Q y^{k+1} &amp;= \beta Q y^k + (AQx^k + Aw^* - b)\\
Q y^{k+1} &amp;= \beta Q y^k + (AQx^k + AA^{-1}b - b)\\
Q y^{k+1} &amp;= \beta Q y^k + Q\Lambda Q^T Q x^k\\
Q y^{k+1} &amp;= \beta Q y^k + Q\Lambda x^k\\
y^{k+1} &amp;= \beta y^k + \Lambda x^k
\end{align*}\]</span></p>
<p>or equivalently:</p>
<p><span class="math display">\[\begin{align*}
y_i^{k+1} &amp;= \beta y_i^k + \lambda_i x_i^k
\end{align*}\]</span></p>
<p>Moreover,</p>
<p><span class="math display">\[\begin{align*}
Qx^{k+1} + w^* &amp;= Qx^k + w^* - \alpha Qy^{k+1}\\
x^{k+1} &amp;= x^k - \alpha y^{k+1}
\end{align*}\]</span></p>
<p>or equivalently:</p>
<p><span class="math display">\[\begin{align*}
x_i^{k+1} &amp;= x_i^k - \alpha y_i^{k+1}
\end{align*}\]</span></p>
<p>This lets us rewrite our iterates as:</p>
<p><span class="math display">\[\begin{align*}
\begin{bmatrix}
y_i^{k+1}\\
x_i^{k+1}
\end{bmatrix} &amp;=
\begin{bmatrix}
\beta y_i^k + \lambda_i x_i^k\\
(1-\alpha\lambda_i)x_i^k - \alpha \beta y_i^k
\end{bmatrix}\\
&amp;=\begin{bmatrix}
\beta &amp; \lambda_i\\
- \alpha \beta &amp; (1-\alpha\lambda_i)
\end{bmatrix}
\begin{bmatrix}
y_i^k\\
x_i^k
\end{bmatrix}
\end{align*}\]</span></p>
<p>Consequently,</p>
<p><span class="math display">\[\begin{align*}
\begin{bmatrix}
y_i^k\\
x_i^k
\end{bmatrix} = R^k \begin{bmatrix}
y_i^0\\
x_i^0
\end{bmatrix},\quad
R = \begin{bmatrix}
\beta &amp; \lambda_i\\
- \alpha \beta &amp; (1-\alpha\lambda_i)
\end{bmatrix}
\end{align*}\]</span></p>
<p>In the case of <span class="math inline">\(2 \times 2\)</span> matrix, there is an elegant little known formula in terms of the eigenvalues of the matrix <span class="math inline">\(R\)</span>, <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span>:</p>
<p><span class="math display">\[\begin{align*}
R^k = \begin{cases}
\sigma_1^k R_1 - \sigma_2^k R_2 &amp; \sigma_1 \neq \sigma_2,\\
\sigma_1^k(kR\sigma_1-(k-1)I) &amp; \sigma_1 = \sigma_2
\end{cases}
\quad
R_j = \frac{R-\sigma_j I}{\sigma_1 - \sigma_2}
\end{align*}\]</span></p>
<p>The formula is rather complicated, but the takeway here is that it plays the exact same role the individual convergence rates <span class="math inline">\((1-\alpha \lambda_i)\)</span> do in gradient descent. The convergence rate is therefore the slowest of the two rates, <span class="math inline">\(\max \{|\sigma_1|,|\sigma_2|\}\)</span>.</p>
<p>For what values of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> does momentum converge? Since we need both <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span> to converge, our convergence criterion is now <span class="math inline">\(\max \{|\sigma_1|,|\sigma_2|\} &lt; 1\)</span>.</p>
<p>It can be shown that when we choose an optimal value of the parameters <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>, the convergence rate is proportional to:</p>
<p><span class="math display">\[\begin{align*}
\frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1}
\end{align*}\]</span></p>
<p>With barely a modicum of extra effort, we have square-rooted the condition number.</p>
</section>
</section>
<section id="adding-momentum-to-the-sgdoptimizer-class" class="level2">
<h2 class="anchored" data-anchor-id="adding-momentum-to-the-sgdoptimizer-class">Adding momentum to the <code>SGDOptimizer</code> class</h2>
<p>We are now in a position to add momentum to the <code>SGDOptimizer</code> class.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb30-2"><a href="#cb30-2"></a></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>, momentum<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb30-6"><a href="#cb30-6"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb30-7"><a href="#cb30-7"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb30-8"><a href="#cb30-8"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb30-9"><a href="#cb30-9"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>        <span class="va">self</span>.beta <span class="op">=</span> momentum</span>
<span id="cb30-11"><a href="#cb30-11"></a></span>
<span id="cb30-12"><a href="#cb30-12"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb30-13"><a href="#cb30-13"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb30-14"><a href="#cb30-14"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb30-15"><a href="#cb30-15"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb30-16"><a href="#cb30-16"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb30-17"><a href="#cb30-17"></a>            )</span>
<span id="cb30-18"><a href="#cb30-18"></a></span>
<span id="cb30-19"><a href="#cb30-19"></a>    <span class="co"># Update parameters</span></span>
<span id="cb30-20"><a href="#cb30-20"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb30-21"><a href="#cb30-21"></a></span>
<span id="cb30-22"><a href="#cb30-22"></a>        <span class="co"># If we use momentum</span></span>
<span id="cb30-23"><a href="#cb30-23"></a>        <span class="cf">if</span> <span class="va">self</span>.beta:</span>
<span id="cb30-24"><a href="#cb30-24"></a></span>
<span id="cb30-25"><a href="#cb30-25"></a>            <span class="co"># If the layer does not contain momentum arrays, create them</span></span>
<span id="cb30-26"><a href="#cb30-26"></a>            <span class="co"># filled with zeros</span></span>
<span id="cb30-27"><a href="#cb30-27"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(layer, <span class="st">"weight_momentums"</span>):</span>
<span id="cb30-28"><a href="#cb30-28"></a>                layer.weight_momentums <span class="op">=</span> np.zeros_like(layer.dloss_dweights)</span>
<span id="cb30-29"><a href="#cb30-29"></a>                <span class="co"># If there is no momentumm array for weights</span></span>
<span id="cb30-30"><a href="#cb30-30"></a>                <span class="co"># the array doesnt exist for biases yet either</span></span>
<span id="cb30-31"><a href="#cb30-31"></a>                layer.bias_momentums <span class="op">=</span> np.zeros_like(layer.dloss_dbiases)</span>
<span id="cb30-32"><a href="#cb30-32"></a></span>
<span id="cb30-33"><a href="#cb30-33"></a>            <span class="co"># Build weight updates with momentum - take previous</span></span>
<span id="cb30-34"><a href="#cb30-34"></a>            <span class="co"># updates multiplied by retain factor and update with</span></span>
<span id="cb30-35"><a href="#cb30-35"></a>            <span class="co"># with current gradients</span></span>
<span id="cb30-36"><a href="#cb30-36"></a>            <span class="co"># v[t+1] = \beta * v[t] + \alpha * dL/dw</span></span>
<span id="cb30-37"><a href="#cb30-37"></a>            weight_updates <span class="op">=</span> (</span>
<span id="cb30-38"><a href="#cb30-38"></a>                <span class="va">self</span>.beta <span class="op">*</span> layer.weight_momentums</span>
<span id="cb30-39"><a href="#cb30-39"></a>                <span class="op">+</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb30-40"><a href="#cb30-40"></a>            )</span>
<span id="cb30-41"><a href="#cb30-41"></a>            layer.weight_momentums <span class="op">=</span> weight_updates</span>
<span id="cb30-42"><a href="#cb30-42"></a></span>
<span id="cb30-43"><a href="#cb30-43"></a>            <span class="co"># Build bias updates</span></span>
<span id="cb30-44"><a href="#cb30-44"></a>            bias_updates <span class="op">=</span> (</span>
<span id="cb30-45"><a href="#cb30-45"></a>                <span class="va">self</span>.beta <span class="op">*</span> layer.bias_momentums</span>
<span id="cb30-46"><a href="#cb30-46"></a>                <span class="op">+</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb30-47"><a href="#cb30-47"></a>            )</span>
<span id="cb30-48"><a href="#cb30-48"></a>            layer.bias_momentums <span class="op">=</span> bias_updates</span>
<span id="cb30-49"><a href="#cb30-49"></a>        <span class="cf">else</span>:</span>
<span id="cb30-50"><a href="#cb30-50"></a>            <span class="co"># Vanilla SGD updates (as before momentum update)</span></span>
<span id="cb30-51"><a href="#cb30-51"></a>            weight_updates <span class="op">=</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb30-52"><a href="#cb30-52"></a>            bias_updates <span class="op">=</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb30-53"><a href="#cb30-53"></a></span>
<span id="cb30-54"><a href="#cb30-54"></a>        layer.weights <span class="op">-=</span> weight_updates</span>
<span id="cb30-55"><a href="#cb30-55"></a>        layer.biases <span class="op">-=</span> bias_updates</span>
<span id="cb30-56"><a href="#cb30-56"></a></span>
<span id="cb30-57"><a href="#cb30-57"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb30-58"><a href="#cb30-58"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see an example illustrating how adding momentum changes the learning process. Keeping the same <code>learning_rate=1.0</code> and <code>decay=1e-3</code> from the previous training attempt and using a momentum of <code>0.50</code>:</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">def</span> train(decay, momentum):</span>
<span id="cb31-2"><a href="#cb31-2"></a>    <span class="co"># Create a dataset</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb31-4"><a href="#cb31-4"></a></span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>    dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a>    <span class="co"># Create ReLU activation (to be used with the dense layer)</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="co"># Create second DenseLayer with 64 input features (as we take output of the</span></span>
<span id="cb31-12"><a href="#cb31-12"></a>    <span class="co"># previous layer here) and 3 output values</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>    dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb31-14"><a href="#cb31-14"></a></span>
<span id="cb31-15"><a href="#cb31-15"></a>    <span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb31-16"><a href="#cb31-16"></a>    loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb31-17"><a href="#cb31-17"></a></span>
<span id="cb31-18"><a href="#cb31-18"></a>    <span class="co"># Create optimizer</span></span>
<span id="cb31-19"><a href="#cb31-19"></a>    optimizer <span class="op">=</span> SGDOptimizer(learning_rate<span class="op">=</span><span class="fl">1.0</span>,decay<span class="op">=</span>decay,momentum<span class="op">=</span>momentum)</span>
<span id="cb31-20"><a href="#cb31-20"></a></span>
<span id="cb31-21"><a href="#cb31-21"></a>    acc_vals <span class="op">=</span> []</span>
<span id="cb31-22"><a href="#cb31-22"></a>    loss_vals <span class="op">=</span> []</span>
<span id="cb31-23"><a href="#cb31-23"></a>    lr_vals <span class="op">=</span> []</span>
<span id="cb31-24"><a href="#cb31-24"></a></span>
<span id="cb31-25"><a href="#cb31-25"></a>    <span class="co"># Train in a loop</span></span>
<span id="cb31-26"><a href="#cb31-26"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb31-27"><a href="#cb31-27"></a>        <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb31-28"><a href="#cb31-28"></a>        dense1.forward(X)</span>
<span id="cb31-29"><a href="#cb31-29"></a></span>
<span id="cb31-30"><a href="#cb31-30"></a>        <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb31-31"><a href="#cb31-31"></a>        <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb31-32"><a href="#cb31-32"></a>        activation1.forward(dense1.output)</span>
<span id="cb31-33"><a href="#cb31-33"></a></span>
<span id="cb31-34"><a href="#cb31-34"></a>        <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb31-35"><a href="#cb31-35"></a>        <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb31-36"><a href="#cb31-36"></a>        dense2.forward(activation1.output)</span>
<span id="cb31-37"><a href="#cb31-37"></a></span>
<span id="cb31-38"><a href="#cb31-38"></a>        <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb31-39"><a href="#cb31-39"></a>        <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb31-40"><a href="#cb31-40"></a>        loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb31-41"><a href="#cb31-41"></a></span>
<span id="cb31-42"><a href="#cb31-42"></a>        <span class="co"># Calculate accuracy from output of activation2 and targets</span></span>
<span id="cb31-43"><a href="#cb31-43"></a>        <span class="co"># Calculate values along the first axis</span></span>
<span id="cb31-44"><a href="#cb31-44"></a>        predictions <span class="op">=</span> np.argmax(loss_activation.output, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-45"><a href="#cb31-45"></a>        <span class="cf">if</span> <span class="bu">len</span>(y.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb31-46"><a href="#cb31-46"></a>            y <span class="op">=</span> np.argmax(y, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-47"><a href="#cb31-47"></a></span>
<span id="cb31-48"><a href="#cb31-48"></a>        accuracy <span class="op">=</span> np.mean(predictions <span class="op">==</span> y)</span>
<span id="cb31-49"><a href="#cb31-49"></a></span>
<span id="cb31-50"><a href="#cb31-50"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb31-51"><a href="#cb31-51"></a>            <span class="bu">print</span>(</span>
<span id="cb31-52"><a href="#cb31-52"></a>                <span class="ss">f"epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb31-53"><a href="#cb31-53"></a><span class="ss">                acc : </span><span class="sc">{</span>accuracy<span class="sc">:.3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb31-54"><a href="#cb31-54"></a><span class="ss">                loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb31-55"><a href="#cb31-55"></a><span class="ss">                lr : </span><span class="sc">{</span>optimizer<span class="sc">.</span>current_learning_rate<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb31-56"><a href="#cb31-56"></a>            )</span>
<span id="cb31-57"><a href="#cb31-57"></a></span>
<span id="cb31-58"><a href="#cb31-58"></a>        acc_vals.append(accuracy)</span>
<span id="cb31-59"><a href="#cb31-59"></a>        loss_vals.append(loss)</span>
<span id="cb31-60"><a href="#cb31-60"></a>        lr_vals.append(optimizer.current_learning_rate)</span>
<span id="cb31-61"><a href="#cb31-61"></a></span>
<span id="cb31-62"><a href="#cb31-62"></a>        <span class="co"># Backward pass</span></span>
<span id="cb31-63"><a href="#cb31-63"></a>        loss_activation.backward(loss_activation.output, y)</span>
<span id="cb31-64"><a href="#cb31-64"></a>        dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb31-65"><a href="#cb31-65"></a>        activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb31-66"><a href="#cb31-66"></a>        dense1.backward(activation1.dloss_dz)</span>
<span id="cb31-67"><a href="#cb31-67"></a></span>
<span id="cb31-68"><a href="#cb31-68"></a>        <span class="co"># Update the weights and the biases</span></span>
<span id="cb31-69"><a href="#cb31-69"></a>        optimizer.pre_update_params()</span>
<span id="cb31-70"><a href="#cb31-70"></a>        optimizer.update_params(dense1)</span>
<span id="cb31-71"><a href="#cb31-71"></a>        optimizer.update_params(dense2)</span>
<span id="cb31-72"><a href="#cb31-72"></a>        optimizer.post_update_params()</span>
<span id="cb31-73"><a href="#cb31-73"></a></span>
<span id="cb31-74"><a href="#cb31-74"></a>    <span class="cf">return</span> acc_vals, loss_vals, lr_vals</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch: 0,                 acc : 0.337,                 loss:  1.099,                 lr : 1.0
epoch: 1000,                 acc : 0.510,                 loss:  0.978,                 lr : 0.5002501250625312
epoch: 2000,                 acc : 0.557,                 loss:  0.879,                 lr : 0.33344448149383127
epoch: 3000,                 acc : 0.580,                 loss:  0.771,                 lr : 0.25006251562890724
epoch: 4000,                 acc : 0.630,                 loss:  0.735,                 lr : 0.2000400080016003
epoch: 5000,                 acc : 0.657,                 loss:  0.670,                 lr : 0.16669444907484582
epoch: 6000,                 acc : 0.753,                 loss:  0.573,                 lr : 0.1428775539362766
epoch: 7000,                 acc : 0.783,                 loss:  0.522,                 lr : 0.12501562695336915
epoch: 8000,                 acc : 0.790,                 loss:  0.481,                 lr : 0.11112345816201799
epoch: 9000,                 acc : 0.807,                 loss:  0.441,                 lr : 0.1000100010001
epoch: 10000,                 acc : 0.843,                 loss:  0.401,                 lr : 0.09091735612328393</code></pre>
</div>
</div>
<p>The model achieved the lowest loss and the highest accuracy that we’ve seen so far. Can we do better? Sure, we can! Let’s try to set the momentum to <span class="math inline">\(0.9\)</span>:</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>epoch: 0,                 acc : 0.340,                 loss:  1.099,                 lr : 1.0
epoch: 1000,                 acc : 0.763,                 loss:  0.463,                 lr : 0.5002501250625312
epoch: 2000,                 acc : 0.790,                 loss:  0.407,                 lr : 0.33344448149383127
epoch: 3000,                 acc : 0.803,                 loss:  0.396,                 lr : 0.25006251562890724
epoch: 4000,                 acc : 0.813,                 loss:  0.391,                 lr : 0.2000400080016003
epoch: 5000,                 acc : 0.813,                 loss:  0.386,                 lr : 0.16669444907484582
epoch: 6000,                 acc : 0.813,                 loss:  0.384,                 lr : 0.1428775539362766
epoch: 7000,                 acc : 0.813,                 loss:  0.375,                 lr : 0.12501562695336915
epoch: 8000,                 acc : 0.833,                 loss:  0.332,                 lr : 0.11112345816201799
epoch: 9000,                 acc : 0.880,                 loss:  0.285,                 lr : 0.1000100010001
epoch: 10000,                 acc : 0.880,                 loss:  0.277,                 lr : 0.09091735612328393</code></pre>
</div>
</div>
</section>
<section id="adagrad" class="level2">
<h2 class="anchored" data-anchor-id="adagrad">AdaGrad</h2>
<p>In real-world datasets, some input features are sparse and some features are dense. If we use the same learning rate <span class="math inline">\(\alpha\)</span> for all the weights, parameters associated with sparse features receive meaningful updates only when these features occur. Given a decreasing learning rate, we might end up with a situation where parameters for dense features converge rather quickly to their optimal values, whereas for sparse features, we are still short of observing them sufficiently frequently before their optimal values can be determined. In other words, the learning rate decreases too slowly for dense features and too quickly for sparse features.</p>
<p>The update rule for adaptive step-size gradient descent is:</p>
<p><span class="math display">\[\begin{align*}
\mathbf{g}_t &amp;= \frac{\partial \mathcal L}{\partial \mathbf{w}}\\
\mathbf{s}_t &amp;= \mathbf{s}_{t-1} + \mathbf{g}_{t}^2 \\
\mathbf{w}_t &amp;= \mathbf{w}_{t-1} + \frac{\alpha}{\sqrt{\mathbf{s}_t+\epsilon}}\cdot \mathbf{g}_t
\end{align*}\]</span></p>
<p>Here the operations are applied coordinate-wise. So, the jacobian <span class="math inline">\(\mathbf{g}_t^2\)</span> has entries <span class="math inline">\(g_t^2\)</span>. As before, <span class="math inline">\(\alpha\)</span> is the learning rate and <span class="math inline">\(\epsilon\)</span> is an additive constant that ensures that we do not divide by <span class="math inline">\(0\)</span>. Thus, the learning rate for features whose weights receive frequent updates is decreased faster, whilst for those features, whose weights receive infrequent updates, it is decreased slower.</p>
<p>Thus, Adagrad decreases the learning-rate dynamically on a per-coordinate basis.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">class</span> AdagradOptimizer:</span>
<span id="cb36-2"><a href="#cb36-2"></a></span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>, epsilon<span class="op">=</span><span class="fl">1e-7</span>):</span>
<span id="cb36-6"><a href="#cb36-6"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb36-7"><a href="#cb36-7"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb36-8"><a href="#cb36-8"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb36-9"><a href="#cb36-9"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>        <span class="va">self</span>.epsilon <span class="op">=</span> epsilon</span>
<span id="cb36-11"><a href="#cb36-11"></a></span>
<span id="cb36-12"><a href="#cb36-12"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb36-14"><a href="#cb36-14"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb36-15"><a href="#cb36-15"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb36-16"><a href="#cb36-16"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb36-17"><a href="#cb36-17"></a>            )</span>
<span id="cb36-18"><a href="#cb36-18"></a></span>
<span id="cb36-19"><a href="#cb36-19"></a>    <span class="co"># Update parameters</span></span>
<span id="cb36-20"><a href="#cb36-20"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb36-21"><a href="#cb36-21"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(layer, <span class="st">"weight_cache"</span>):</span>
<span id="cb36-22"><a href="#cb36-22"></a>            layer.weight_cache <span class="op">=</span> np.zeros_like(layer.weights)</span>
<span id="cb36-23"><a href="#cb36-23"></a>            layer.bias_cache <span class="op">=</span> np.zeros_like(layer.biases)</span>
<span id="cb36-24"><a href="#cb36-24"></a></span>
<span id="cb36-25"><a href="#cb36-25"></a>        <span class="co"># Update cache with squared current gradients</span></span>
<span id="cb36-26"><a href="#cb36-26"></a>        layer.weight_cache <span class="op">+=</span> layer.dloss_dweights<span class="op">**</span><span class="dv">2</span></span>
<span id="cb36-27"><a href="#cb36-27"></a>        layer.bias_cache <span class="op">+=</span> layer.dloss_dbiases<span class="op">**</span><span class="dv">2</span></span>
<span id="cb36-28"><a href="#cb36-28"></a></span>
<span id="cb36-29"><a href="#cb36-29"></a>        <span class="co"># Vanilla SGD parameter update + normalization</span></span>
<span id="cb36-30"><a href="#cb36-30"></a>        <span class="co"># with square rooted cache</span></span>
<span id="cb36-31"><a href="#cb36-31"></a>        layer.weights <span class="op">+=</span> (</span>
<span id="cb36-32"><a href="#cb36-32"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb36-33"><a href="#cb36-33"></a>            <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb36-34"><a href="#cb36-34"></a>            <span class="op">/</span> (np.sqrt(layer.weight_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb36-35"><a href="#cb36-35"></a>        )</span>
<span id="cb36-36"><a href="#cb36-36"></a>        layer.biases <span class="op">+=</span> (</span>
<span id="cb36-37"><a href="#cb36-37"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb36-38"><a href="#cb36-38"></a>            <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb36-39"><a href="#cb36-39"></a>            <span class="op">/</span> (np.sqrt(layer.bias_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb36-40"><a href="#cb36-40"></a>        )</span>
<span id="cb36-41"><a href="#cb36-41"></a></span>
<span id="cb36-42"><a href="#cb36-42"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb36-43"><a href="#cb36-43"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="rmsprop" class="level2">
<h2 class="anchored" data-anchor-id="rmsprop">RMSProp</h2>
<p>One of the key issues of Adagrad is that the learning rate decreases at a predefined schedule essentially at a rate proportional <span class="math inline">\(\frac{1}{\sqrt{t}}\)</span>. While this is generally appropriate for convex problems, it might not be ideal for nonconvex ones, such as those encountered in deep learning. Yet, the coordinate-wise adaptivity of Adagrad is highly desirable as a preconditioner.</p>
<p>Tieleman and Hinton(<a href="https://www.d2l.ai/chapter_references/zreferences.html#id284">2012</a>) have proposed the RMSProp algorithm as a simple fix to decouple the rate scheduling from coordinate adaptive learning rates. The issue is that the squares of the gradient <span class="math inline">\(\mathbf{g}_t\)</span> keeps accumulating into the state vector <span class="math inline">\(\mathbf{s}_t = \mathbf{s}_{t-1} + \mathbf{g}_t^2\)</span>. As a result, <span class="math inline">\(\mathbf{s}_t\)</span> keeps on growing without bounds, essentially linearly as the algorithm converges.</p>
<section id="the-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-algorithm">The Algorithm</h3>
<p>The update rule for the RMSProp algorithm is as follows:</p>
<p><span class="math display">\[\begin{align*}
\mathbf{s}_t &amp;= \gamma \mathbf{s}_{t-1} + (1- \gamma)\mathbf{g}_t^2\\
\mathbf{x}_t &amp;= \mathbf{x}_{t-1} - \frac{\alpha}{\sqrt{\mathbf{s}_t + \epsilon}}\odot \mathbf{g}_t
\end{align*}\]</span></p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb37" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb37-1"><a href="#cb37-1"></a><span class="co">---</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="an">title:</span><span class="co"> "Optimization Algorithms"</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="an">author:</span><span class="co"> "Quasar"</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="an">date:</span><span class="co"> "2024-06-10"</span></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="an">categories:</span><span class="co"> [Machine Learning]      </span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="an">image:</span><span class="co"> "image.jpg"</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb37-8"><a href="#cb37-8"></a><span class="an">toc-depth:</span><span class="co"> 3</span></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="co">---</span></span>
<span id="cb37-10"><a href="#cb37-10"></a></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="fu">## Gradient vector</span></span>
<span id="cb37-12"><a href="#cb37-12"></a></span>
<span id="cb37-13"><a href="#cb37-13"></a>*Definition*. Let $f:\mathbf{R}^n \to \mathbf{R}$ be a scalar-valued function. The gradient vector of $f$ is defined as:</span>
<span id="cb37-14"><a href="#cb37-14"></a></span>
<span id="cb37-15"><a href="#cb37-15"></a>\begin{align*}</span>
<span id="cb37-16"><a href="#cb37-16"></a>\nabla f(\mathbf{x}) = \left<span class="co">[</span><span class="ot">\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\ldots,\frac{\partial f}{\partial x_n}\right</span><span class="co">]</span> </span>
<span id="cb37-17"><a href="#cb37-17"></a>\end{align*}</span>
<span id="cb37-18"><a href="#cb37-18"></a></span>
<span id="cb37-19"><a href="#cb37-19"></a>The graph of the function $f:\mathbf{R}^n \to \mathbf{R}$ is the *hypersurface* in $\mathbf{R}^{n+1}$ given by the equation $x_{n+1}=f(x_1,\ldots,x_n)$. </span>
<span id="cb37-20"><a href="#cb37-20"></a></span>
<span id="cb37-21"><a href="#cb37-21"></a>*Definition*. $f$ is said to be *differentiable* at $\mathbf{a}$ if all the partial derivatives $f_{x_i}(\mathbf{a})$ exist and if the function $h(\mathbf{x})$ defined by:</span>
<span id="cb37-22"><a href="#cb37-22"></a></span>
<span id="cb37-23"><a href="#cb37-23"></a>\begin{align*}</span>
<span id="cb37-24"><a href="#cb37-24"></a>h(\mathbf{x}) = f(\mathbf{a}) + \nabla f(\mathbf{a})\cdot (\mathbf{x}-\mathbf{a}) </span>
<span id="cb37-25"><a href="#cb37-25"></a>\end{align*}</span>
<span id="cb37-26"><a href="#cb37-26"></a></span>
<span id="cb37-27"><a href="#cb37-27"></a>is a good linear approximation to $f$ near $a$, meaning that:</span>
<span id="cb37-28"><a href="#cb37-28"></a></span>
<span id="cb37-29"><a href="#cb37-29"></a>\begin{align*}</span>
<span id="cb37-30"><a href="#cb37-30"></a>L = \lim_{\mathbf{x} \to \mathbf{a}} \frac{f(\mathbf{x}) - h(\mathbf{x})}{||\mathbf{x} - \mathbf{a}||} = 0 </span>
<span id="cb37-31"><a href="#cb37-31"></a>\end{align*}</span>
<span id="cb37-32"><a href="#cb37-32"></a></span>
<span id="cb37-33"><a href="#cb37-33"></a>If $f$ is differentiable at $\mathbf{a},f(\mathbf{a})$, then the hypersurface determined by the graph has a *tangent hyperplane* at $(\mathbf{a},f(\mathbf{a}))$ given by the equation:</span>
<span id="cb37-34"><a href="#cb37-34"></a></span>
<span id="cb37-35"><a href="#cb37-35"></a>\begin{align*}</span>
<span id="cb37-36"><a href="#cb37-36"></a>h(\mathbf{x}) = f(\mathbf{a}) + \nabla f(\mathbf{a})\cdot (\mathbf{x}-\mathbf{a}) </span>
<span id="cb37-37"><a href="#cb37-37"></a>\end{align*}</span>
<span id="cb37-38"><a href="#cb37-38"></a></span>
<span id="cb37-39"><a href="#cb37-39"></a><span class="fu">### The directional derivative</span></span>
<span id="cb37-40"><a href="#cb37-40"></a></span>
<span id="cb37-41"><a href="#cb37-41"></a>Let $f(x,y)$ be a scalar-valued function of two variables. We understand the partial derivative $\frac{\partial f}{\partial x}(a,b)$ as the slope at the point $(a,b,f(a,b))$ of the curve obtained as the intersection of the surface $z=f(x,y)$ and the plane $y=b$. The other partial derivative has a geometric interpretation. However, the surface $z=f(x,y)$ contains infinitely many curves passing through $(a,b,f(a,b))$ whose slope we might choose to measure. The directional derivative enables us to do this.</span>
<span id="cb37-42"><a href="#cb37-42"></a></span>
<span id="cb37-43"><a href="#cb37-43"></a>Intuitively, $\frac{\partial f}{\partial x}(a,b)$ is as the rate of change of $f$ as we move *infinitesimally* from $\mathbf{a}=(a,b)$ in the $\mathbf{i}$ direction. </span>
<span id="cb37-44"><a href="#cb37-44"></a></span>
<span id="cb37-45"><a href="#cb37-45"></a>Mathematically, by the definition of the derivative of $f$:</span>
<span id="cb37-46"><a href="#cb37-46"></a></span>
<span id="cb37-47"><a href="#cb37-47"></a>\begin{align*}</span>
<span id="cb37-48"><a href="#cb37-48"></a>\frac{\partial f}{\partial x}(a,b) &amp;= \lim_{h \to 0} \frac{f(a+h,b) - f(a,b)}{h}<span class="sc">\\</span></span>
<span id="cb37-49"><a href="#cb37-49"></a>&amp;=\lim_{h \to 0} \frac{f((a,b) + (h,0)) - f(a,b)}{h}<span class="sc">\\</span></span>
<span id="cb37-50"><a href="#cb37-50"></a>&amp;=\lim_{h \to 0} \frac{f((a,b) + h(1,0)) - f(a,b)}{h}<span class="sc">\\</span></span>
<span id="cb37-51"><a href="#cb37-51"></a>&amp;=\lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{i}) - f(\mathbf{a})}{h}</span>
<span id="cb37-52"><a href="#cb37-52"></a>\end{align*}</span>
<span id="cb37-53"><a href="#cb37-53"></a></span>
<span id="cb37-54"><a href="#cb37-54"></a>Similarly, we have:</span>
<span id="cb37-55"><a href="#cb37-55"></a></span>
<span id="cb37-56"><a href="#cb37-56"></a>\begin{align*}</span>
<span id="cb37-57"><a href="#cb37-57"></a>\frac{\partial f}{\partial y}(a,b) = \lim_{h\to 0} \frac{f(\mathbf{a} + h\mathbf{j})-f(\mathbf{a})}{h} </span>
<span id="cb37-58"><a href="#cb37-58"></a>\end{align*}</span>
<span id="cb37-59"><a href="#cb37-59"></a></span>
<span id="cb37-60"><a href="#cb37-60"></a>Writing partial derivatives as we have enables us to see that they are special cases of a more general type of derivative. Suppose $\mathbf{v}$ is a unit vector in $\mathbf{R}^2$. The quantity:</span>
<span id="cb37-61"><a href="#cb37-61"></a></span>
<span id="cb37-62"><a href="#cb37-62"></a>\begin{align*}</span>
<span id="cb37-63"><a href="#cb37-63"></a>\lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{v}) - f(\mathbf{a})}{h}</span>
<span id="cb37-64"><a href="#cb37-64"></a>\end{align*}</span>
<span id="cb37-65"><a href="#cb37-65"></a></span>
<span id="cb37-66"><a href="#cb37-66"></a>is nothing more than the rate of change of $f$ as we move infinitesimally from $\mathbf{a} = (a,b)$ in the direction specified by $\mathbf{v}=(A,B) = A\mathbf{i} + B\mathbf{j}$. </span>
<span id="cb37-67"><a href="#cb37-67"></a></span>
<span id="cb37-68"><a href="#cb37-68"></a>*Definition*. Let $\mathbf{v}\in \mathbf{R}^n$ be any unit vector, then the *directional derivative* of $f$ at $\mathbf{a}$ in the direction of $\mathbf{v}$, denoted $D_{\mathbf{v}}f(\mathbf{a})$ is:</span>
<span id="cb37-69"><a href="#cb37-69"></a></span>
<span id="cb37-70"><a href="#cb37-70"></a>\begin{align*}</span>
<span id="cb37-71"><a href="#cb37-71"></a>D_{\mathbf{v}}f(\mathbf{a}) = \lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{v}) - f(\mathbf{a})}{h} </span>
<span id="cb37-72"><a href="#cb37-72"></a>\end{align*}</span>
<span id="cb37-73"><a href="#cb37-73"></a></span>
<span id="cb37-74"><a href="#cb37-74"></a>Let's define a new function $F$ of a single variable $t$, by holding everything else constant:</span>
<span id="cb37-75"><a href="#cb37-75"></a></span>
<span id="cb37-76"><a href="#cb37-76"></a>\begin{align*}</span>
<span id="cb37-77"><a href="#cb37-77"></a>F(t) = f(\mathbf{a} + t\mathbf{v}) </span>
<span id="cb37-78"><a href="#cb37-78"></a>\end{align*}</span>
<span id="cb37-79"><a href="#cb37-79"></a></span>
<span id="cb37-80"><a href="#cb37-80"></a>Then, by the definition of directional derivatives, we have:</span>
<span id="cb37-81"><a href="#cb37-81"></a></span>
<span id="cb37-82"><a href="#cb37-82"></a>\begin{align*}</span>
<span id="cb37-83"><a href="#cb37-83"></a>D_{\mathbf{v}}f(\mathbf{a}) &amp;= \lim_{t\to 0} \frac{f(\mathbf{a} + t\mathbf{v}) - f(\mathbf{a})}{t}<span class="sc">\\</span></span>
<span id="cb37-84"><a href="#cb37-84"></a>&amp;= \lim_{t\to 0} \frac{F(t) - F(0)}{t - 0} <span class="sc">\\</span></span>
<span id="cb37-85"><a href="#cb37-85"></a>&amp;= F'(0) </span>
<span id="cb37-86"><a href="#cb37-86"></a>\end{align*}</span>
<span id="cb37-87"><a href="#cb37-87"></a></span>
<span id="cb37-88"><a href="#cb37-88"></a>That is:</span>
<span id="cb37-89"><a href="#cb37-89"></a></span>
<span id="cb37-90"><a href="#cb37-90"></a>\begin{align*}</span>
<span id="cb37-91"><a href="#cb37-91"></a>D_{\mathbf{v}}f(\mathbf{a}) = \frac{d}{dt} f(\mathbf{a} + t\mathbf{v})\vert_{t=0} </span>
<span id="cb37-92"><a href="#cb37-92"></a>\end{align*}</span>
<span id="cb37-93"><a href="#cb37-93"></a></span>
<span id="cb37-94"><a href="#cb37-94"></a>Let $\mathbf{x}(t) = \mathbf{a}+t\mathbf{v}$. Then, by the chain rule:</span>
<span id="cb37-95"><a href="#cb37-95"></a></span>
<span id="cb37-96"><a href="#cb37-96"></a>\begin{align*}</span>
<span id="cb37-97"><a href="#cb37-97"></a>\frac{d}{dt} f(\mathbf{a} + t\mathbf{v}) &amp;= Df(\mathbf{x}) D\mathbf{x}(t) <span class="sc">\\</span></span>
<span id="cb37-98"><a href="#cb37-98"></a>&amp;= \nabla f(\mathbf{x}) \cdot \mathbf{v}</span>
<span id="cb37-99"><a href="#cb37-99"></a>\end{align*}</span>
<span id="cb37-100"><a href="#cb37-100"></a></span>
<span id="cb37-101"><a href="#cb37-101"></a>This equation emphasizes the geometry of the situation. The directional derivative is just the dot product of the gradient vector and the direction vector $\mathbf{v}$. </span>
<span id="cb37-102"><a href="#cb37-102"></a></span>
<span id="cb37-103"><a href="#cb37-103"></a>*Theorem.* Let $f:X\to\mathbf{R}$ be differentiable at $\mathbf{a}\in X$. Then, the directional derivative $D_{\mathbf{v}}f(\mathbf{a})$ exists for all directions $\mathbf{v}\in\mathbf{R}^n$ and moreover we have:</span>
<span id="cb37-104"><a href="#cb37-104"></a></span>
<span id="cb37-105"><a href="#cb37-105"></a>\begin{align*}</span>
<span id="cb37-106"><a href="#cb37-106"></a>D_{\mathbf{v}}f(\mathbf{a}) = \nabla f(\mathbf{x})\cdot \mathbf{v}</span>
<span id="cb37-107"><a href="#cb37-107"></a>\end{align*}</span>
<span id="cb37-108"><a href="#cb37-108"></a></span>
<span id="cb37-109"><a href="#cb37-109"></a><span class="fu">### Gradients and steepest ascent</span></span>
<span id="cb37-110"><a href="#cb37-110"></a></span>
<span id="cb37-111"><a href="#cb37-111"></a>Suppose you are traveling in space near the planet Nilrebo and that one of your spaceship's instruments measures the external atmospheric pressure on your ship as a function $f(x,y,z)$ of position. Assume quite reasonably that this function is differentiable. Then, the directional derivative exists and if you travel from point $\mathbf{a}=(a,b,c)$ in the direction of the unit vector $\mathbf{u}=u\mathbf{i}+v\mathbf{j}+w\mathbf{k}$, the rate of change of pressure is given by:</span>
<span id="cb37-112"><a href="#cb37-112"></a></span>
<span id="cb37-113"><a href="#cb37-113"></a>\begin{align*}</span>
<span id="cb37-114"><a href="#cb37-114"></a>D_{\mathbf{u}}f(\mathbf{a}) = \nabla f(\mathbf{a}) \cdot \mathbf{u} = ||\nabla f(\mathbf{a})|| \cdot ||\mathbf{u}|| \cos \theta </span>
<span id="cb37-115"><a href="#cb37-115"></a>\end{align*}</span>
<span id="cb37-116"><a href="#cb37-116"></a></span>
<span id="cb37-117"><a href="#cb37-117"></a>where $\theta$ is the angle between $\mathbf{u}$ and the gradient vector $\nabla f(\mathbf{a})$. Because, $-1 \leq \cos \theta \leq 1$, and $||\mathbf{u}||=1$, we have:</span>
<span id="cb37-118"><a href="#cb37-118"></a></span>
<span id="cb37-119"><a href="#cb37-119"></a>\begin{align*}</span>
<span id="cb37-120"><a href="#cb37-120"></a><span class="ss">- </span>||\nabla f(\mathbf{a})|| \leq D_{\mathbf{u}}f(\mathbf{a}) \leq ||\nabla f(\mathbf{a})||</span>
<span id="cb37-121"><a href="#cb37-121"></a>\end{align*}</span>
<span id="cb37-122"><a href="#cb37-122"></a></span>
<span id="cb37-123"><a href="#cb37-123"></a>Moreover, $\cos \theta = 1$ when $\theta = 0$ and $\cos \theta = -1$ when $\theta = \pi$.</span>
<span id="cb37-124"><a href="#cb37-124"></a></span>
<span id="cb37-125"><a href="#cb37-125"></a>*Theorem*. The directional derivative $D_{\mathbf{u}}f(\mathbf{a})$ is maximized, with respect to the direction, when $\mathbf{u}$ points in the direction of the gradient vector $f(\mathbf{a})$ and is minimized when $\mathbf{u}$ points in the opposite direction. Furthermore, the maximum and minimum values of $D_{\mathbf{u}}f(\mathbf{a})$ are $||\nabla f(\mathbf{a})||$ and $-||\nabla f(\mathbf{a})||$.</span>
<span id="cb37-126"><a href="#cb37-126"></a></span>
<span id="cb37-127"><a href="#cb37-127"></a>*Theorem* Let $f:X \subseteq \mathbf{R}^n \to \mathbf{R}$ be a function of class $C^1$. If $\mathbf{x}_0$ is a point on the level set $S=\{\mathbf{x} \in X | f(\mathbf{x}) = c\}$, then the gradient vector $\nabla f(\mathbf{x}_0) \in \mathbf{R}^n$ is perpendicular to $S$.</span>
<span id="cb37-128"><a href="#cb37-128"></a></span>
<span id="cb37-129"><a href="#cb37-129"></a>*Proof.* We need to establish the following: if $\mathbf{v}$ is any vector tangent to $S$ at $\mathbf{x}_0$, then $\nabla f(\mathbf{x}_0)$ is perpendicular to $\mathbf{v}$ (i.e. $\nabla f(\mathbf{x}_0) \cdot \mathbf{v} = 0$). By a tangent vector to $S$ at $\mathbf{x}_0$, we mean that $\mathbf{v}$ is the velocity vector of a curve $C$ that lies in $S$ and passes through $\mathbf{x}_0$.</span>
<span id="cb37-130"><a href="#cb37-130"></a></span>
<span id="cb37-131"><a href="#cb37-131"></a>Let $C$ be given parametrically by $\mathbf{x}(t)=(x_1(t),\ldots,x_n(t))$ where $a &lt; t &lt; b$ and $\mathbf{x}(t_0) = \mathbf{x}_0$ for some number $t_0$ in $(a,b)$. </span>
<span id="cb37-132"><a href="#cb37-132"></a></span>
<span id="cb37-133"><a href="#cb37-133"></a>\begin{align*}</span>
<span id="cb37-134"><a href="#cb37-134"></a>\frac{d}{dt}<span class="co">[</span><span class="ot">f(\mathbf{x}(t))</span><span class="co">]</span> &amp;= Df(\mathbf{x}) \cdot \mathbf{x}'(t)<span class="sc">\\</span></span>
<span id="cb37-135"><a href="#cb37-135"></a>&amp;= \nabla f(\mathbf{x}) \cdot \mathbf{v} </span>
<span id="cb37-136"><a href="#cb37-136"></a>\end{align*}</span>
<span id="cb37-137"><a href="#cb37-137"></a></span>
<span id="cb37-138"><a href="#cb37-138"></a>Evaluation at $t = t_0$, yields:</span>
<span id="cb37-139"><a href="#cb37-139"></a></span>
<span id="cb37-140"><a href="#cb37-140"></a>\begin{align*}</span>
<span id="cb37-141"><a href="#cb37-141"></a>\nabla f (\mathbf{x}(t_0)) \cdot \mathbf{x}'(t_0) = \nabla f(\mathbf{x}_0) \cdot \mathbf{v} </span>
<span id="cb37-142"><a href="#cb37-142"></a>\end{align*}</span>
<span id="cb37-143"><a href="#cb37-143"></a></span>
<span id="cb37-144"><a href="#cb37-144"></a>On the other hand, since $C$ is contained in $S$, $f(\mathbf{x})=c$. So,</span>
<span id="cb37-145"><a href="#cb37-145"></a></span>
<span id="cb37-146"><a href="#cb37-146"></a>\begin{align*}</span>
<span id="cb37-147"><a href="#cb37-147"></a>\frac{d}{dt}<span class="co">[</span><span class="ot">f(\mathbf{x}(t))</span><span class="co">]</span> &amp;= \frac{d}{dt}<span class="co">[</span><span class="ot">c</span><span class="co">]</span> = 0 </span>
<span id="cb37-148"><a href="#cb37-148"></a>\end{align*}</span>
<span id="cb37-149"><a href="#cb37-149"></a></span>
<span id="cb37-150"><a href="#cb37-150"></a>Putting the above two facts together, we have the desired result. </span>
<span id="cb37-151"><a href="#cb37-151"></a></span>
<span id="cb37-152"><a href="#cb37-152"></a><span class="fu">## Gradient Descent - Naive Implementation</span></span>
<span id="cb37-153"><a href="#cb37-153"></a></span>
<span id="cb37-154"><a href="#cb37-154"></a>Beginning at $\mathbf{x}_0$, optimization algorithms generate a sequence of iterates $\{\mathbf{x}_k\}_{k=0}^{\infty}$ that terminate when no more progress can be made or it seems a solution point has been approximated with sufficient accuracy. The *gradient descent method* is an optimization algorithm that moves along $\mathbf{d}_k = -\nabla f(\mathbf{x}_k)$ at every step. Thus,</span>
<span id="cb37-155"><a href="#cb37-155"></a></span>
<span id="cb37-156"><a href="#cb37-156"></a>\begin{align*}</span>
<span id="cb37-157"><a href="#cb37-157"></a>\mathbf{x}_{k+1} = \mathbf{x}_k - \alpha_k \mathbf{d}_k</span>
<span id="cb37-158"><a href="#cb37-158"></a>\end{align*}</span>
<span id="cb37-159"><a href="#cb37-159"></a></span>
<span id="cb37-160"><a href="#cb37-160"></a>It can choose the step length $\alpha_k$ in a variety of ways. One advantage of steepest descent is that it requires the calculation of the gradient $\nabla f(\mathbf{x}_k)$, but not of the second derivatives. However, it can be excruciatingly slow on difficult problems.</span>
<span id="cb37-161"><a href="#cb37-161"></a></span>
<span id="cb37-164"><a href="#cb37-164"></a><span class="in">```{python}</span></span>
<span id="cb37-165"><a href="#cb37-165"></a><span class="op">%</span>load_ext itikz</span>
<span id="cb37-166"><a href="#cb37-166"></a><span class="in">```</span></span>
<span id="cb37-167"><a href="#cb37-167"></a></span>
<span id="cb37-170"><a href="#cb37-170"></a><span class="in">```{python}</span></span>
<span id="cb37-171"><a href="#cb37-171"></a><span class="im">from</span> typing <span class="im">import</span> Callable</span>
<span id="cb37-172"><a href="#cb37-172"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-173"><a href="#cb37-173"></a></span>
<span id="cb37-174"><a href="#cb37-174"></a></span>
<span id="cb37-175"><a href="#cb37-175"></a><span class="kw">def</span> gradient_descent(</span>
<span id="cb37-176"><a href="#cb37-176"></a>    func: Callable[[<span class="bu">float</span>], <span class="bu">float</span>],</span>
<span id="cb37-177"><a href="#cb37-177"></a>    alpha: <span class="bu">float</span>,</span>
<span id="cb37-178"><a href="#cb37-178"></a>    xval_0: np.array,</span>
<span id="cb37-179"><a href="#cb37-179"></a>    epsilon: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-5</span>,</span>
<span id="cb37-180"><a href="#cb37-180"></a>    n_iter: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10000</span>,</span>
<span id="cb37-181"><a href="#cb37-181"></a>    debug_step: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>,</span>
<span id="cb37-182"><a href="#cb37-182"></a>):</span>
<span id="cb37-183"><a href="#cb37-183"></a>    <span class="co">"""</span></span>
<span id="cb37-184"><a href="#cb37-184"></a><span class="co">    The gradient descent algorithm.</span></span>
<span id="cb37-185"><a href="#cb37-185"></a><span class="co">    """</span></span>
<span id="cb37-186"><a href="#cb37-186"></a></span>
<span id="cb37-187"><a href="#cb37-187"></a>    xval_hist <span class="op">=</span> []</span>
<span id="cb37-188"><a href="#cb37-188"></a>    funcval_hist <span class="op">=</span> []</span>
<span id="cb37-189"><a href="#cb37-189"></a></span>
<span id="cb37-190"><a href="#cb37-190"></a>    xval_curr <span class="op">=</span> xval_0</span>
<span id="cb37-191"><a href="#cb37-191"></a>    error <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb37-192"><a href="#cb37-192"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-193"><a href="#cb37-193"></a></span>
<span id="cb37-194"><a href="#cb37-194"></a>    <span class="cf">while</span> np.linalg.norm(error) <span class="op">&gt;</span> epsilon <span class="kw">and</span> i <span class="op">&lt;</span> n_iter:</span>
<span id="cb37-195"><a href="#cb37-195"></a>        <span class="co"># Save down x_curr and func(x_curr)</span></span>
<span id="cb37-196"><a href="#cb37-196"></a>        xval_hist.append(xval_curr)</span>
<span id="cb37-197"><a href="#cb37-197"></a>        funcval_hist.append(func(xval_curr))</span>
<span id="cb37-198"><a href="#cb37-198"></a></span>
<span id="cb37-199"><a href="#cb37-199"></a>        <span class="co"># Calculate the forward difference</span></span>
<span id="cb37-200"><a href="#cb37-200"></a>        bump <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb37-201"><a href="#cb37-201"></a>        num_dims <span class="op">=</span> <span class="bu">len</span>(xval_curr)</span>
<span id="cb37-202"><a href="#cb37-202"></a>        xval_bump <span class="op">=</span> xval_curr <span class="op">+</span> np.eye(num_dims) <span class="op">*</span> bump</span>
<span id="cb37-203"><a href="#cb37-203"></a>        xval_nobump <span class="op">=</span> np.full((num_dims, num_dims), xval_curr)</span>
<span id="cb37-204"><a href="#cb37-204"></a></span>
<span id="cb37-205"><a href="#cb37-205"></a>        grad <span class="op">=</span> np.array(</span>
<span id="cb37-206"><a href="#cb37-206"></a>            [</span>
<span id="cb37-207"><a href="#cb37-207"></a>                (func(xval_h) <span class="op">-</span> func(xval)) <span class="op">/</span> bump</span>
<span id="cb37-208"><a href="#cb37-208"></a>                <span class="cf">for</span> xval_h, xval <span class="kw">in</span> <span class="bu">zip</span>(xval_bump, xval_nobump)</span>
<span id="cb37-209"><a href="#cb37-209"></a>            ]</span>
<span id="cb37-210"><a href="#cb37-210"></a>        )</span>
<span id="cb37-211"><a href="#cb37-211"></a></span>
<span id="cb37-212"><a href="#cb37-212"></a>        <span class="co"># Compute the next iterate</span></span>
<span id="cb37-213"><a href="#cb37-213"></a>        xval_next <span class="op">=</span> xval_curr <span class="op">-</span> alpha <span class="op">*</span> grad</span>
<span id="cb37-214"><a href="#cb37-214"></a></span>
<span id="cb37-215"><a href="#cb37-215"></a>        <span class="co"># Compute the error vector</span></span>
<span id="cb37-216"><a href="#cb37-216"></a>        error <span class="op">=</span> xval_next <span class="op">-</span> xval_curr</span>
<span id="cb37-217"><a href="#cb37-217"></a></span>
<span id="cb37-218"><a href="#cb37-218"></a>        <span class="cf">if</span> i <span class="op">%</span> debug_step <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb37-219"><a href="#cb37-219"></a>            <span class="bu">print</span>(</span>
<span id="cb37-220"><a href="#cb37-220"></a>                <span class="ss">f"x[</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">] = </span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">, f(</span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>func(xval_curr)<span class="sc">}</span><span class="ss">, f'(</span><span class="sc">{</span>xval_curr<span class="sc">}</span><span class="ss">) = </span><span class="sc">{</span>grad<span class="sc">}</span><span class="ss">, error=</span><span class="sc">{</span>error<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb37-221"><a href="#cb37-221"></a>            )</span>
<span id="cb37-222"><a href="#cb37-222"></a></span>
<span id="cb37-223"><a href="#cb37-223"></a>        xval_curr <span class="op">=</span> xval_next</span>
<span id="cb37-224"><a href="#cb37-224"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-225"><a href="#cb37-225"></a></span>
<span id="cb37-226"><a href="#cb37-226"></a>    <span class="cf">return</span> xval_hist, funcval_hist</span>
<span id="cb37-227"><a href="#cb37-227"></a><span class="in">```</span></span>
<span id="cb37-228"><a href="#cb37-228"></a></span>
<span id="cb37-229"><a href="#cb37-229"></a>One infamous test function is the *Rosenbrock function* defined as:</span>
<span id="cb37-230"><a href="#cb37-230"></a></span>
<span id="cb37-231"><a href="#cb37-231"></a>\begin{align*}</span>
<span id="cb37-232"><a href="#cb37-232"></a>f(x,y) = (a-x)^2 + b(y-x^2)^2</span>
<span id="cb37-233"><a href="#cb37-233"></a>\end{align*}</span>
<span id="cb37-234"><a href="#cb37-234"></a></span>
<span id="cb37-235"><a href="#cb37-235"></a></span>
<span id="cb37-238"><a href="#cb37-238"></a><span class="in">```{python}</span></span>
<span id="cb37-239"><a href="#cb37-239"></a><span class="kw">def</span> rosenbrock(x):</span>
<span id="cb37-240"><a href="#cb37-240"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span><span class="op">*</span>(x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-241"><a href="#cb37-241"></a></span>
<span id="cb37-242"><a href="#cb37-242"></a><span class="kw">def</span> f(x):</span>
<span id="cb37-243"><a href="#cb37-243"></a>    <span class="cf">return</span> x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-244"><a href="#cb37-244"></a><span class="in">```</span></span>
<span id="cb37-245"><a href="#cb37-245"></a></span>
<span id="cb37-246"><a href="#cb37-246"></a>Here is the plot of the Rosenbrock function with parameters $a=1,b=100$.</span>
<span id="cb37-247"><a href="#cb37-247"></a></span>
<span id="cb37-250"><a href="#cb37-250"></a><span class="in">```{python}</span></span>
<span id="cb37-251"><a href="#cb37-251"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-252"><a href="#cb37-252"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-253"><a href="#cb37-253"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb37-254"><a href="#cb37-254"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb37-255"><a href="#cb37-255"></a>\begin{axis}[</span>
<span id="cb37-256"><a href="#cb37-256"></a>     title<span class="op">=</span>{Plot of $f(x,y)<span class="op">=</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span>(y<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span>)<span class="op">^</span><span class="dv">2</span>$},</span>
<span id="cb37-257"><a href="#cb37-257"></a>]</span>
<span id="cb37-258"><a href="#cb37-258"></a>    \addplot3 [surf] {(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">100</span><span class="op">*</span>(y<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span>)<span class="op">^</span><span class="dv">2</span>}<span class="op">;</span></span>
<span id="cb37-259"><a href="#cb37-259"></a>\end{axis}</span>
<span id="cb37-260"><a href="#cb37-260"></a>\end{tikzpicture}</span>
<span id="cb37-261"><a href="#cb37-261"></a><span class="in">```</span></span>
<span id="cb37-262"><a href="#cb37-262"></a></span>
<span id="cb37-265"><a href="#cb37-265"></a><span class="in">```{python}</span></span>
<span id="cb37-266"><a href="#cb37-266"></a>x_history, f_x_history <span class="op">=</span> gradient_descent(</span>
<span id="cb37-267"><a href="#cb37-267"></a>    func<span class="op">=</span>rosenbrock,</span>
<span id="cb37-268"><a href="#cb37-268"></a>    alpha<span class="op">=</span><span class="fl">0.001</span>,</span>
<span id="cb37-269"><a href="#cb37-269"></a>    xval_0<span class="op">=</span>np.array([<span class="op">-</span><span class="fl">2.0</span>, <span class="fl">2.0</span>]),</span>
<span id="cb37-270"><a href="#cb37-270"></a>    epsilon<span class="op">=</span><span class="fl">1e-7</span>,</span>
<span id="cb37-271"><a href="#cb37-271"></a>    debug_step<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb37-272"><a href="#cb37-272"></a>)</span>
<span id="cb37-273"><a href="#cb37-273"></a></span>
<span id="cb37-274"><a href="#cb37-274"></a><span class="bu">print</span>(<span class="ss">f"x* = </span><span class="sc">{</span>x_history[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">, f(x*)=</span><span class="sc">{</span>f_x_history[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-275"><a href="#cb37-275"></a><span class="in">```</span></span>
<span id="cb37-276"><a href="#cb37-276"></a></span>
<span id="cb37-277"><a href="#cb37-277"></a><span class="fu">## Convergence.</span></span>
<span id="cb37-278"><a href="#cb37-278"></a></span>
<span id="cb37-279"><a href="#cb37-279"></a>When applying gradient descent in practice, we need to choose a value for the learning rate parameter $\alpha$. An error surface $E$ is usually a convex function on the weight space $\mathbf{w}$. Intuitively, we might expect that increasing the value of $\alpha$ should lead to bigger steps through the weight space and hence faster convergence. However, the successive steps oscillate back and forth across the valley, and if we increase $\alpha$ too much, these oscillations will become divergent. Because $\alpha$ must be kept sufficiently small to avoid divergent oscillations across the valley, progress along the valley is very slow. Gradient descent then takes many small steps to reach the minimum and is a very inefficient procedure. </span>
<span id="cb37-280"><a href="#cb37-280"></a></span>
<span id="cb37-281"><a href="#cb37-281"></a>We can gain deeper insight into this problem, by considering a quadratic approximation to the error function in the neighbourhood of the minimum. Let the error function be given by:</span>
<span id="cb37-282"><a href="#cb37-282"></a></span>
<span id="cb37-283"><a href="#cb37-283"></a>\begin{align*}</span>
<span id="cb37-284"><a href="#cb37-284"></a>f(w) = \frac{1}{2}w^T A w - b^T w, \quad w\in\mathbf{R}^n</span>
<span id="cb37-285"><a href="#cb37-285"></a>\end{align*}</span>
<span id="cb37-286"><a href="#cb37-286"></a></span>
<span id="cb37-287"><a href="#cb37-287"></a>where $A$ is symmetric and $A \succ 0$.</span>
<span id="cb37-288"><a href="#cb37-288"></a></span>
<span id="cb37-289"><a href="#cb37-289"></a>Differentiating on both sides, the gradient of the error function is:</span>
<span id="cb37-290"><a href="#cb37-290"></a></span>
<span id="cb37-291"><a href="#cb37-291"></a>\begin{align*}</span>
<span id="cb37-292"><a href="#cb37-292"></a>\nabla f(w) = Aw - b</span>
<span id="cb37-293"><a href="#cb37-293"></a>\end{align*}</span>
<span id="cb37-294"><a href="#cb37-294"></a></span>
<span id="cb37-295"><a href="#cb37-295"></a>and the hessian is:</span>
<span id="cb37-296"><a href="#cb37-296"></a></span>
<span id="cb37-297"><a href="#cb37-297"></a>\begin{align*}</span>
<span id="cb37-298"><a href="#cb37-298"></a>\nabla^2 f(w) = A</span>
<span id="cb37-299"><a href="#cb37-299"></a>\end{align*}</span>
<span id="cb37-300"><a href="#cb37-300"></a></span>
<span id="cb37-301"><a href="#cb37-301"></a>The critical points of $f$ are given by:</span>
<span id="cb37-302"><a href="#cb37-302"></a></span>
<span id="cb37-303"><a href="#cb37-303"></a>\begin{align*}</span>
<span id="cb37-304"><a href="#cb37-304"></a>\nabla f(w^*) &amp;= 0<span class="sc">\\</span></span>
<span id="cb37-305"><a href="#cb37-305"></a>Aw^{*} - b &amp;= 0<span class="sc">\\</span></span>
<span id="cb37-306"><a href="#cb37-306"></a>w^{*} &amp;= A^{-1}b</span>
<span id="cb37-307"><a href="#cb37-307"></a>\end{align*}</span>
<span id="cb37-308"><a href="#cb37-308"></a></span>
<span id="cb37-309"><a href="#cb37-309"></a>and </span>
<span id="cb37-310"><a href="#cb37-310"></a></span>
<span id="cb37-311"><a href="#cb37-311"></a>\begin{align*}</span>
<span id="cb37-312"><a href="#cb37-312"></a>f(w^{*}) &amp;= \frac{1}{2}(A^{-1}b)^T A (A^{-1}b) - b^T (A^{-1} b)<span class="sc">\\</span></span>
<span id="cb37-313"><a href="#cb37-313"></a>&amp;= \frac{1}{2}b^T A^{-1} A A^{-1} b -b^T A^{-1} b <span class="sc">\\</span></span>
<span id="cb37-314"><a href="#cb37-314"></a>&amp;= \frac{1}{2}b^T A^{-1} b - b^T A^{-1} b <span class="sc">\\</span></span>
<span id="cb37-315"><a href="#cb37-315"></a>&amp;= -\frac{1}{2}b^T A^{-1} b</span>
<span id="cb37-316"><a href="#cb37-316"></a>\end{align*}</span>
<span id="cb37-317"><a href="#cb37-317"></a></span>
<span id="cb37-318"><a href="#cb37-318"></a>Therefore, the iterates of $w$ are:</span>
<span id="cb37-319"><a href="#cb37-319"></a></span>
<span id="cb37-320"><a href="#cb37-320"></a>\begin{align*}</span>
<span id="cb37-321"><a href="#cb37-321"></a>w^{(k+1)} = w^{(k)} - \alpha(Aw^{(k)} - b)</span>
<span id="cb37-322"><a href="#cb37-322"></a>\end{align*}</span>
<span id="cb37-323"><a href="#cb37-323"></a></span>
<span id="cb37-324"><a href="#cb37-324"></a>By the *spectral theorem*, every symmetric matrix $A$ is orthogonally diagonalizable. So, $A$ admits a factorization:</span>
<span id="cb37-325"><a href="#cb37-325"></a></span>
<span id="cb37-326"><a href="#cb37-326"></a>\begin{align*}</span>
<span id="cb37-327"><a href="#cb37-327"></a>A = Q \Lambda Q^T</span>
<span id="cb37-328"><a href="#cb37-328"></a>\end{align*}</span>
<span id="cb37-329"><a href="#cb37-329"></a></span>
<span id="cb37-330"><a href="#cb37-330"></a>where $\Lambda = diag(\lambda_1,\ldots,\lambda_n)$ and as per convention, we will assume that $\lambda_i$\s are sorted from smallest $\lambda_1$ to biggest $\lambda_n$.</span>
<span id="cb37-331"><a href="#cb37-331"></a></span>
<span id="cb37-332"><a href="#cb37-332"></a>Recall that $Q=<span class="co">[</span><span class="ot">q_1,\ldots,q_n</span><span class="co">]</span>$, where $q_i$ are the eigenvectors of $A$ and $Q$ is the change of basis matrix from the standard basis to the eigenvector basis. So, if $a \in \mathbf{R}^n$ are the coordinates of a vector in the standard basis and $b \in \mathbf{R}^n$ are its coordinates in the eigenvector basis, then $a = Qb$ or $b=Q^T a$. </span>
<span id="cb37-333"><a href="#cb37-333"></a></span>
<span id="cb37-334"><a href="#cb37-334"></a>Let $x^{(k)}=Q^T(w^{(k)}-w^{*})$. Equivalently, $w^{(k)} = Qx^{(k)} + w^{*}$. Thus, we are shifting the origin to $w^{*}$ and changing the axes to be aligned with the eigenvectors. In this new coordinate system,</span>
<span id="cb37-335"><a href="#cb37-335"></a></span>
<span id="cb37-336"><a href="#cb37-336"></a>\begin{align*}</span>
<span id="cb37-337"><a href="#cb37-337"></a>Qx^{(k+1)} + w^{*} &amp;= Qx^{(k)} + w^{*} - \alpha(AQx^{(k)} + Aw^{*} - b)<span class="sc">\\</span></span>
<span id="cb37-338"><a href="#cb37-338"></a>Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)} + Aw^{*} - b)<span class="sc">\\</span></span>
<span id="cb37-339"><a href="#cb37-339"></a>Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)} + A(A^{-1}b) - b)<span class="sc">\\</span></span>
<span id="cb37-340"><a href="#cb37-340"></a>&amp; \quad <span class="sc">\{</span>\text{Substituting } w^{*}=A^{-1}b <span class="sc">\}\\</span></span>
<span id="cb37-341"><a href="#cb37-341"></a>Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(AQx^{(k)})<span class="sc">\\</span></span>
<span id="cb37-342"><a href="#cb37-342"></a>Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(Q\Lambda Q^T Qx^{(k)})<span class="sc">\\</span></span>
<span id="cb37-343"><a href="#cb37-343"></a>&amp; \quad <span class="sc">\{</span>\text{Substituting } A = Q\Lambda Q^T <span class="sc">\}\\</span></span>
<span id="cb37-344"><a href="#cb37-344"></a>Qx^{(k+1)} &amp;= Qx^{(k)} - \alpha(Q\Lambda x^{(k)})<span class="sc">\\</span></span>
<span id="cb37-345"><a href="#cb37-345"></a>&amp; \quad <span class="sc">\{</span>\text{Using } Q^T Q = I <span class="sc">\}\\</span></span>
<span id="cb37-346"><a href="#cb37-346"></a>x^{(k+1)} &amp;= x^{(k)} - \alpha\Lambda x^{(k)}</span>
<span id="cb37-347"><a href="#cb37-347"></a>\end{align*}</span>
<span id="cb37-348"><a href="#cb37-348"></a></span>
<span id="cb37-349"><a href="#cb37-349"></a>The $i$-th coordinate of this recursive system is given by:</span>
<span id="cb37-350"><a href="#cb37-350"></a></span>
<span id="cb37-351"><a href="#cb37-351"></a>\begin{align*}</span>
<span id="cb37-352"><a href="#cb37-352"></a>x_i^{(k+1)} &amp;= x_i^{(k)} - \alpha\lambda_i x_i^{(k)}<span class="sc">\\</span></span>
<span id="cb37-353"><a href="#cb37-353"></a>&amp;= (1-\alpha \lambda_i)x_i^{(k)}<span class="sc">\\</span></span>
<span id="cb37-354"><a href="#cb37-354"></a>&amp;= (1-\alpha \lambda_i)^{k+1}x_i^{(0)}</span>
<span id="cb37-355"><a href="#cb37-355"></a>\end{align*}</span>
<span id="cb37-356"><a href="#cb37-356"></a></span>
<span id="cb37-357"><a href="#cb37-357"></a>Moving back to our original space $w$, we can see that:</span>
<span id="cb37-358"><a href="#cb37-358"></a></span>
<span id="cb37-359"><a href="#cb37-359"></a>\begin{align*}</span>
<span id="cb37-360"><a href="#cb37-360"></a>w^{(k)} - w^{*} = Qx^{(k)} &amp;= \sum_i q_i x_i^{(k)}<span class="sc">\\</span></span>
<span id="cb37-361"><a href="#cb37-361"></a>&amp;= \sum_i q_i (1-\alpha \lambda_i)^{k+1} x_i^{(0)}</span>
<span id="cb37-362"><a href="#cb37-362"></a>\end{align*}</span>
<span id="cb37-363"><a href="#cb37-363"></a></span>
<span id="cb37-364"><a href="#cb37-364"></a>and there we have it - gradient descent in the closed form.</span>
<span id="cb37-365"><a href="#cb37-365"></a></span>
<span id="cb37-366"><a href="#cb37-366"></a><span class="fu">### Decomposing the error</span></span>
<span id="cb37-367"><a href="#cb37-367"></a></span>
<span id="cb37-368"><a href="#cb37-368"></a>The above equation admits a simple interpretation. Each element of $x^{(0)}$ is the component of the error in the initial guess in $Q$-basis. There are $n$ such errors and each of these errors follow their own, solitary path to the minimum, decreasing exponentially with a compounding rate of $1-\alpha \lambda_i$. The closer that number is to $1$, the slower it converges. </span>
<span id="cb37-369"><a href="#cb37-369"></a></span>
<span id="cb37-370"><a href="#cb37-370"></a>For most step-sizes, the eigenvectors with the largest eigenvalues converge the fastest. This triggers an explosion of progress in the first few iterations, before things slow down, as the eigenvectors with smaller eigenvalues' struggles are revealed. It's easy to visualize this - look at the sequences of $\frac{1}{2^k}$ and $\frac{1}{3^k}$. </span>
<span id="cb37-371"><a href="#cb37-371"></a></span>
<span id="cb37-374"><a href="#cb37-374"></a><span class="in">```{python}</span></span>
<span id="cb37-375"><a href="#cb37-375"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-376"><a href="#cb37-376"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-377"><a href="#cb37-377"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb37-378"><a href="#cb37-378"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb37-379"><a href="#cb37-379"></a>\begin{axis}[</span>
<span id="cb37-380"><a href="#cb37-380"></a>     title<span class="op">=</span>{Comparison of the rates of convergence},</span>
<span id="cb37-381"><a href="#cb37-381"></a>     xlabel<span class="op">=</span>{$n$},</span>
<span id="cb37-382"><a href="#cb37-382"></a>     ylabel<span class="op">=</span>{$f(n)$}</span>
<span id="cb37-383"><a href="#cb37-383"></a>]</span>
<span id="cb37-384"><a href="#cb37-384"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">5</span>,samples<span class="op">=</span><span class="dv">400</span>,blue] {<span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">^</span>x)} node [midway,above] {$<span class="dv">2</span><span class="op">^</span>{<span class="op">-</span>n}$}<span class="op">;</span></span>
<span id="cb37-385"><a href="#cb37-385"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">5</span>,samples<span class="op">=</span><span class="dv">400</span>,red] {<span class="dv">1</span><span class="op">/</span>(<span class="dv">3</span><span class="op">^</span>x)} node [midway,below] {$<span class="dv">3</span><span class="op">^</span>{<span class="op">-</span>n}$}<span class="op">;</span></span>
<span id="cb37-386"><a href="#cb37-386"></a>\end{axis}</span>
<span id="cb37-387"><a href="#cb37-387"></a>\end{tikzpicture}</span>
<span id="cb37-388"><a href="#cb37-388"></a><span class="in">```</span></span>
<span id="cb37-389"><a href="#cb37-389"></a></span>
<span id="cb37-390"><a href="#cb37-390"></a><span class="fu">### Choosing a step size</span></span>
<span id="cb37-391"><a href="#cb37-391"></a></span>
<span id="cb37-392"><a href="#cb37-392"></a>The above analysis gives us immediate guidance as to how to set a step-size $\alpha$. In order to converge, each $|1-\alpha \lambda_i| &lt; 1$. All workable step-sizes, therefore, fall in the interval:</span>
<span id="cb37-393"><a href="#cb37-393"></a></span>
<span id="cb37-394"><a href="#cb37-394"></a>\begin{align*}</span>
<span id="cb37-395"><a href="#cb37-395"></a>-1 &amp;\leq 1 - \alpha \lambda_i &amp;\leq 1 <span class="sc">\\</span></span>
<span id="cb37-396"><a href="#cb37-396"></a>-2 &amp;\leq - \alpha \lambda_i &amp;\leq 0 <span class="sc">\\</span></span>
<span id="cb37-397"><a href="#cb37-397"></a>0 &amp;\leq \alpha \lambda_i &amp;\leq 2 </span>
<span id="cb37-398"><a href="#cb37-398"></a>\end{align*}</span>
<span id="cb37-399"><a href="#cb37-399"></a></span>
<span id="cb37-400"><a href="#cb37-400"></a>Because $(1-\alpha \lambda_i)$ could be either positive or negative, the overall convergence rate is determined by the slowest error component, which must be either $\lambda_1$ or $\lambda_n$:</span>
<span id="cb37-401"><a href="#cb37-401"></a></span>
<span id="cb37-402"><a href="#cb37-402"></a>\begin{align*}</span>
<span id="cb37-403"><a href="#cb37-403"></a>\text{rate}(\alpha) = \max <span class="sc">\{</span>|1-\alpha \lambda_1|,|1-\alpha \lambda_n|<span class="sc">\}</span></span>
<span id="cb37-404"><a href="#cb37-404"></a>\end{align*}</span>
<span id="cb37-405"><a href="#cb37-405"></a></span>
<span id="cb37-406"><a href="#cb37-406"></a>The optimal learning rate is that which balances the convergence rate. Setting the convergence rate to be equal for the smallest and largest eigenvalues, we can solve for the optimal step size.</span>
<span id="cb37-407"><a href="#cb37-407"></a></span>
<span id="cb37-408"><a href="#cb37-408"></a>\begin{align*}</span>
<span id="cb37-409"><a href="#cb37-409"></a>|1- \alpha \lambda_1| = |1- \alpha \lambda_n| </span>
<span id="cb37-410"><a href="#cb37-410"></a>\end{align*}</span>
<span id="cb37-411"><a href="#cb37-411"></a></span>
<span id="cb37-412"><a href="#cb37-412"></a>Assuming $\lambda_1 \neq \lambda_n$:</span>
<span id="cb37-413"><a href="#cb37-413"></a></span>
<span id="cb37-414"><a href="#cb37-414"></a>\begin{align*}</span>
<span id="cb37-415"><a href="#cb37-415"></a>1 - \alpha \lambda_1 &amp;= -1 + \alpha \lambda_n<span class="sc">\\</span></span>
<span id="cb37-416"><a href="#cb37-416"></a>\alpha (\lambda_1 + \lambda_n) &amp;= 2<span class="sc">\\</span></span>
<span id="cb37-417"><a href="#cb37-417"></a>\alpha^* &amp;= \frac{2}{\lambda_1 + \lambda_n}</span>
<span id="cb37-418"><a href="#cb37-418"></a>\end{align*}</span>
<span id="cb37-419"><a href="#cb37-419"></a></span>
<span id="cb37-420"><a href="#cb37-420"></a>So, the optimal convergence rate equals:</span>
<span id="cb37-421"><a href="#cb37-421"></a></span>
<span id="cb37-422"><a href="#cb37-422"></a>\begin{align*}</span>
<span id="cb37-423"><a href="#cb37-423"></a>\max <span class="sc">\{</span>|1-\alpha \lambda_1|,|1-\alpha \lambda_n|<span class="sc">\}</span> &amp;= 1 - \frac{2\lambda_1}{\lambda_1 + \lambda_n} <span class="sc">\\</span></span>
<span id="cb37-424"><a href="#cb37-424"></a>&amp;= \frac{\lambda_n - \lambda_1}{\lambda_n + \lambda_1}<span class="sc">\\</span></span>
<span id="cb37-425"><a href="#cb37-425"></a>&amp;= \frac{\kappa - 1}{\kappa + 1}</span>
<span id="cb37-426"><a href="#cb37-426"></a>\end{align*}</span>
<span id="cb37-427"><a href="#cb37-427"></a></span>
<span id="cb37-428"><a href="#cb37-428"></a>The ratio $\kappa = \lambda_n / \lambda_1$ determines the convergence rate of the problem. Recall that the level curves of the error surface are ellipsoids. Hence, a poorly conditioned Hessian results in stretching one of the axes of the ellipses, and taken to its extreme, the contours are almost parallel. Since gradient vectors are orthogonal to the level curves, the optimizer keeps pin-balling between parallel lines and takes forever to reach the center.</span>
<span id="cb37-429"><a href="#cb37-429"></a></span>
<span id="cb37-430"><a href="#cb37-430"></a><span class="fu">## Stochastic Gradient Descent(SGD)</span></span>
<span id="cb37-431"><a href="#cb37-431"></a></span>
<span id="cb37-432"><a href="#cb37-432"></a>In machine learning applications, we typically want to minimize the loss function $\mathcal{L}(w)$ that has the form of a sum:</span>
<span id="cb37-433"><a href="#cb37-433"></a></span>
<span id="cb37-434"><a href="#cb37-434"></a>\begin{align*}</span>
<span id="cb37-435"><a href="#cb37-435"></a>\mathcal{L}(w) = \frac{1}{n}\sum_i L_i(w)</span>
<span id="cb37-436"><a href="#cb37-436"></a>\end{align*}</span>
<span id="cb37-437"><a href="#cb37-437"></a></span>
<span id="cb37-438"><a href="#cb37-438"></a>where the weights $w$ (and the biases) are to be estimated. Each summand function $L_i$ is typically associated with the $i$-th sample in the data-set used for training.</span>
<span id="cb37-439"><a href="#cb37-439"></a></span>
<span id="cb37-440"><a href="#cb37-440"></a>When we minimize the above function with respect to the weights and biases, a standard gradient descent method would perform the following operations:</span>
<span id="cb37-441"><a href="#cb37-441"></a></span>
<span id="cb37-442"><a href="#cb37-442"></a>\begin{align*}</span>
<span id="cb37-443"><a href="#cb37-443"></a>w_{k+1} := w_k - \alpha_k \nabla \mathcal{L}(w_{k}) = w_k - \frac{\alpha_k}{n}\sum_{i} \nabla L_i(w_{k})</span>
<span id="cb37-444"><a href="#cb37-444"></a>\end{align*}</span>
<span id="cb37-445"><a href="#cb37-445"></a></span>
<span id="cb37-446"><a href="#cb37-446"></a>In the stochastic (or online) gradient descent algorithm, the true gradient of $\mathcal{L}(w)$ is approximated by the gradient at a single sample:</span>
<span id="cb37-447"><a href="#cb37-447"></a></span>
<span id="cb37-448"><a href="#cb37-448"></a>\begin{align*}</span>
<span id="cb37-449"><a href="#cb37-449"></a>w_{k+1} := w_k - \alpha_k \nabla \mathcal{L}(w_{k}) = w_k - \alpha_k \nabla L_i(w_{k})</span>
<span id="cb37-450"><a href="#cb37-450"></a>\end{align*}</span>
<span id="cb37-451"><a href="#cb37-451"></a></span>
<span id="cb37-452"><a href="#cb37-452"></a>if vanilla gradient descent is used, the computational cost of each independent iteration is $O(n)$, where $n$ is the number of training examples. Therefore, when the training dataset is larger, the cost of vanilla gradient descent for each iteration will be higher. We can see that the computational cost of each iteration drops from $O(n)$ to $O(1)$.</span>
<span id="cb37-453"><a href="#cb37-453"></a></span>
<span id="cb37-454"><a href="#cb37-454"></a><span class="fu">## `SGDOptimizer` class</span></span>
<span id="cb37-455"><a href="#cb37-455"></a></span>
<span id="cb37-456"><a href="#cb37-456"></a>We are now in a position to code the <span class="in">`SGDOptimizer`</span> class.</span>
<span id="cb37-457"><a href="#cb37-457"></a></span>
<span id="cb37-460"><a href="#cb37-460"></a><span class="in">```{python}</span></span>
<span id="cb37-461"><a href="#cb37-461"></a><span class="co"># Global imports</span></span>
<span id="cb37-462"><a href="#cb37-462"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-463"><a href="#cb37-463"></a><span class="im">import</span> nnfs</span>
<span id="cb37-464"><a href="#cb37-464"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb37-465"><a href="#cb37-465"></a><span class="im">from</span> nnfs.datasets <span class="im">import</span> spiral_data</span>
<span id="cb37-466"><a href="#cb37-466"></a></span>
<span id="cb37-467"><a href="#cb37-467"></a><span class="im">from</span> dense_layer <span class="im">import</span> DenseLayer</span>
<span id="cb37-468"><a href="#cb37-468"></a><span class="im">from</span> relu_activation <span class="im">import</span> ReLUActivation</span>
<span id="cb37-469"><a href="#cb37-469"></a><span class="im">from</span> softmax_activation <span class="im">import</span> SoftmaxActivation</span>
<span id="cb37-470"><a href="#cb37-470"></a></span>
<span id="cb37-471"><a href="#cb37-471"></a><span class="im">from</span> loss <span class="im">import</span> Loss</span>
<span id="cb37-472"><a href="#cb37-472"></a><span class="im">from</span> categorical_cross_entropy_loss <span class="im">import</span> CategoricalCrossEntropyLoss</span>
<span id="cb37-473"><a href="#cb37-473"></a><span class="im">from</span> categorical_cross_entropy_softmax <span class="im">import</span> CategoricalCrossEntropySoftmax</span>
<span id="cb37-474"><a href="#cb37-474"></a><span class="in">```</span></span>
<span id="cb37-475"><a href="#cb37-475"></a></span>
<span id="cb37-478"><a href="#cb37-478"></a><span class="in">```{python}</span></span>
<span id="cb37-479"><a href="#cb37-479"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb37-480"><a href="#cb37-480"></a></span>
<span id="cb37-481"><a href="#cb37-481"></a>    <span class="co"># Initialize the optimizer</span></span>
<span id="cb37-482"><a href="#cb37-482"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb37-483"><a href="#cb37-483"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-484"><a href="#cb37-484"></a></span>
<span id="cb37-485"><a href="#cb37-485"></a>    <span class="co"># Update the parameters</span></span>
<span id="cb37-486"><a href="#cb37-486"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb37-487"><a href="#cb37-487"></a>        layer.weights <span class="op">-=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-488"><a href="#cb37-488"></a>        layer.biases <span class="op">-=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-489"><a href="#cb37-489"></a><span class="in">```</span></span>
<span id="cb37-490"><a href="#cb37-490"></a></span>
<span id="cb37-491"><a href="#cb37-491"></a>Let's play around with our optimizer. </span>
<span id="cb37-492"><a href="#cb37-492"></a></span>
<span id="cb37-495"><a href="#cb37-495"></a><span class="in">```{python}</span></span>
<span id="cb37-496"><a href="#cb37-496"></a><span class="co"># Create dataset</span></span>
<span id="cb37-497"><a href="#cb37-497"></a>X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-498"><a href="#cb37-498"></a></span>
<span id="cb37-499"><a href="#cb37-499"></a><span class="co"># Create a DenseLayer with 2 input features and 64 neurons</span></span>
<span id="cb37-500"><a href="#cb37-500"></a>dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb37-501"><a href="#cb37-501"></a></span>
<span id="cb37-502"><a href="#cb37-502"></a><span class="co"># Create ReLU Activation (to be used with DenseLayer 1)</span></span>
<span id="cb37-503"><a href="#cb37-503"></a>activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb37-504"><a href="#cb37-504"></a></span>
<span id="cb37-505"><a href="#cb37-505"></a><span class="co"># Create the second DenseLayer with 64 inputs and 3 output values</span></span>
<span id="cb37-506"><a href="#cb37-506"></a>dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>,<span class="dv">3</span>)</span>
<span id="cb37-507"><a href="#cb37-507"></a></span>
<span id="cb37-508"><a href="#cb37-508"></a><span class="co"># Create SoftmaxClassifer's combined loss and activation</span></span>
<span id="cb37-509"><a href="#cb37-509"></a>loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb37-510"><a href="#cb37-510"></a></span>
<span id="cb37-511"><a href="#cb37-511"></a><span class="co"># The next step is to create the optimizer object</span></span>
<span id="cb37-512"><a href="#cb37-512"></a>optimizer <span class="op">=</span> SGDOptimizer()</span>
<span id="cb37-513"><a href="#cb37-513"></a><span class="in">```</span></span>
<span id="cb37-514"><a href="#cb37-514"></a></span>
<span id="cb37-515"><a href="#cb37-515"></a>Now, we perform a *forward pass* of our sample data.</span>
<span id="cb37-516"><a href="#cb37-516"></a></span>
<span id="cb37-519"><a href="#cb37-519"></a><span class="in">```{python}</span></span>
<span id="cb37-520"><a href="#cb37-520"></a><span class="co"># Perform a forward pass for our sample data</span></span>
<span id="cb37-521"><a href="#cb37-521"></a>dense1.forward(X)</span>
<span id="cb37-522"><a href="#cb37-522"></a></span>
<span id="cb37-523"><a href="#cb37-523"></a><span class="co"># Performs a forward pass through the activation function</span></span>
<span id="cb37-524"><a href="#cb37-524"></a><span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb37-525"><a href="#cb37-525"></a>activation1.forward(dense1.output)</span>
<span id="cb37-526"><a href="#cb37-526"></a></span>
<span id="cb37-527"><a href="#cb37-527"></a><span class="co"># Performs a forward pass through the second DenseLayer</span></span>
<span id="cb37-528"><a href="#cb37-528"></a>dense2.forward(activation1.output)</span>
<span id="cb37-529"><a href="#cb37-529"></a></span>
<span id="cb37-530"><a href="#cb37-530"></a><span class="co"># Performs a forward pass through the activation/loss function</span></span>
<span id="cb37-531"><a href="#cb37-531"></a><span class="co"># takes the output of the second DenseLayer and returns the loss</span></span>
<span id="cb37-532"><a href="#cb37-532"></a>loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb37-533"><a href="#cb37-533"></a></span>
<span id="cb37-534"><a href="#cb37-534"></a><span class="co"># Let's print the loss value</span></span>
<span id="cb37-535"><a href="#cb37-535"></a><span class="bu">print</span>(<span class="ss">f"Loss = </span><span class="sc">{</span>loss<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-536"><a href="#cb37-536"></a></span>
<span id="cb37-537"><a href="#cb37-537"></a><span class="co"># Now we do our backward pass </span></span>
<span id="cb37-538"><a href="#cb37-538"></a>loss_activation.backward(loss_activation.output, y)</span>
<span id="cb37-539"><a href="#cb37-539"></a>dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb37-540"><a href="#cb37-540"></a>activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb37-541"><a href="#cb37-541"></a>dense1.backward(activation1.dloss_dz)</span>
<span id="cb37-542"><a href="#cb37-542"></a></span>
<span id="cb37-543"><a href="#cb37-543"></a><span class="co"># Then finally we use our optimizer to update the weights and biases</span></span>
<span id="cb37-544"><a href="#cb37-544"></a>optimizer.update_params(dense1)</span>
<span id="cb37-545"><a href="#cb37-545"></a>optimizer.update_params(dense2)</span>
<span id="cb37-546"><a href="#cb37-546"></a><span class="in">```</span></span>
<span id="cb37-547"><a href="#cb37-547"></a></span>
<span id="cb37-548"><a href="#cb37-548"></a>This is everything we need to train our model! </span>
<span id="cb37-549"><a href="#cb37-549"></a></span>
<span id="cb37-550"><a href="#cb37-550"></a>But why would we only perform this optimization only once, when we can perform it many times by leveraging Python's looping capabilities? We will repeatedly perform a forward pass, backward pass and optimization until we reach some stopping point. Each full pass through all of the training data is called an *epoch*.</span>
<span id="cb37-551"><a href="#cb37-551"></a></span>
<span id="cb37-552"><a href="#cb37-552"></a>In most deep learning tasks, a neural network will be trained for multiple epochs, though the ideal scenario would be to have a perfect model with ideal weights and biases after only one epoch. To add multiple epochs of our training into our code, we will initialize our model and run a loop around all the code performing the forward pass, backward pass and optimization calculations. </span>
<span id="cb37-553"><a href="#cb37-553"></a></span>
<span id="cb37-556"><a href="#cb37-556"></a><span class="in">```{python}</span></span>
<span id="cb37-557"><a href="#cb37-557"></a><span class="co"># Create dataset</span></span>
<span id="cb37-558"><a href="#cb37-558"></a>X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-559"><a href="#cb37-559"></a></span>
<span id="cb37-560"><a href="#cb37-560"></a><span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb37-561"><a href="#cb37-561"></a>dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb37-562"><a href="#cb37-562"></a></span>
<span id="cb37-563"><a href="#cb37-563"></a><span class="co"># Create ReLU Activation (to be used with the DenseLayer)</span></span>
<span id="cb37-564"><a href="#cb37-564"></a>activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb37-565"><a href="#cb37-565"></a></span>
<span id="cb37-566"><a href="#cb37-566"></a><span class="co"># Create a second DenseLayer with 64 input features (as we take</span></span>
<span id="cb37-567"><a href="#cb37-567"></a><span class="co"># output of the previous layer here) and 3 output values (output values)</span></span>
<span id="cb37-568"><a href="#cb37-568"></a>dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb37-569"><a href="#cb37-569"></a></span>
<span id="cb37-570"><a href="#cb37-570"></a><span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb37-571"><a href="#cb37-571"></a>loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb37-572"><a href="#cb37-572"></a></span>
<span id="cb37-573"><a href="#cb37-573"></a><span class="co"># Create optimizer</span></span>
<span id="cb37-574"><a href="#cb37-574"></a>optimizer <span class="op">=</span> SGDOptimizer()</span>
<span id="cb37-575"><a href="#cb37-575"></a></span>
<span id="cb37-576"><a href="#cb37-576"></a><span class="co"># Train in loop</span></span>
<span id="cb37-577"><a href="#cb37-577"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb37-578"><a href="#cb37-578"></a></span>
<span id="cb37-579"><a href="#cb37-579"></a>    <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb37-580"><a href="#cb37-580"></a>    dense1.forward(X)</span>
<span id="cb37-581"><a href="#cb37-581"></a></span>
<span id="cb37-582"><a href="#cb37-582"></a>    <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb37-583"><a href="#cb37-583"></a>    <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb37-584"><a href="#cb37-584"></a>    activation1.forward(dense1.output)</span>
<span id="cb37-585"><a href="#cb37-585"></a></span>
<span id="cb37-586"><a href="#cb37-586"></a>    <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb37-587"><a href="#cb37-587"></a>    <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb37-588"><a href="#cb37-588"></a>    dense2.forward(activation1.output)</span>
<span id="cb37-589"><a href="#cb37-589"></a></span>
<span id="cb37-590"><a href="#cb37-590"></a>    <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb37-591"><a href="#cb37-591"></a>    <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb37-592"><a href="#cb37-592"></a>    loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb37-593"><a href="#cb37-593"></a></span>
<span id="cb37-594"><a href="#cb37-594"></a>    <span class="cf">if</span> <span class="kw">not</span> epoch <span class="op">%</span> <span class="dv">1000</span>:</span>
<span id="cb37-595"><a href="#cb37-595"></a>        <span class="bu">print</span>(<span class="ss">f"Epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, Loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">"</span>)</span>
<span id="cb37-596"><a href="#cb37-596"></a></span>
<span id="cb37-597"><a href="#cb37-597"></a>    <span class="co"># Backward pass</span></span>
<span id="cb37-598"><a href="#cb37-598"></a>    loss_activation.backward(loss_activation.output, y)</span>
<span id="cb37-599"><a href="#cb37-599"></a>    dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb37-600"><a href="#cb37-600"></a>    activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb37-601"><a href="#cb37-601"></a>    dense1.backward(activation1.dloss_dz)</span>
<span id="cb37-602"><a href="#cb37-602"></a></span>
<span id="cb37-603"><a href="#cb37-603"></a>    <span class="co"># Update the weights and the biases</span></span>
<span id="cb37-604"><a href="#cb37-604"></a>    optimizer.update_params(dense1)</span>
<span id="cb37-605"><a href="#cb37-605"></a>    optimizer.update_params(dense2)</span>
<span id="cb37-606"><a href="#cb37-606"></a></span>
<span id="cb37-607"><a href="#cb37-607"></a><span class="in">```</span></span>
<span id="cb37-608"><a href="#cb37-608"></a></span>
<span id="cb37-609"><a href="#cb37-609"></a>Our neural network mostly stays stuck at around a loss of $1.0$ and later around $0.85$-$0.90$ Given that this loss didn't decrease much, we can assume that this learning rate being too high, also caused the model to get stuck in a **local minimum**, which we'll learn more about soon. Iterating over more epochs, doesn't seem helpful at this point, which tells us that we're likely stuck with our optimization. Does this mean that this is the most we can get from our optimizer on this dataset?</span>
<span id="cb37-610"><a href="#cb37-610"></a></span>
<span id="cb37-611"><a href="#cb37-611"></a>Recall that we're adjusting our weights and biases by applying some fraction, in this case $1.0$ to the gradient and subtracting this from the weights and biases. This fraction is called the **learning rate** (LR) and is the primary adjustable parameter for the optimizer as it decreases loss. </span>
<span id="cb37-612"><a href="#cb37-612"></a></span>
<span id="cb37-613"><a href="#cb37-613"></a><span class="fu">## Learning Rate Decay</span></span>
<span id="cb37-614"><a href="#cb37-614"></a></span>
<span id="cb37-615"><a href="#cb37-615"></a>The idea of a *learning rate decay* is to start with a large learning rate, say $1.0$ in our case and then decrease it during training. There are a few methods for doing this. One option is program a **decay rate**, which steadily decays the learning rate per batch or per epoch.</span>
<span id="cb37-616"><a href="#cb37-616"></a></span>
<span id="cb37-617"><a href="#cb37-617"></a>Let's plan to decay per step. This can also be referred to as $1/t$ **decaying** or **exponential decaying**. Basically, we're going to update the learning rate each step by the reciprocal of the step count fraction. This fraction is a new hyper parameter that we'll add to the optimizer, called the **learning rate decay**.</span>
<span id="cb37-618"><a href="#cb37-618"></a></span>
<span id="cb37-621"><a href="#cb37-621"></a><span class="in">```{python}</span></span>
<span id="cb37-622"><a href="#cb37-622"></a>initial_learning_rate <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb37-623"><a href="#cb37-623"></a>learning_rate_decay <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb37-624"><a href="#cb37-624"></a></span>
<span id="cb37-625"><a href="#cb37-625"></a><span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb37-626"><a href="#cb37-626"></a>    learning_rate <span class="op">=</span> initial_learning_rate <span class="op">*</span> <span class="fl">1.0</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> learning_rate_decay <span class="op">*</span> step)</span>
<span id="cb37-627"><a href="#cb37-627"></a>    <span class="bu">print</span>(learning_rate)</span>
<span id="cb37-628"><a href="#cb37-628"></a><span class="in">```</span></span>
<span id="cb37-629"><a href="#cb37-629"></a></span>
<span id="cb37-630"><a href="#cb37-630"></a>The derivative of the function $\frac{1}{1+x}$ is $-\frac{1}{(1+x)^2}$.</span>
<span id="cb37-631"><a href="#cb37-631"></a></span>
<span id="cb37-634"><a href="#cb37-634"></a><span class="in">```{python}</span></span>
<span id="cb37-635"><a href="#cb37-635"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-636"><a href="#cb37-636"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-637"><a href="#cb37-637"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz,pgfplots <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb37-638"><a href="#cb37-638"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb37-639"><a href="#cb37-639"></a>\begin{axis}[</span>
<span id="cb37-640"><a href="#cb37-640"></a>     title<span class="op">=</span>{Plot of $f(x)<span class="op">=-</span>\frac{<span class="dv">1</span>}{(<span class="dv">1</span><span class="op">+</span>x)<span class="op">^</span><span class="dv">2</span>}$},</span>
<span id="cb37-641"><a href="#cb37-641"></a>     xlabel<span class="op">=</span>{$x$},</span>
<span id="cb37-642"><a href="#cb37-642"></a>     ylabel<span class="op">=</span>{$f(x)$}</span>
<span id="cb37-643"><a href="#cb37-643"></a>]</span>
<span id="cb37-644"><a href="#cb37-644"></a>    \addplot [domain<span class="op">=</span><span class="dv">0</span>:<span class="dv">1</span>,samples<span class="op">=</span><span class="dv">400</span>] {<span class="op">-</span><span class="dv">1</span><span class="op">/</span>(( <span class="dv">1</span> <span class="op">+</span> x)<span class="op">^</span><span class="dv">2</span>)}<span class="op">;</span></span>
<span id="cb37-645"><a href="#cb37-645"></a>\end{axis}</span>
<span id="cb37-646"><a href="#cb37-646"></a>\end{tikzpicture}</span>
<span id="cb37-647"><a href="#cb37-647"></a><span class="in">```</span></span>
<span id="cb37-648"><a href="#cb37-648"></a></span>
<span id="cb37-649"><a href="#cb37-649"></a>The learning rate drops fast initially, but the change in the learning rate lowers in each step. We can update our <span class="in">`SGDOptimizer`</span> class to allow for the learning rate decay.</span>
<span id="cb37-650"><a href="#cb37-650"></a></span>
<span id="cb37-653"><a href="#cb37-653"></a><span class="in">```{python}</span></span>
<span id="cb37-654"><a href="#cb37-654"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb37-655"><a href="#cb37-655"></a></span>
<span id="cb37-656"><a href="#cb37-656"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb37-657"><a href="#cb37-657"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb37-658"><a href="#cb37-658"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb37-659"><a href="#cb37-659"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-660"><a href="#cb37-660"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-661"><a href="#cb37-661"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb37-662"><a href="#cb37-662"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-663"><a href="#cb37-663"></a></span>
<span id="cb37-664"><a href="#cb37-664"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb37-665"><a href="#cb37-665"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb37-666"><a href="#cb37-666"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb37-667"><a href="#cb37-667"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb37-668"><a href="#cb37-668"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb37-669"><a href="#cb37-669"></a>            )</span>
<span id="cb37-670"><a href="#cb37-670"></a></span>
<span id="cb37-671"><a href="#cb37-671"></a>    <span class="co"># Update parameters</span></span>
<span id="cb37-672"><a href="#cb37-672"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb37-673"><a href="#cb37-673"></a>        layer.weights <span class="op">+=</span> <span class="op">-</span><span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-674"><a href="#cb37-674"></a>        layer.biases <span class="op">+=</span> <span class="op">-</span><span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-675"><a href="#cb37-675"></a></span>
<span id="cb37-676"><a href="#cb37-676"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb37-677"><a href="#cb37-677"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-678"><a href="#cb37-678"></a><span class="in">```</span></span>
<span id="cb37-679"><a href="#cb37-679"></a></span>
<span id="cb37-680"><a href="#cb37-680"></a>Let's use a decay rate of $0.01$ and train our neural network again.</span>
<span id="cb37-681"><a href="#cb37-681"></a></span>
<span id="cb37-684"><a href="#cb37-684"></a><span class="in">```{python}</span></span>
<span id="cb37-685"><a href="#cb37-685"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-686"><a href="#cb37-686"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-687"><a href="#cb37-687"></a><span class="kw">def</span> train(decay):</span>
<span id="cb37-688"><a href="#cb37-688"></a>    <span class="co"># Create a dataset</span></span>
<span id="cb37-689"><a href="#cb37-689"></a>    X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-690"><a href="#cb37-690"></a></span>
<span id="cb37-691"><a href="#cb37-691"></a>    <span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb37-692"><a href="#cb37-692"></a>    dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb37-693"><a href="#cb37-693"></a></span>
<span id="cb37-694"><a href="#cb37-694"></a>    <span class="co"># Create ReLU activation (to be used with the dense layer)</span></span>
<span id="cb37-695"><a href="#cb37-695"></a>    activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb37-696"><a href="#cb37-696"></a></span>
<span id="cb37-697"><a href="#cb37-697"></a>    <span class="co"># Create second DenseLayer with 64 input features (as we take output of the</span></span>
<span id="cb37-698"><a href="#cb37-698"></a>    <span class="co"># previous layer here) and 3 output values</span></span>
<span id="cb37-699"><a href="#cb37-699"></a>    dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb37-700"><a href="#cb37-700"></a></span>
<span id="cb37-701"><a href="#cb37-701"></a>    <span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb37-702"><a href="#cb37-702"></a>    loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb37-703"><a href="#cb37-703"></a></span>
<span id="cb37-704"><a href="#cb37-704"></a>    <span class="co"># Create optimizer</span></span>
<span id="cb37-705"><a href="#cb37-705"></a>    optimizer <span class="op">=</span> SGDOptimizer(learning_rate<span class="op">=</span><span class="fl">1.0</span>,decay<span class="op">=</span>decay)</span>
<span id="cb37-706"><a href="#cb37-706"></a></span>
<span id="cb37-707"><a href="#cb37-707"></a>    acc_vals <span class="op">=</span> []</span>
<span id="cb37-708"><a href="#cb37-708"></a>    loss_vals <span class="op">=</span> []</span>
<span id="cb37-709"><a href="#cb37-709"></a>    lr_vals <span class="op">=</span> []</span>
<span id="cb37-710"><a href="#cb37-710"></a></span>
<span id="cb37-711"><a href="#cb37-711"></a>    <span class="co"># Train in a loop</span></span>
<span id="cb37-712"><a href="#cb37-712"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb37-713"><a href="#cb37-713"></a>        <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb37-714"><a href="#cb37-714"></a>        dense1.forward(X)</span>
<span id="cb37-715"><a href="#cb37-715"></a></span>
<span id="cb37-716"><a href="#cb37-716"></a>        <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb37-717"><a href="#cb37-717"></a>        <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb37-718"><a href="#cb37-718"></a>        activation1.forward(dense1.output)</span>
<span id="cb37-719"><a href="#cb37-719"></a></span>
<span id="cb37-720"><a href="#cb37-720"></a>        <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb37-721"><a href="#cb37-721"></a>        <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb37-722"><a href="#cb37-722"></a>        dense2.forward(activation1.output)</span>
<span id="cb37-723"><a href="#cb37-723"></a></span>
<span id="cb37-724"><a href="#cb37-724"></a>        <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb37-725"><a href="#cb37-725"></a>        <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb37-726"><a href="#cb37-726"></a>        loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb37-727"><a href="#cb37-727"></a></span>
<span id="cb37-728"><a href="#cb37-728"></a>        <span class="co"># Calculate accuracy from output of activation2 and targets</span></span>
<span id="cb37-729"><a href="#cb37-729"></a>        <span class="co"># Calculate values along the first axis</span></span>
<span id="cb37-730"><a href="#cb37-730"></a>        predictions <span class="op">=</span> np.argmax(loss_activation.output, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-731"><a href="#cb37-731"></a>        <span class="cf">if</span> <span class="bu">len</span>(y.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb37-732"><a href="#cb37-732"></a>            y <span class="op">=</span> np.argmax(y, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-733"><a href="#cb37-733"></a></span>
<span id="cb37-734"><a href="#cb37-734"></a>        accuracy <span class="op">=</span> np.mean(predictions <span class="op">==</span> y)</span>
<span id="cb37-735"><a href="#cb37-735"></a></span>
<span id="cb37-736"><a href="#cb37-736"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb37-737"><a href="#cb37-737"></a>            <span class="bu">print</span>(</span>
<span id="cb37-738"><a href="#cb37-738"></a>                <span class="ss">f"epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-739"><a href="#cb37-739"></a><span class="ss">                acc : </span><span class="sc">{</span>accuracy<span class="sc">:.3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-740"><a href="#cb37-740"></a><span class="ss">                loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-741"><a href="#cb37-741"></a><span class="ss">                lr : </span><span class="sc">{</span>optimizer<span class="sc">.</span>current_learning_rate<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb37-742"><a href="#cb37-742"></a>            )</span>
<span id="cb37-743"><a href="#cb37-743"></a></span>
<span id="cb37-744"><a href="#cb37-744"></a>        acc_vals.append(accuracy)</span>
<span id="cb37-745"><a href="#cb37-745"></a>        loss_vals.append(loss)</span>
<span id="cb37-746"><a href="#cb37-746"></a>        lr_vals.append(optimizer.current_learning_rate)</span>
<span id="cb37-747"><a href="#cb37-747"></a></span>
<span id="cb37-748"><a href="#cb37-748"></a>        <span class="co"># Backward pass</span></span>
<span id="cb37-749"><a href="#cb37-749"></a>        loss_activation.backward(loss_activation.output, y)</span>
<span id="cb37-750"><a href="#cb37-750"></a>        dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb37-751"><a href="#cb37-751"></a>        activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb37-752"><a href="#cb37-752"></a>        dense1.backward(activation1.dloss_dz)</span>
<span id="cb37-753"><a href="#cb37-753"></a></span>
<span id="cb37-754"><a href="#cb37-754"></a>        <span class="co"># Update the weights and the biases</span></span>
<span id="cb37-755"><a href="#cb37-755"></a>        optimizer.pre_update_params()</span>
<span id="cb37-756"><a href="#cb37-756"></a>        optimizer.update_params(dense1)</span>
<span id="cb37-757"><a href="#cb37-757"></a>        optimizer.update_params(dense2)</span>
<span id="cb37-758"><a href="#cb37-758"></a>        optimizer.post_update_params()</span>
<span id="cb37-759"><a href="#cb37-759"></a></span>
<span id="cb37-760"><a href="#cb37-760"></a>    <span class="cf">return</span> acc_vals, loss_vals, lr_vals</span>
<span id="cb37-761"><a href="#cb37-761"></a><span class="in">```</span></span>
<span id="cb37-762"><a href="#cb37-762"></a></span>
<span id="cb37-765"><a href="#cb37-765"></a><span class="in">```{python}</span></span>
<span id="cb37-766"><a href="#cb37-766"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb37-767"><a href="#cb37-767"></a><span class="in">```</span></span>
<span id="cb37-768"><a href="#cb37-768"></a></span>
<span id="cb37-771"><a href="#cb37-771"></a><span class="in">```{python}</span></span>
<span id="cb37-772"><a href="#cb37-772"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-773"><a href="#cb37-773"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-774"><a href="#cb37-774"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-775"><a href="#cb37-775"></a>epochs <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10000</span>,<span class="dv">10001</span>)</span>
<span id="cb37-776"><a href="#cb37-776"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb37-777"><a href="#cb37-777"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb37-778"><a href="#cb37-778"></a>plt.plot(epochs,acc_vals)</span>
<span id="cb37-779"><a href="#cb37-779"></a>plt.show()</span>
<span id="cb37-780"><a href="#cb37-780"></a><span class="in">```</span></span>
<span id="cb37-781"><a href="#cb37-781"></a></span>
<span id="cb37-784"><a href="#cb37-784"></a><span class="in">```{python}</span></span>
<span id="cb37-785"><a href="#cb37-785"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-786"><a href="#cb37-786"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-787"><a href="#cb37-787"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-788"><a href="#cb37-788"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb37-789"><a href="#cb37-789"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb37-790"><a href="#cb37-790"></a>plt.plot(epochs,loss_vals)</span>
<span id="cb37-791"><a href="#cb37-791"></a>plt.show()</span>
<span id="cb37-792"><a href="#cb37-792"></a><span class="in">```</span></span>
<span id="cb37-793"><a href="#cb37-793"></a></span>
<span id="cb37-796"><a href="#cb37-796"></a><span class="in">```{python}</span></span>
<span id="cb37-797"><a href="#cb37-797"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-798"><a href="#cb37-798"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-799"><a href="#cb37-799"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-800"><a href="#cb37-800"></a>plt.ylabel(<span class="st">"Learning rate"</span>)</span>
<span id="cb37-801"><a href="#cb37-801"></a>plt.xlabel(<span class="st">"Epochs"</span>)</span>
<span id="cb37-802"><a href="#cb37-802"></a>plt.plot(epochs, lr_vals)</span>
<span id="cb37-803"><a href="#cb37-803"></a>plt.show()</span>
<span id="cb37-804"><a href="#cb37-804"></a><span class="in">```</span></span>
<span id="cb37-805"><a href="#cb37-805"></a></span>
<span id="cb37-806"><a href="#cb37-806"></a>The optimization algorithm appears to be stuck and the reason is because the learning rate decayed far too quickly and became too small, trapping the optimizer in some local minimum. We can, instead, try to decay a bit slower by making our decay a smaller number. For example, let's go with $10^{-3}$.</span>
<span id="cb37-807"><a href="#cb37-807"></a></span>
<span id="cb37-810"><a href="#cb37-810"></a><span class="in">```{python}</span></span>
<span id="cb37-811"><a href="#cb37-811"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>)</span>
<span id="cb37-812"><a href="#cb37-812"></a><span class="in">```</span></span>
<span id="cb37-813"><a href="#cb37-813"></a></span>
<span id="cb37-816"><a href="#cb37-816"></a><span class="in">```{python}</span></span>
<span id="cb37-817"><a href="#cb37-817"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-818"><a href="#cb37-818"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-819"><a href="#cb37-819"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-820"><a href="#cb37-820"></a>epochs <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10000</span>,<span class="dv">10001</span>)</span>
<span id="cb37-821"><a href="#cb37-821"></a>plt.ylabel(<span class="st">'Accuracy'</span>)</span>
<span id="cb37-822"><a href="#cb37-822"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb37-823"><a href="#cb37-823"></a>plt.plot(epochs,acc_vals)</span>
<span id="cb37-824"><a href="#cb37-824"></a>plt.show()</span>
<span id="cb37-825"><a href="#cb37-825"></a><span class="in">```</span></span>
<span id="cb37-826"><a href="#cb37-826"></a></span>
<span id="cb37-829"><a href="#cb37-829"></a><span class="in">```{python}</span></span>
<span id="cb37-830"><a href="#cb37-830"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-831"><a href="#cb37-831"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-832"><a href="#cb37-832"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-833"><a href="#cb37-833"></a>plt.ylabel(<span class="st">'Loss'</span>)</span>
<span id="cb37-834"><a href="#cb37-834"></a>plt.xlabel(<span class="st">'Epochs'</span>)</span>
<span id="cb37-835"><a href="#cb37-835"></a>plt.plot(epochs,loss_vals)</span>
<span id="cb37-836"><a href="#cb37-836"></a>plt.show()</span>
<span id="cb37-837"><a href="#cb37-837"></a><span class="in">```</span></span>
<span id="cb37-838"><a href="#cb37-838"></a></span>
<span id="cb37-841"><a href="#cb37-841"></a><span class="in">```{python}</span></span>
<span id="cb37-842"><a href="#cb37-842"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-843"><a href="#cb37-843"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-844"><a href="#cb37-844"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb37-845"><a href="#cb37-845"></a>plt.ylabel(<span class="st">"Learning rate"</span>)</span>
<span id="cb37-846"><a href="#cb37-846"></a>plt.xlabel(<span class="st">"Epochs"</span>)</span>
<span id="cb37-847"><a href="#cb37-847"></a>plt.plot(epochs, lr_vals)</span>
<span id="cb37-848"><a href="#cb37-848"></a>plt.show()</span>
<span id="cb37-849"><a href="#cb37-849"></a><span class="in">```</span></span>
<span id="cb37-850"><a href="#cb37-850"></a></span>
<span id="cb37-851"><a href="#cb37-851"></a></span>
<span id="cb37-852"><a href="#cb37-852"></a><span class="fu">## Stochastic Gradient Descent with Momentum</span></span>
<span id="cb37-853"><a href="#cb37-853"></a></span>
<span id="cb37-854"><a href="#cb37-854"></a>Momentum proposes a small tweak to gradient descent. We give gradient descent a short-term memory. Let's define the updated velocity $z^{k+1}$ to be weighted and controlled by the mass $\beta$. When $\beta$ is high, we simply use the velocity from the last time, that is, we are entirely driven by momentum. When $\beta=0$, the momentum is zero.</span>
<span id="cb37-855"><a href="#cb37-855"></a></span>
<span id="cb37-856"><a href="#cb37-856"></a>\begin{align*}</span>
<span id="cb37-857"><a href="#cb37-857"></a>z^{(k+1)} &amp;= \beta z^{(k)} + \nabla f(w^{(k)})<span class="sc">\\</span></span>
<span id="cb37-858"><a href="#cb37-858"></a>w^{k+1} &amp;= w^k - \alpha z^{k+1}</span>
<span id="cb37-859"><a href="#cb37-859"></a>\end{align*}</span>
<span id="cb37-860"><a href="#cb37-860"></a></span>
<span id="cb37-861"><a href="#cb37-861"></a>$z^{(k+1)}$ is called the *velocity*. It accumulates the past gradients similar to how a heavy ball rolling down the error function landscape integrates over past forces. To see what's happening in more detail, we can recursively write out:</span>
<span id="cb37-862"><a href="#cb37-862"></a></span>
<span id="cb37-863"><a href="#cb37-863"></a>\begin{align*}</span>
<span id="cb37-864"><a href="#cb37-864"></a>z^{(k)} &amp;= \beta z^{k-1} + \nabla f(w^{(k-1)}) <span class="sc">\\</span></span>
<span id="cb37-865"><a href="#cb37-865"></a>&amp;= \beta(\beta z^{k-2} + \nabla f(w^{(k-2)})) + \nabla f(w^{(k-1)})<span class="sc">\\</span></span>
<span id="cb37-866"><a href="#cb37-866"></a>&amp;= \beta^2 z^{k-2} + \beta \nabla f(w^{(k-2)}) + \nabla f(w^{(k-1)})<span class="sc">\\</span></span>
<span id="cb37-867"><a href="#cb37-867"></a>&amp;= \beta^2 (\beta z^{k-3} + \nabla f(w^{(k-3)}) ) + \beta \nabla f(w^{(k-2)}) + \nabla f(w^{(k-1)})<span class="sc">\\</span></span>
<span id="cb37-868"><a href="#cb37-868"></a>&amp;= \sum_{t=0}^{k} \beta^t \nabla f(w^{(k-1-t)})</span>
<span id="cb37-869"><a href="#cb37-869"></a>\end{align*}</span>
<span id="cb37-870"><a href="#cb37-870"></a></span>
<span id="cb37-871"><a href="#cb37-871"></a>The new gradient replacement no longer points into the direction of steepest descent on a particular instance any longer but rather in the direction of an exponentially weighted average of past gradients.</span>
<span id="cb37-872"><a href="#cb37-872"></a></span>
<span id="cb37-873"><a href="#cb37-873"></a><span class="fu">### The dynamics of Momentum</span></span>
<span id="cb37-874"><a href="#cb37-874"></a></span>
<span id="cb37-875"><a href="#cb37-875"></a>Since $\nabla f(w^k) = Aw^k - b$, the update on the quadratic is:</span>
<span id="cb37-876"><a href="#cb37-876"></a></span>
<span id="cb37-877"><a href="#cb37-877"></a>\begin{align*}</span>
<span id="cb37-878"><a href="#cb37-878"></a>z^{k+1} &amp;= \beta z^k + (Aw^k - b)<span class="sc">\\</span></span>
<span id="cb37-879"><a href="#cb37-879"></a>w^{k+1} &amp;= w^k - \alpha z^{k+1}</span>
<span id="cb37-880"><a href="#cb37-880"></a>\end{align*}</span>
<span id="cb37-881"><a href="#cb37-881"></a></span>
<span id="cb37-882"><a href="#cb37-882"></a>We go through the same motions as before with the change of basis $(w^k - w^{*})=Qx^k$ and $z^k = Q y^k$ to yield the update rule:</span>
<span id="cb37-883"><a href="#cb37-883"></a></span>
<span id="cb37-884"><a href="#cb37-884"></a>\begin{align*}</span>
<span id="cb37-885"><a href="#cb37-885"></a>Q y^{k+1} &amp;= \beta Q y^k + (AQx^k + Aw^* - b)<span class="sc">\\</span></span>
<span id="cb37-886"><a href="#cb37-886"></a>Q y^{k+1} &amp;= \beta Q y^k + (AQx^k + AA^{-1}b - b)<span class="sc">\\</span></span>
<span id="cb37-887"><a href="#cb37-887"></a>Q y^{k+1} &amp;= \beta Q y^k + Q\Lambda Q^T Q x^k<span class="sc">\\</span></span>
<span id="cb37-888"><a href="#cb37-888"></a>Q y^{k+1} &amp;= \beta Q y^k + Q\Lambda x^k<span class="sc">\\</span></span>
<span id="cb37-889"><a href="#cb37-889"></a>y^{k+1} &amp;= \beta y^k + \Lambda x^k</span>
<span id="cb37-890"><a href="#cb37-890"></a>\end{align*}</span>
<span id="cb37-891"><a href="#cb37-891"></a></span>
<span id="cb37-892"><a href="#cb37-892"></a>or equivalently:</span>
<span id="cb37-893"><a href="#cb37-893"></a></span>
<span id="cb37-894"><a href="#cb37-894"></a>\begin{align*}</span>
<span id="cb37-895"><a href="#cb37-895"></a>y_i^{k+1} &amp;= \beta y_i^k + \lambda_i x_i^k</span>
<span id="cb37-896"><a href="#cb37-896"></a>\end{align*}</span>
<span id="cb37-897"><a href="#cb37-897"></a></span>
<span id="cb37-898"><a href="#cb37-898"></a>Moreover,</span>
<span id="cb37-899"><a href="#cb37-899"></a></span>
<span id="cb37-900"><a href="#cb37-900"></a>\begin{align*}</span>
<span id="cb37-901"><a href="#cb37-901"></a>Qx^{k+1} + w^* &amp;= Qx^k + w^* - \alpha Qy^{k+1}<span class="sc">\\</span></span>
<span id="cb37-902"><a href="#cb37-902"></a>x^{k+1} &amp;= x^k - \alpha y^{k+1}</span>
<span id="cb37-903"><a href="#cb37-903"></a>\end{align*}</span>
<span id="cb37-904"><a href="#cb37-904"></a></span>
<span id="cb37-905"><a href="#cb37-905"></a>or equivalently:</span>
<span id="cb37-906"><a href="#cb37-906"></a></span>
<span id="cb37-907"><a href="#cb37-907"></a>\begin{align*}</span>
<span id="cb37-908"><a href="#cb37-908"></a>x_i^{k+1} &amp;= x_i^k - \alpha y_i^{k+1}</span>
<span id="cb37-909"><a href="#cb37-909"></a>\end{align*}</span>
<span id="cb37-910"><a href="#cb37-910"></a></span>
<span id="cb37-911"><a href="#cb37-911"></a>This lets us rewrite our iterates as:</span>
<span id="cb37-912"><a href="#cb37-912"></a></span>
<span id="cb37-913"><a href="#cb37-913"></a>\begin{align*}</span>
<span id="cb37-914"><a href="#cb37-914"></a>\begin{bmatrix}</span>
<span id="cb37-915"><a href="#cb37-915"></a>y_i^{k+1}<span class="sc">\\</span></span>
<span id="cb37-916"><a href="#cb37-916"></a>x_i^{k+1}</span>
<span id="cb37-917"><a href="#cb37-917"></a>\end{bmatrix} &amp;= </span>
<span id="cb37-918"><a href="#cb37-918"></a>\begin{bmatrix}</span>
<span id="cb37-919"><a href="#cb37-919"></a>\beta y_i^k + \lambda_i x_i^k<span class="sc">\\</span></span>
<span id="cb37-920"><a href="#cb37-920"></a>(1-\alpha\lambda_i)x_i^k - \alpha \beta y_i^k</span>
<span id="cb37-921"><a href="#cb37-921"></a>\end{bmatrix}<span class="sc">\\</span></span>
<span id="cb37-922"><a href="#cb37-922"></a>&amp;=\begin{bmatrix}</span>
<span id="cb37-923"><a href="#cb37-923"></a>\beta &amp; \lambda_i<span class="sc">\\</span></span>
<span id="cb37-924"><a href="#cb37-924"></a><span class="ss">- </span>\alpha \beta &amp; (1-\alpha\lambda_i) </span>
<span id="cb37-925"><a href="#cb37-925"></a>\end{bmatrix} </span>
<span id="cb37-926"><a href="#cb37-926"></a>\begin{bmatrix}</span>
<span id="cb37-927"><a href="#cb37-927"></a>y_i^k<span class="sc">\\</span></span>
<span id="cb37-928"><a href="#cb37-928"></a>x_i^k</span>
<span id="cb37-929"><a href="#cb37-929"></a>\end{bmatrix}</span>
<span id="cb37-930"><a href="#cb37-930"></a>\end{align*}</span>
<span id="cb37-931"><a href="#cb37-931"></a></span>
<span id="cb37-932"><a href="#cb37-932"></a>Consequently,</span>
<span id="cb37-933"><a href="#cb37-933"></a></span>
<span id="cb37-934"><a href="#cb37-934"></a>\begin{align*}</span>
<span id="cb37-935"><a href="#cb37-935"></a>\begin{bmatrix}</span>
<span id="cb37-936"><a href="#cb37-936"></a>y_i^k<span class="sc">\\</span></span>
<span id="cb37-937"><a href="#cb37-937"></a>x_i^k</span>
<span id="cb37-938"><a href="#cb37-938"></a>\end{bmatrix} = R^k \begin{bmatrix}</span>
<span id="cb37-939"><a href="#cb37-939"></a>y_i^0<span class="sc">\\</span></span>
<span id="cb37-940"><a href="#cb37-940"></a>x_i^0</span>
<span id="cb37-941"><a href="#cb37-941"></a>\end{bmatrix},\quad </span>
<span id="cb37-942"><a href="#cb37-942"></a>R = \begin{bmatrix}</span>
<span id="cb37-943"><a href="#cb37-943"></a>\beta &amp; \lambda_i<span class="sc">\\</span></span>
<span id="cb37-944"><a href="#cb37-944"></a><span class="ss">- </span>\alpha \beta &amp; (1-\alpha\lambda_i) </span>
<span id="cb37-945"><a href="#cb37-945"></a>\end{bmatrix}</span>
<span id="cb37-946"><a href="#cb37-946"></a>\end{align*}</span>
<span id="cb37-947"><a href="#cb37-947"></a></span>
<span id="cb37-948"><a href="#cb37-948"></a>In the case of $2 \times 2$ matrix, there is an elegant little known formula in terms of the eigenvalues of the matrix $R$, $\sigma_1$ and $\sigma_2$:</span>
<span id="cb37-949"><a href="#cb37-949"></a></span>
<span id="cb37-950"><a href="#cb37-950"></a>\begin{align*}</span>
<span id="cb37-951"><a href="#cb37-951"></a>R^k = \begin{cases}</span>
<span id="cb37-952"><a href="#cb37-952"></a>\sigma_1^k R_1 - \sigma_2^k R_2 &amp; \sigma_1 \neq \sigma_2,<span class="sc">\\</span></span>
<span id="cb37-953"><a href="#cb37-953"></a>\sigma_1^k(kR\sigma_1-(k-1)I) &amp; \sigma_1 = \sigma_2</span>
<span id="cb37-954"><a href="#cb37-954"></a>\end{cases}</span>
<span id="cb37-955"><a href="#cb37-955"></a>\quad</span>
<span id="cb37-956"><a href="#cb37-956"></a>R_j = \frac{R-\sigma_j I}{\sigma_1 - \sigma_2}</span>
<span id="cb37-957"><a href="#cb37-957"></a>\end{align*}</span>
<span id="cb37-958"><a href="#cb37-958"></a></span>
<span id="cb37-959"><a href="#cb37-959"></a>The formula is rather complicated, but the takeway here is that it plays the exact same role  the individual convergence rates $(1-\alpha \lambda_i)$ do in gradient descent. The convergence rate is therefore the slowest of the two rates, $\max <span class="sc">\{</span>|\sigma_1|,|\sigma_2|<span class="sc">\}</span>$.</span>
<span id="cb37-960"><a href="#cb37-960"></a></span>
<span id="cb37-961"><a href="#cb37-961"></a>For what values of $\alpha$ and $\beta$ does momentum converge? Since we need both $\sigma_1$ and $\sigma_2$ to converge, our convergence criterion is now </span>
<span id="cb37-962"><a href="#cb37-962"></a>$\max <span class="sc">\{</span>|\sigma_1|,|\sigma_2|<span class="sc">\}</span> &lt; 1$.</span>
<span id="cb37-963"><a href="#cb37-963"></a></span>
<span id="cb37-964"><a href="#cb37-964"></a>It can be shown that when we choose an optimal value of the parameters $\alpha$ and $\beta$, the convergence rate is proportional to:</span>
<span id="cb37-965"><a href="#cb37-965"></a></span>
<span id="cb37-966"><a href="#cb37-966"></a>\begin{align*}</span>
<span id="cb37-967"><a href="#cb37-967"></a>\frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1}</span>
<span id="cb37-968"><a href="#cb37-968"></a>\end{align*}</span>
<span id="cb37-969"><a href="#cb37-969"></a></span>
<span id="cb37-970"><a href="#cb37-970"></a>With barely a modicum of extra effort, we have square-rooted the condition number. </span>
<span id="cb37-971"><a href="#cb37-971"></a></span>
<span id="cb37-972"><a href="#cb37-972"></a><span class="fu">## Adding momentum to the `SGDOptimizer` class</span></span>
<span id="cb37-973"><a href="#cb37-973"></a></span>
<span id="cb37-974"><a href="#cb37-974"></a>We are now in a position to add momentum to the <span class="in">`SGDOptimizer`</span> class.</span>
<span id="cb37-975"><a href="#cb37-975"></a></span>
<span id="cb37-978"><a href="#cb37-978"></a><span class="in">```{python}</span></span>
<span id="cb37-979"><a href="#cb37-979"></a><span class="kw">class</span> SGDOptimizer:</span>
<span id="cb37-980"><a href="#cb37-980"></a></span>
<span id="cb37-981"><a href="#cb37-981"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb37-982"><a href="#cb37-982"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb37-983"><a href="#cb37-983"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>, momentum<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb37-984"><a href="#cb37-984"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-985"><a href="#cb37-985"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-986"><a href="#cb37-986"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb37-987"><a href="#cb37-987"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-988"><a href="#cb37-988"></a>        <span class="va">self</span>.beta <span class="op">=</span> momentum</span>
<span id="cb37-989"><a href="#cb37-989"></a></span>
<span id="cb37-990"><a href="#cb37-990"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb37-991"><a href="#cb37-991"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb37-992"><a href="#cb37-992"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb37-993"><a href="#cb37-993"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb37-994"><a href="#cb37-994"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb37-995"><a href="#cb37-995"></a>            )</span>
<span id="cb37-996"><a href="#cb37-996"></a></span>
<span id="cb37-997"><a href="#cb37-997"></a>    <span class="co"># Update parameters</span></span>
<span id="cb37-998"><a href="#cb37-998"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb37-999"><a href="#cb37-999"></a></span>
<span id="cb37-1000"><a href="#cb37-1000"></a>        <span class="co"># If we use momentum</span></span>
<span id="cb37-1001"><a href="#cb37-1001"></a>        <span class="cf">if</span> <span class="va">self</span>.beta:</span>
<span id="cb37-1002"><a href="#cb37-1002"></a></span>
<span id="cb37-1003"><a href="#cb37-1003"></a>            <span class="co"># If the layer does not contain momentum arrays, create them</span></span>
<span id="cb37-1004"><a href="#cb37-1004"></a>            <span class="co"># filled with zeros</span></span>
<span id="cb37-1005"><a href="#cb37-1005"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(layer, <span class="st">"weight_momentums"</span>):</span>
<span id="cb37-1006"><a href="#cb37-1006"></a>                layer.weight_momentums <span class="op">=</span> np.zeros_like(layer.dloss_dweights)</span>
<span id="cb37-1007"><a href="#cb37-1007"></a>                <span class="co"># If there is no momentumm array for weights</span></span>
<span id="cb37-1008"><a href="#cb37-1008"></a>                <span class="co"># the array doesnt exist for biases yet either</span></span>
<span id="cb37-1009"><a href="#cb37-1009"></a>                layer.bias_momentums <span class="op">=</span> np.zeros_like(layer.dloss_dbiases)</span>
<span id="cb37-1010"><a href="#cb37-1010"></a></span>
<span id="cb37-1011"><a href="#cb37-1011"></a>            <span class="co"># Build weight updates with momentum - take previous</span></span>
<span id="cb37-1012"><a href="#cb37-1012"></a>            <span class="co"># updates multiplied by retain factor and update with</span></span>
<span id="cb37-1013"><a href="#cb37-1013"></a>            <span class="co"># with current gradients</span></span>
<span id="cb37-1014"><a href="#cb37-1014"></a>            <span class="co"># v[t+1] = \beta * v[t] + \alpha * dL/dw</span></span>
<span id="cb37-1015"><a href="#cb37-1015"></a>            weight_updates <span class="op">=</span> (</span>
<span id="cb37-1016"><a href="#cb37-1016"></a>                <span class="va">self</span>.beta <span class="op">*</span> layer.weight_momentums</span>
<span id="cb37-1017"><a href="#cb37-1017"></a>                <span class="op">+</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-1018"><a href="#cb37-1018"></a>            )</span>
<span id="cb37-1019"><a href="#cb37-1019"></a>            layer.weight_momentums <span class="op">=</span> weight_updates</span>
<span id="cb37-1020"><a href="#cb37-1020"></a></span>
<span id="cb37-1021"><a href="#cb37-1021"></a>            <span class="co"># Build bias updates</span></span>
<span id="cb37-1022"><a href="#cb37-1022"></a>            bias_updates <span class="op">=</span> (</span>
<span id="cb37-1023"><a href="#cb37-1023"></a>                <span class="va">self</span>.beta <span class="op">*</span> layer.bias_momentums</span>
<span id="cb37-1024"><a href="#cb37-1024"></a>                <span class="op">+</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-1025"><a href="#cb37-1025"></a>            )</span>
<span id="cb37-1026"><a href="#cb37-1026"></a>            layer.bias_momentums <span class="op">=</span> bias_updates</span>
<span id="cb37-1027"><a href="#cb37-1027"></a>        <span class="cf">else</span>:</span>
<span id="cb37-1028"><a href="#cb37-1028"></a>            <span class="co"># Vanilla SGD updates (as before momentum update)</span></span>
<span id="cb37-1029"><a href="#cb37-1029"></a>            weight_updates <span class="op">=</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-1030"><a href="#cb37-1030"></a>            bias_updates <span class="op">=</span> <span class="va">self</span>.current_learning_rate <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-1031"><a href="#cb37-1031"></a></span>
<span id="cb37-1032"><a href="#cb37-1032"></a>        layer.weights <span class="op">-=</span> weight_updates</span>
<span id="cb37-1033"><a href="#cb37-1033"></a>        layer.biases <span class="op">-=</span> bias_updates</span>
<span id="cb37-1034"><a href="#cb37-1034"></a></span>
<span id="cb37-1035"><a href="#cb37-1035"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb37-1036"><a href="#cb37-1036"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-1037"><a href="#cb37-1037"></a><span class="in">```</span></span>
<span id="cb37-1038"><a href="#cb37-1038"></a></span>
<span id="cb37-1039"><a href="#cb37-1039"></a>Let's see an example illustrating how adding momentum changes the learning process. Keeping the same <span class="in">`learning_rate=1.0`</span> and <span class="in">`decay=1e-3`</span> from the previous training attempt and using a momentum of <span class="in">`0.50`</span>:</span>
<span id="cb37-1040"><a href="#cb37-1040"></a></span>
<span id="cb37-1043"><a href="#cb37-1043"></a><span class="in">```{python}</span></span>
<span id="cb37-1044"><a href="#cb37-1044"></a><span class="kw">def</span> train(decay, momentum):</span>
<span id="cb37-1045"><a href="#cb37-1045"></a>    <span class="co"># Create a dataset</span></span>
<span id="cb37-1046"><a href="#cb37-1046"></a>    X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-1047"><a href="#cb37-1047"></a></span>
<span id="cb37-1048"><a href="#cb37-1048"></a>    <span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb37-1049"><a href="#cb37-1049"></a>    dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb37-1050"><a href="#cb37-1050"></a></span>
<span id="cb37-1051"><a href="#cb37-1051"></a>    <span class="co"># Create ReLU activation (to be used with the dense layer)</span></span>
<span id="cb37-1052"><a href="#cb37-1052"></a>    activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb37-1053"><a href="#cb37-1053"></a></span>
<span id="cb37-1054"><a href="#cb37-1054"></a>    <span class="co"># Create second DenseLayer with 64 input features (as we take output of the</span></span>
<span id="cb37-1055"><a href="#cb37-1055"></a>    <span class="co"># previous layer here) and 3 output values</span></span>
<span id="cb37-1056"><a href="#cb37-1056"></a>    dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb37-1057"><a href="#cb37-1057"></a></span>
<span id="cb37-1058"><a href="#cb37-1058"></a>    <span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb37-1059"><a href="#cb37-1059"></a>    loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb37-1060"><a href="#cb37-1060"></a></span>
<span id="cb37-1061"><a href="#cb37-1061"></a>    <span class="co"># Create optimizer</span></span>
<span id="cb37-1062"><a href="#cb37-1062"></a>    optimizer <span class="op">=</span> SGDOptimizer(learning_rate<span class="op">=</span><span class="fl">1.0</span>,decay<span class="op">=</span>decay,momentum<span class="op">=</span>momentum)</span>
<span id="cb37-1063"><a href="#cb37-1063"></a></span>
<span id="cb37-1064"><a href="#cb37-1064"></a>    acc_vals <span class="op">=</span> []</span>
<span id="cb37-1065"><a href="#cb37-1065"></a>    loss_vals <span class="op">=</span> []</span>
<span id="cb37-1066"><a href="#cb37-1066"></a>    lr_vals <span class="op">=</span> []</span>
<span id="cb37-1067"><a href="#cb37-1067"></a></span>
<span id="cb37-1068"><a href="#cb37-1068"></a>    <span class="co"># Train in a loop</span></span>
<span id="cb37-1069"><a href="#cb37-1069"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb37-1070"><a href="#cb37-1070"></a>        <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb37-1071"><a href="#cb37-1071"></a>        dense1.forward(X)</span>
<span id="cb37-1072"><a href="#cb37-1072"></a></span>
<span id="cb37-1073"><a href="#cb37-1073"></a>        <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb37-1074"><a href="#cb37-1074"></a>        <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb37-1075"><a href="#cb37-1075"></a>        activation1.forward(dense1.output)</span>
<span id="cb37-1076"><a href="#cb37-1076"></a></span>
<span id="cb37-1077"><a href="#cb37-1077"></a>        <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb37-1078"><a href="#cb37-1078"></a>        <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb37-1079"><a href="#cb37-1079"></a>        dense2.forward(activation1.output)</span>
<span id="cb37-1080"><a href="#cb37-1080"></a></span>
<span id="cb37-1081"><a href="#cb37-1081"></a>        <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb37-1082"><a href="#cb37-1082"></a>        <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb37-1083"><a href="#cb37-1083"></a>        loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb37-1084"><a href="#cb37-1084"></a></span>
<span id="cb37-1085"><a href="#cb37-1085"></a>        <span class="co"># Calculate accuracy from output of activation2 and targets</span></span>
<span id="cb37-1086"><a href="#cb37-1086"></a>        <span class="co"># Calculate values along the first axis</span></span>
<span id="cb37-1087"><a href="#cb37-1087"></a>        predictions <span class="op">=</span> np.argmax(loss_activation.output, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-1088"><a href="#cb37-1088"></a>        <span class="cf">if</span> <span class="bu">len</span>(y.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb37-1089"><a href="#cb37-1089"></a>            y <span class="op">=</span> np.argmax(y, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-1090"><a href="#cb37-1090"></a></span>
<span id="cb37-1091"><a href="#cb37-1091"></a>        accuracy <span class="op">=</span> np.mean(predictions <span class="op">==</span> y)</span>
<span id="cb37-1092"><a href="#cb37-1092"></a></span>
<span id="cb37-1093"><a href="#cb37-1093"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb37-1094"><a href="#cb37-1094"></a>            <span class="bu">print</span>(</span>
<span id="cb37-1095"><a href="#cb37-1095"></a>                <span class="ss">f"epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1096"><a href="#cb37-1096"></a><span class="ss">                acc : </span><span class="sc">{</span>accuracy<span class="sc">:.3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1097"><a href="#cb37-1097"></a><span class="ss">                loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1098"><a href="#cb37-1098"></a><span class="ss">                lr : </span><span class="sc">{</span>optimizer<span class="sc">.</span>current_learning_rate<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb37-1099"><a href="#cb37-1099"></a>            )</span>
<span id="cb37-1100"><a href="#cb37-1100"></a></span>
<span id="cb37-1101"><a href="#cb37-1101"></a>        acc_vals.append(accuracy)</span>
<span id="cb37-1102"><a href="#cb37-1102"></a>        loss_vals.append(loss)</span>
<span id="cb37-1103"><a href="#cb37-1103"></a>        lr_vals.append(optimizer.current_learning_rate)</span>
<span id="cb37-1104"><a href="#cb37-1104"></a></span>
<span id="cb37-1105"><a href="#cb37-1105"></a>        <span class="co"># Backward pass</span></span>
<span id="cb37-1106"><a href="#cb37-1106"></a>        loss_activation.backward(loss_activation.output, y)</span>
<span id="cb37-1107"><a href="#cb37-1107"></a>        dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb37-1108"><a href="#cb37-1108"></a>        activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb37-1109"><a href="#cb37-1109"></a>        dense1.backward(activation1.dloss_dz)</span>
<span id="cb37-1110"><a href="#cb37-1110"></a></span>
<span id="cb37-1111"><a href="#cb37-1111"></a>        <span class="co"># Update the weights and the biases</span></span>
<span id="cb37-1112"><a href="#cb37-1112"></a>        optimizer.pre_update_params()</span>
<span id="cb37-1113"><a href="#cb37-1113"></a>        optimizer.update_params(dense1)</span>
<span id="cb37-1114"><a href="#cb37-1114"></a>        optimizer.update_params(dense2)</span>
<span id="cb37-1115"><a href="#cb37-1115"></a>        optimizer.post_update_params()</span>
<span id="cb37-1116"><a href="#cb37-1116"></a></span>
<span id="cb37-1117"><a href="#cb37-1117"></a>    <span class="cf">return</span> acc_vals, loss_vals, lr_vals</span>
<span id="cb37-1118"><a href="#cb37-1118"></a><span class="in">```</span></span>
<span id="cb37-1119"><a href="#cb37-1119"></a></span>
<span id="cb37-1122"><a href="#cb37-1122"></a><span class="in">```{python}</span></span>
<span id="cb37-1123"><a href="#cb37-1123"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb37-1124"><a href="#cb37-1124"></a><span class="in">```</span></span>
<span id="cb37-1125"><a href="#cb37-1125"></a></span>
<span id="cb37-1126"><a href="#cb37-1126"></a>The model achieved the lowest loss and the highest accuracy that we've seen so far. Can we do better? Sure, we can! Let's try to set the momentum to $0.9$:</span>
<span id="cb37-1127"><a href="#cb37-1127"></a></span>
<span id="cb37-1130"><a href="#cb37-1130"></a><span class="in">```{python}</span></span>
<span id="cb37-1131"><a href="#cb37-1131"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb37-1132"><a href="#cb37-1132"></a><span class="in">```</span></span>
<span id="cb37-1133"><a href="#cb37-1133"></a></span>
<span id="cb37-1134"><a href="#cb37-1134"></a><span class="fu">## AdaGrad</span></span>
<span id="cb37-1135"><a href="#cb37-1135"></a></span>
<span id="cb37-1136"><a href="#cb37-1136"></a>In real-world datasets, some input features are sparse and some features are dense. If we use the same learning rate $\alpha$ for all the weights, parameters associated with sparse features receive meaningful updates only when these features occur. Given a decreasing learning rate, we might end up with a situation where parameters for dense features converge rather quickly to their optimal values, whereas for sparse features, we are still short of observing them sufficiently frequently before their optimal values can be determined. In other words, the learning rate decreases too slowly for dense features and too quickly for sparse features. </span>
<span id="cb37-1137"><a href="#cb37-1137"></a></span>
<span id="cb37-1138"><a href="#cb37-1138"></a>The update rule for adaptive step-size gradient descent is:</span>
<span id="cb37-1139"><a href="#cb37-1139"></a></span>
<span id="cb37-1140"><a href="#cb37-1140"></a>\begin{align*}</span>
<span id="cb37-1141"><a href="#cb37-1141"></a>\mathbf{g}_t &amp;= \frac{\partial \mathcal L}{\partial \mathbf{w}}<span class="sc">\\</span></span>
<span id="cb37-1142"><a href="#cb37-1142"></a>\mathbf{s}_t &amp;= \mathbf{s}_{t-1} + \mathbf{g}_{t}^2 <span class="sc">\\</span></span>
<span id="cb37-1143"><a href="#cb37-1143"></a>\mathbf{w}_t &amp;= \mathbf{w}_{t-1} + \frac{\alpha}{\sqrt{\mathbf{s}_t+\epsilon}}\cdot \mathbf{g}_t</span>
<span id="cb37-1144"><a href="#cb37-1144"></a>\end{align*}</span>
<span id="cb37-1145"><a href="#cb37-1145"></a></span>
<span id="cb37-1146"><a href="#cb37-1146"></a>Here the operations are applied coordinate-wise. So, the jacobian $\mathbf{g}_t^2$ has entries $g_t^2$. As before, $\alpha$ is the learning rate and $\epsilon$ is an additive constant that ensures that we do not divide by $0$. Thus, the learning rate for features whose weights receive frequent updates is decreased faster, whilst for those features, whose weights receive infrequent updates, it is decreased slower.</span>
<span id="cb37-1147"><a href="#cb37-1147"></a></span>
<span id="cb37-1148"><a href="#cb37-1148"></a>Thus, Adagrad decreases the learning-rate dynamically on a per-coordinate basis.  </span>
<span id="cb37-1149"><a href="#cb37-1149"></a></span>
<span id="cb37-1152"><a href="#cb37-1152"></a><span class="in">```{python}</span></span>
<span id="cb37-1153"><a href="#cb37-1153"></a><span class="kw">class</span> AdagradOptimizer:</span>
<span id="cb37-1154"><a href="#cb37-1154"></a></span>
<span id="cb37-1155"><a href="#cb37-1155"></a>    <span class="co"># Initial optimizer - set settings</span></span>
<span id="cb37-1156"><a href="#cb37-1156"></a>    <span class="co"># learning rate of 1. is default for this optimizer</span></span>
<span id="cb37-1157"><a href="#cb37-1157"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, learning_rate<span class="op">=</span><span class="fl">1.0</span>, decay<span class="op">=</span><span class="fl">0.0</span>, epsilon<span class="op">=</span><span class="fl">1e-7</span>):</span>
<span id="cb37-1158"><a href="#cb37-1158"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-1159"><a href="#cb37-1159"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-1160"><a href="#cb37-1160"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb37-1161"><a href="#cb37-1161"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-1162"><a href="#cb37-1162"></a>        <span class="va">self</span>.epsilon <span class="op">=</span> epsilon</span>
<span id="cb37-1163"><a href="#cb37-1163"></a></span>
<span id="cb37-1164"><a href="#cb37-1164"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb37-1165"><a href="#cb37-1165"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb37-1166"><a href="#cb37-1166"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb37-1167"><a href="#cb37-1167"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb37-1168"><a href="#cb37-1168"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb37-1169"><a href="#cb37-1169"></a>            )</span>
<span id="cb37-1170"><a href="#cb37-1170"></a></span>
<span id="cb37-1171"><a href="#cb37-1171"></a>    <span class="co"># Update parameters</span></span>
<span id="cb37-1172"><a href="#cb37-1172"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb37-1173"><a href="#cb37-1173"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(layer, <span class="st">"weight_cache"</span>):</span>
<span id="cb37-1174"><a href="#cb37-1174"></a>            layer.weight_cache <span class="op">=</span> np.zeros_like(layer.weights)</span>
<span id="cb37-1175"><a href="#cb37-1175"></a>            layer.bias_cache <span class="op">=</span> np.zeros_like(layer.biases)</span>
<span id="cb37-1176"><a href="#cb37-1176"></a></span>
<span id="cb37-1177"><a href="#cb37-1177"></a>        <span class="co"># Update cache with squared current gradients</span></span>
<span id="cb37-1178"><a href="#cb37-1178"></a>        layer.weight_cache <span class="op">+=</span> layer.dloss_dweights<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-1179"><a href="#cb37-1179"></a>        layer.bias_cache <span class="op">+=</span> layer.dloss_dbiases<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-1180"><a href="#cb37-1180"></a></span>
<span id="cb37-1181"><a href="#cb37-1181"></a>        <span class="co"># Vanilla SGD parameter update + normalization</span></span>
<span id="cb37-1182"><a href="#cb37-1182"></a>        <span class="co"># with square rooted cache</span></span>
<span id="cb37-1183"><a href="#cb37-1183"></a>        layer.weights <span class="op">+=</span> (</span>
<span id="cb37-1184"><a href="#cb37-1184"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb37-1185"><a href="#cb37-1185"></a>            <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-1186"><a href="#cb37-1186"></a>            <span class="op">/</span> (np.sqrt(layer.weight_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb37-1187"><a href="#cb37-1187"></a>        )</span>
<span id="cb37-1188"><a href="#cb37-1188"></a>        layer.biases <span class="op">+=</span> (</span>
<span id="cb37-1189"><a href="#cb37-1189"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb37-1190"><a href="#cb37-1190"></a>            <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-1191"><a href="#cb37-1191"></a>            <span class="op">/</span> (np.sqrt(layer.bias_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb37-1192"><a href="#cb37-1192"></a>        )</span>
<span id="cb37-1193"><a href="#cb37-1193"></a></span>
<span id="cb37-1194"><a href="#cb37-1194"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb37-1195"><a href="#cb37-1195"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-1196"><a href="#cb37-1196"></a><span class="in">```</span></span>
<span id="cb37-1197"><a href="#cb37-1197"></a></span>
<span id="cb37-1198"><a href="#cb37-1198"></a><span class="fu">## RMSProp</span></span>
<span id="cb37-1199"><a href="#cb37-1199"></a></span>
<span id="cb37-1200"><a href="#cb37-1200"></a>One of the key issues of Adagrad is that the learning rate decreases at a predefined schedule essentially at a rate proportional $\frac{1}{\sqrt{t}}$. While this is generally appropriate for convex problems, it might not be ideal for nonconvex ones, such as those encountered in deep learning. Yet, the coordinate-wise adaptivity of Adagrad is highly desirable as a preconditioner. </span>
<span id="cb37-1201"><a href="#cb37-1201"></a></span>
<span id="cb37-1202"><a href="#cb37-1202"></a>Tieleman and Hinton(<span class="co">[</span><span class="ot">2012</span><span class="co">](https://www.d2l.ai/chapter_references/zreferences.html#id284)</span>) have proposed the RMSProp algorithm as a simple fix to decouple the rate scheduling from coordinate adaptive learning rates. The issue is that the squares of the gradient $\mathbf{g}_t$ keeps accumulating into the state vector $\mathbf{s}_t = \mathbf{s}_{t-1} + \mathbf{g}_t^2$. As a result, $\mathbf{s}_t$ keeps on growing without bounds, essentially linearly as the algorithm converges.</span>
<span id="cb37-1203"><a href="#cb37-1203"></a></span>
<span id="cb37-1204"><a href="#cb37-1204"></a><span class="fu">### The Algorithm</span></span>
<span id="cb37-1205"><a href="#cb37-1205"></a></span>
<span id="cb37-1206"><a href="#cb37-1206"></a>The update rule for the RMSProp algorithm is as follows:</span>
<span id="cb37-1207"><a href="#cb37-1207"></a></span>
<span id="cb37-1208"><a href="#cb37-1208"></a>\begin{align*}</span>
<span id="cb37-1209"><a href="#cb37-1209"></a>\mathbf{s}_t &amp;= \gamma \mathbf{s}_{t-1} + (1- \gamma)\mathbf{g}_t^2<span class="sc">\\</span></span>
<span id="cb37-1210"><a href="#cb37-1210"></a>\mathbf{x}_t &amp;= \mathbf{x}_{t-1} - \frac{\alpha}{\sqrt{\mathbf{s}_t + \epsilon}}\odot \mathbf{g}_t</span>
<span id="cb37-1211"><a href="#cb37-1211"></a>\end{align*}</span>
<span id="cb37-1212"><a href="#cb37-1212"></a></span>
<span id="cb37-1213"><a href="#cb37-1213"></a>We are now in a position to implement an <span class="in">`RMSPropOptimizer`</span> class:</span>
<span id="cb37-1214"><a href="#cb37-1214"></a></span>
<span id="cb37-1217"><a href="#cb37-1217"></a><span class="in">```{python}</span></span>
<span id="cb37-1218"><a href="#cb37-1218"></a><span class="kw">class</span> RMSPropOptimizer:</span>
<span id="cb37-1219"><a href="#cb37-1219"></a></span>
<span id="cb37-1220"><a href="#cb37-1220"></a>    <span class="co"># Initialize</span></span>
<span id="cb37-1221"><a href="#cb37-1221"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb37-1222"><a href="#cb37-1222"></a>        <span class="va">self</span>,</span>
<span id="cb37-1223"><a href="#cb37-1223"></a>        learning_rate: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.001</span>,</span>
<span id="cb37-1224"><a href="#cb37-1224"></a>        decay: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.0</span>,</span>
<span id="cb37-1225"><a href="#cb37-1225"></a>        epsilon: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-7</span>,</span>
<span id="cb37-1226"><a href="#cb37-1226"></a>        rho: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span id="cb37-1227"><a href="#cb37-1227"></a>    ):</span>
<span id="cb37-1228"><a href="#cb37-1228"></a>        <span class="va">self</span>.learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-1229"><a href="#cb37-1229"></a>        <span class="va">self</span>.current_learning_rate <span class="op">=</span> learning_rate</span>
<span id="cb37-1230"><a href="#cb37-1230"></a>        <span class="va">self</span>.decay <span class="op">=</span> decay</span>
<span id="cb37-1231"><a href="#cb37-1231"></a>        <span class="va">self</span>.iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-1232"><a href="#cb37-1232"></a>        <span class="va">self</span>.epsilon <span class="op">=</span> epsilon</span>
<span id="cb37-1233"><a href="#cb37-1233"></a>        <span class="va">self</span>.rho <span class="op">=</span> rho</span>
<span id="cb37-1234"><a href="#cb37-1234"></a></span>
<span id="cb37-1235"><a href="#cb37-1235"></a>    <span class="co"># Call once before any parameter updates</span></span>
<span id="cb37-1236"><a href="#cb37-1236"></a>    <span class="kw">def</span> pre_update_params(<span class="va">self</span>):</span>
<span id="cb37-1237"><a href="#cb37-1237"></a>        <span class="cf">if</span> <span class="va">self</span>.decay:</span>
<span id="cb37-1238"><a href="#cb37-1238"></a>            <span class="va">self</span>.current_learning_rate <span class="op">=</span> <span class="va">self</span>.learning_rate <span class="op">*</span> (</span>
<span id="cb37-1239"><a href="#cb37-1239"></a>                <span class="fl">1.0</span> <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">+</span> <span class="va">self</span>.decay <span class="op">*</span> <span class="va">self</span>.iterations)</span>
<span id="cb37-1240"><a href="#cb37-1240"></a>            )</span>
<span id="cb37-1241"><a href="#cb37-1241"></a></span>
<span id="cb37-1242"><a href="#cb37-1242"></a>    <span class="kw">def</span> update_params(<span class="va">self</span>, layer):</span>
<span id="cb37-1243"><a href="#cb37-1243"></a></span>
<span id="cb37-1244"><a href="#cb37-1244"></a>        <span class="co"># If layer does not contain cache arrays,</span></span>
<span id="cb37-1245"><a href="#cb37-1245"></a>        <span class="co"># create them filled with zeros</span></span>
<span id="cb37-1246"><a href="#cb37-1246"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(layer, <span class="st">"weight_cache"</span>):</span>
<span id="cb37-1247"><a href="#cb37-1247"></a>            layer.weight_cache <span class="op">=</span> np.zeros_like(layer.dloss_dweights)</span>
<span id="cb37-1248"><a href="#cb37-1248"></a>            layer.bias_cache <span class="op">=</span> np.zeros_like(layer.dloss_dbiases)</span>
<span id="cb37-1249"><a href="#cb37-1249"></a></span>
<span id="cb37-1250"><a href="#cb37-1250"></a>        <span class="co"># Update cache with squared current gradients</span></span>
<span id="cb37-1251"><a href="#cb37-1251"></a>        layer.weight_cache <span class="op">=</span> (</span>
<span id="cb37-1252"><a href="#cb37-1252"></a>            <span class="va">self</span>.rho <span class="op">*</span> layer.weight_cache <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.rho) <span class="op">*</span> layer.dloss_dweights<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-1253"><a href="#cb37-1253"></a>        )</span>
<span id="cb37-1254"><a href="#cb37-1254"></a>        layer.bias_cache <span class="op">=</span> (</span>
<span id="cb37-1255"><a href="#cb37-1255"></a>            <span class="va">self</span>.rho <span class="op">*</span> layer.bias_cache <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.rho) <span class="op">*</span> layer.dloss_dbiases<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-1256"><a href="#cb37-1256"></a>        )</span>
<span id="cb37-1257"><a href="#cb37-1257"></a></span>
<span id="cb37-1258"><a href="#cb37-1258"></a>        <span class="co"># Vanilla SGD parameter update + normalization</span></span>
<span id="cb37-1259"><a href="#cb37-1259"></a>        <span class="co"># with square rooted cache</span></span>
<span id="cb37-1260"><a href="#cb37-1260"></a>        layer.weights <span class="op">-=</span> (</span>
<span id="cb37-1261"><a href="#cb37-1261"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb37-1262"><a href="#cb37-1262"></a>            <span class="op">*</span> layer.dloss_dweights</span>
<span id="cb37-1263"><a href="#cb37-1263"></a>            <span class="op">/</span> (np.sqrt(layer.weight_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb37-1264"><a href="#cb37-1264"></a>        )</span>
<span id="cb37-1265"><a href="#cb37-1265"></a>        layer.biases <span class="op">-=</span> (</span>
<span id="cb37-1266"><a href="#cb37-1266"></a>            <span class="va">self</span>.current_learning_rate</span>
<span id="cb37-1267"><a href="#cb37-1267"></a>            <span class="op">*</span> layer.dloss_dbiases</span>
<span id="cb37-1268"><a href="#cb37-1268"></a>            <span class="op">/</span> (np.sqrt(layer.bias_cache) <span class="op">+</span> <span class="va">self</span>.epsilon)</span>
<span id="cb37-1269"><a href="#cb37-1269"></a>        )</span>
<span id="cb37-1270"><a href="#cb37-1270"></a></span>
<span id="cb37-1271"><a href="#cb37-1271"></a>    <span class="kw">def</span> post_update_params(<span class="va">self</span>):</span>
<span id="cb37-1272"><a href="#cb37-1272"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb37-1273"><a href="#cb37-1273"></a><span class="in">```</span></span>
<span id="cb37-1274"><a href="#cb37-1274"></a></span>
<span id="cb37-1275"><a href="#cb37-1275"></a>Changing the optimizer in our main neural network <span class="in">`training`</span> function, we have:</span>
<span id="cb37-1276"><a href="#cb37-1276"></a></span>
<span id="cb37-1279"><a href="#cb37-1279"></a><span class="in">```{python}</span></span>
<span id="cb37-1280"><a href="#cb37-1280"></a><span class="co"># | code-fold: true</span></span>
<span id="cb37-1281"><a href="#cb37-1281"></a><span class="co"># | code-summary: "Show the code"</span></span>
<span id="cb37-1282"><a href="#cb37-1282"></a><span class="kw">def</span> train(decay):</span>
<span id="cb37-1283"><a href="#cb37-1283"></a>    <span class="co"># Create a dataset</span></span>
<span id="cb37-1284"><a href="#cb37-1284"></a>    X, y <span class="op">=</span> spiral_data(samples<span class="op">=</span><span class="dv">100</span>, classes<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb37-1285"><a href="#cb37-1285"></a></span>
<span id="cb37-1286"><a href="#cb37-1286"></a>    <span class="co"># Create a dense layer with 2 input features and 64 output values</span></span>
<span id="cb37-1287"><a href="#cb37-1287"></a>    dense1 <span class="op">=</span> DenseLayer(<span class="dv">2</span>, <span class="dv">64</span>)</span>
<span id="cb37-1288"><a href="#cb37-1288"></a></span>
<span id="cb37-1289"><a href="#cb37-1289"></a>    <span class="co"># Create ReLU activation (to be used with the dense layer)</span></span>
<span id="cb37-1290"><a href="#cb37-1290"></a>    activation1 <span class="op">=</span> ReLUActivation()</span>
<span id="cb37-1291"><a href="#cb37-1291"></a></span>
<span id="cb37-1292"><a href="#cb37-1292"></a>    <span class="co"># Create second DenseLayer with 64 input features (as we take output of the</span></span>
<span id="cb37-1293"><a href="#cb37-1293"></a>    <span class="co"># previous layer here) and 3 output values</span></span>
<span id="cb37-1294"><a href="#cb37-1294"></a>    dense2 <span class="op">=</span> DenseLayer(<span class="dv">64</span>, <span class="dv">3</span>)</span>
<span id="cb37-1295"><a href="#cb37-1295"></a></span>
<span id="cb37-1296"><a href="#cb37-1296"></a>    <span class="co"># Create Softmax classifier's combined loss and activation</span></span>
<span id="cb37-1297"><a href="#cb37-1297"></a>    loss_activation <span class="op">=</span> CategoricalCrossEntropySoftmax()</span>
<span id="cb37-1298"><a href="#cb37-1298"></a></span>
<span id="cb37-1299"><a href="#cb37-1299"></a>    <span class="co"># Create optimizer</span></span>
<span id="cb37-1300"><a href="#cb37-1300"></a>    optimizer <span class="op">=</span> RMSPropOptimizer(learning_rate<span class="op">=</span><span class="fl">1.0</span>,decay<span class="op">=</span>decay)</span>
<span id="cb37-1301"><a href="#cb37-1301"></a></span>
<span id="cb37-1302"><a href="#cb37-1302"></a>    acc_vals <span class="op">=</span> []</span>
<span id="cb37-1303"><a href="#cb37-1303"></a>    loss_vals <span class="op">=</span> []</span>
<span id="cb37-1304"><a href="#cb37-1304"></a>    lr_vals <span class="op">=</span> []</span>
<span id="cb37-1305"><a href="#cb37-1305"></a></span>
<span id="cb37-1306"><a href="#cb37-1306"></a>    <span class="co"># Train in a loop</span></span>
<span id="cb37-1307"><a href="#cb37-1307"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10001</span>):</span>
<span id="cb37-1308"><a href="#cb37-1308"></a>        <span class="co"># Perform a forward pass of our training data through this layer</span></span>
<span id="cb37-1309"><a href="#cb37-1309"></a>        dense1.forward(X)</span>
<span id="cb37-1310"><a href="#cb37-1310"></a></span>
<span id="cb37-1311"><a href="#cb37-1311"></a>        <span class="co"># Perform a forward pass through the activation function</span></span>
<span id="cb37-1312"><a href="#cb37-1312"></a>        <span class="co"># takes the output of the first dense layer here</span></span>
<span id="cb37-1313"><a href="#cb37-1313"></a>        activation1.forward(dense1.output)</span>
<span id="cb37-1314"><a href="#cb37-1314"></a></span>
<span id="cb37-1315"><a href="#cb37-1315"></a>        <span class="co"># Perform a forward pass through second DenseLayer</span></span>
<span id="cb37-1316"><a href="#cb37-1316"></a>        <span class="co"># takes the outputs of the activation function of first layer as inputs</span></span>
<span id="cb37-1317"><a href="#cb37-1317"></a>        dense2.forward(activation1.output)</span>
<span id="cb37-1318"><a href="#cb37-1318"></a></span>
<span id="cb37-1319"><a href="#cb37-1319"></a>        <span class="co"># Perform a forward pass through the activation/loss function</span></span>
<span id="cb37-1320"><a href="#cb37-1320"></a>        <span class="co"># takes the output of the second DenseLayer here and returns the loss</span></span>
<span id="cb37-1321"><a href="#cb37-1321"></a>        loss <span class="op">=</span> loss_activation.forward(dense2.output, y)</span>
<span id="cb37-1322"><a href="#cb37-1322"></a></span>
<span id="cb37-1323"><a href="#cb37-1323"></a>        <span class="co"># Calculate accuracy from output of activation2 and targets</span></span>
<span id="cb37-1324"><a href="#cb37-1324"></a>        <span class="co"># Calculate values along the first axis</span></span>
<span id="cb37-1325"><a href="#cb37-1325"></a>        predictions <span class="op">=</span> np.argmax(loss_activation.output, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-1326"><a href="#cb37-1326"></a>        <span class="cf">if</span> <span class="bu">len</span>(y.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb37-1327"><a href="#cb37-1327"></a>            y <span class="op">=</span> np.argmax(y, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-1328"><a href="#cb37-1328"></a></span>
<span id="cb37-1329"><a href="#cb37-1329"></a>        accuracy <span class="op">=</span> np.mean(predictions <span class="op">==</span> y)</span>
<span id="cb37-1330"><a href="#cb37-1330"></a></span>
<span id="cb37-1331"><a href="#cb37-1331"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb37-1332"><a href="#cb37-1332"></a>            <span class="bu">print</span>(</span>
<span id="cb37-1333"><a href="#cb37-1333"></a>                <span class="ss">f"epoch: </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1334"><a href="#cb37-1334"></a><span class="ss">                acc : </span><span class="sc">{</span>accuracy<span class="sc">:.3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1335"><a href="#cb37-1335"></a><span class="ss">                loss: </span><span class="sc">{</span>loss<span class="sc">: .3f}</span><span class="ss">, </span><span class="ch">\</span></span>
<span id="cb37-1336"><a href="#cb37-1336"></a><span class="ss">                lr : </span><span class="sc">{</span>optimizer<span class="sc">.</span>current_learning_rate<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb37-1337"><a href="#cb37-1337"></a>            )</span>
<span id="cb37-1338"><a href="#cb37-1338"></a></span>
<span id="cb37-1339"><a href="#cb37-1339"></a>        acc_vals.append(accuracy)</span>
<span id="cb37-1340"><a href="#cb37-1340"></a>        loss_vals.append(loss)</span>
<span id="cb37-1341"><a href="#cb37-1341"></a>        lr_vals.append(optimizer.current_learning_rate)</span>
<span id="cb37-1342"><a href="#cb37-1342"></a></span>
<span id="cb37-1343"><a href="#cb37-1343"></a>        <span class="co"># Backward pass</span></span>
<span id="cb37-1344"><a href="#cb37-1344"></a>        loss_activation.backward(loss_activation.output, y)</span>
<span id="cb37-1345"><a href="#cb37-1345"></a>        dense2.backward(loss_activation.dloss_dz)</span>
<span id="cb37-1346"><a href="#cb37-1346"></a>        activation1.backward(dense2.dloss_dinputs)</span>
<span id="cb37-1347"><a href="#cb37-1347"></a>        dense1.backward(activation1.dloss_dz)</span>
<span id="cb37-1348"><a href="#cb37-1348"></a></span>
<span id="cb37-1349"><a href="#cb37-1349"></a>        <span class="co"># Update the weights and the biases</span></span>
<span id="cb37-1350"><a href="#cb37-1350"></a>        optimizer.pre_update_params()</span>
<span id="cb37-1351"><a href="#cb37-1351"></a>        optimizer.update_params(dense1)</span>
<span id="cb37-1352"><a href="#cb37-1352"></a>        optimizer.update_params(dense2)</span>
<span id="cb37-1353"><a href="#cb37-1353"></a>        optimizer.post_update_params()</span>
<span id="cb37-1354"><a href="#cb37-1354"></a></span>
<span id="cb37-1355"><a href="#cb37-1355"></a>    <span class="cf">return</span> acc_vals, loss_vals, lr_vals</span>
<span id="cb37-1356"><a href="#cb37-1356"></a><span class="in">```</span></span>
<span id="cb37-1357"><a href="#cb37-1357"></a></span>
<span id="cb37-1360"><a href="#cb37-1360"></a><span class="in">```{python}</span></span>
<span id="cb37-1361"><a href="#cb37-1361"></a>acc_vals, loss_vals, lr_vals <span class="op">=</span> train(decay<span class="op">=</span><span class="fl">1e-4</span>)</span>
<span id="cb37-1362"><a href="#cb37-1362"></a><span class="in">```</span></span>
<span id="cb37-1363"><a href="#cb37-1363"></a></span>
<span id="cb37-1364"><a href="#cb37-1364"></a><span class="fu">## Adam</span></span>
<span id="cb37-1365"><a href="#cb37-1365"></a></span>
<span id="cb37-1366"><a href="#cb37-1366"></a>In the discussions leading up to this section, we encountered a number of techniques for efficient optimization. Let's recap them here in detail :</span>
<span id="cb37-1367"><a href="#cb37-1367"></a></span>
<span id="cb37-1368"><a href="#cb37-1368"></a><span class="ss">- </span>We saw that SGD reduces the computational cost from $O(n)$ to $O(1)$ for each independent iteration compared to gradient descent.</span>
<span id="cb37-1369"><a href="#cb37-1369"></a></span>
<span id="cb37-1370"><a href="#cb37-1370"></a><span class="ss">- </span>Momentum adds a mechanism for aggregating the history of past gradients to converge. </span>
<span id="cb37-1371"><a href="#cb37-1371"></a></span>
<span id="cb37-1372"><a href="#cb37-1372"></a><span class="ss">- </span>Adagrad used a per-coordinate scaling to allow for allow for different learning rates. The learning rate for weights related to sparse features decreases slower than the learning rate for weights related to dense features.</span>
<span id="cb37-1373"><a href="#cb37-1373"></a></span>
<span id="cb37-1374"><a href="#cb37-1374"></a><span class="ss">- </span>RMSProp decoupled per-coordinate scaling from a learning rate adjustment.</span>
<span id="cb37-1375"><a href="#cb37-1375"></a></span>
<span id="cb37-1376"><a href="#cb37-1376"></a>Adam combines all these techniques into one efficient learning algorithm. As expected, this is an algorithm that has become rather popular as one of the more robust and effective optimization algorithms to use in deep learning. It is not without issues, though. In particular, there are situations where Adam can diverge due to poor variance control. </span>
<span id="cb37-1377"><a href="#cb37-1377"></a></span>
<span id="cb37-1378"><a href="#cb37-1378"></a><span class="fu">### The Algorithm</span></span>
<span id="cb37-1379"><a href="#cb37-1379"></a></span>
<span id="cb37-1380"><a href="#cb37-1380"></a>One of the key components of Adam is that is uses exponentially weighted moving averages (also known as leaky averaging) to obtain an estimate of both the momentum and also the second moment of the gradient. That is, it uses the state variables:</span>
<span id="cb37-1381"><a href="#cb37-1381"></a></span>
<span id="cb37-1382"><a href="#cb37-1382"></a>\begin{align*}</span>
<span id="cb37-1383"><a href="#cb37-1383"></a>\mathbf{v}_t &amp;= \beta_1 \mathbf{v}_{t-1} + (1-\beta_1)\mathbf{g}_t<span class="sc">\\</span></span>
<span id="cb37-1384"><a href="#cb37-1384"></a>\mathbf{s}_{t} &amp;= \beta_2 \mathbf{v}_{t-1} + (1 - \beta_2)\mathbf{g}_t^2</span>
<span id="cb37-1385"><a href="#cb37-1385"></a>\end{align*}</span>
<span id="cb37-1386"><a href="#cb37-1386"></a></span>
<span id="cb37-1387"><a href="#cb37-1387"></a>Here $\beta_1$ and $\beta_2$ are nonnegative weighting parameters. Common choices for them are $\beta_1=0.9$ and $\beta_2=0.999$. That is, the variance estimate moves much more slowly than the momentum term. Note that, </span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>