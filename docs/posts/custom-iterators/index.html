<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-05-05">

<title>quantdev.blog - Custom iterators and Iterator concepts</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Custom iterators and Iterator concepts</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 5, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#traditional-c-iterators" id="toc-traditional-c-iterators" class="nav-link" data-scroll-target="#traditional-c-iterators">Traditional C++ iterators</a></li>
  <li><a href="#modern-c-iterators" id="toc-modern-c-iterators" class="nav-link" data-scroll-target="#modern-c-iterators">Modern C++ iterators</a>
  <ul class="collapse">
  <li><a href="#stdinput_or_output_iterator" id="toc-stdinput_or_output_iterator" class="nav-link" data-scroll-target="#stdinput_or_output_iterator"><code>std::input_or_output_iterator</code></a></li>
  <li><a href="#stdoutput_iterator" id="toc-stdoutput_iterator" class="nav-link" data-scroll-target="#stdoutput_iterator"><code>std::output_iterator</code></a></li>
  <li><a href="#stdinput_iterator" id="toc-stdinput_iterator" class="nav-link" data-scroll-target="#stdinput_iterator"><code>std::input_iterator</code></a></li>
  <li><a href="#stdforward_iterator" id="toc-stdforward_iterator" class="nav-link" data-scroll-target="#stdforward_iterator"><code>std::forward_iterator</code></a></li>
  <li><a href="#stdbidirectional_iterator" id="toc-stdbidirectional_iterator" class="nav-link" data-scroll-target="#stdbidirectional_iterator"><code>std::bidirectional_iterator</code></a></li>
  </ul></li>
  
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>An iterator is a generalization of a pointer. C++ STL containers usually expose iterators as part of their interface. They abstract away lower-level implementation details of traversing through container types, thus freeing the container-user to focus on algorithm design/business logic.</p>
</section>
<section id="traditional-c-iterators" class="level1">
<h1>Traditional C++ iterators</h1>
<p>Iterators have been around since before C++11, but they really hit mainstream since C++11 started shipping. The STL containers all implement their own iterators, however, it’s possible for developers to write their own iterators for custom collections.</p>
<p>In the past, you’d implement iterators using <a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">tagging</a>. A tag is simply an empty struct, with no data or behavior. It is often used to perform static dispatching (compile-time polymorphism). Here is a minimalistic example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">namespace</span> dev<span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">struct</span> random_access_iterator_tag<span class="op">{};</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="kw">struct</span> forward_iterator_tag<span class="op">{};</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="kw">struct</span> vector<span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        T<span class="op">*</span> <span class="va">m_data</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        <span class="bu">std::</span>size_t<span class="op"> </span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        <span class="bu">std::</span>size_t<span class="op"> </span><span class="va">m_capacity</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>        </span>
<span id="cb1-13"><a href="#cb1-13"></a>        <span class="kw">struct</span> iterator<span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>            <span class="kw">using</span> iterator_category <span class="op">=</span> random_access_iterator_tag<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>            <span class="co">/* .... */</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>            T<span class="op">*</span> <span class="va">m_ptr</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>        <span class="op">};</span></span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>        iterator begin<span class="op">(){</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>            <span class="cf">return</span><span class="op">(</span>iterator<span class="op">(</span><span class="va">m_data</span><span class="op">));</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="op">};</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="kw">struct</span> list<span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        <span class="kw">struct</span> node<span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>            T data<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            node<span class="op">*</span> next<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>        <span class="op">};</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>        node<span class="op">*</span> head<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>        <span class="bu">std::</span>size_t<span class="op"> </span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>        <span class="kw">struct</span> iterator<span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>            <span class="kw">using</span> iterator_category <span class="op">=</span> forward_iterator_tag<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>            <span class="co">/* .... */</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>            node<span class="op">*</span> <span class="va">m_ptr</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>        <span class="op">};</span></span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a>        iterator begin<span class="op">(){</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>            <span class="cf">return</span><span class="op">(</span>iterator<span class="op">(</span>head<span class="op">));</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>        <span class="op">}</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="op">};</span></span>
<span id="cb1-43"><a href="#cb1-43"></a></span>
<span id="cb1-44"><a href="#cb1-44"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>    It advance<span class="op">(</span>It iterator<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>n<span class="op">,</span> forward_iterator_tag<span class="op">){</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span> <span class="op">&lt;&lt;</span> <span class="st">"Advance a foward iterator"</span><span class="op">;</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>        <span class="cf">return</span> iterator<span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>    <span class="op">}</span></span>
<span id="cb1-49"><a href="#cb1-49"></a></span>
<span id="cb1-50"><a href="#cb1-50"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>    It advance<span class="op">(</span>It iterator<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>n<span class="op">,</span> random_access_iterator_tag<span class="op">){</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span> <span class="op">&lt;&lt;</span> <span class="st">"Advance a random access iterator"</span><span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53"></a>        <span class="cf">return</span> iterator<span class="op">;</span></span>
<span id="cb1-54"><a href="#cb1-54"></a>    <span class="op">}</span></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="op">}</span></span>
<span id="cb1-56"><a href="#cb1-56"></a></span>
<span id="cb1-57"><a href="#cb1-57"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-58"><a href="#cb1-58"></a>    dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">;</span></span>
<span id="cb1-59"><a href="#cb1-59"></a>    dev<span class="op">::</span>list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lst<span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>    <span class="kw">auto</span> it <span class="op">=</span> vec<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>    dev<span class="op">::</span>advance<span class="op">(</span>it<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">::</span>iterator_category<span class="op">());</span></span>
<span id="cb1-63"><a href="#cb1-63"></a></span>
<span id="cb1-64"><a href="#cb1-64"></a>    <span class="kw">auto</span> it2 <span class="op">=</span> lst<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>    dev<span class="op">::</span>advance<span class="op">(</span>it2<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> dev<span class="op">::</span>list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">::</span>iterator_category<span class="op">());</span></span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/q7YGG8oj5">Compiler Explorer</a></p>
<p>An iterator over a custom array-like sequence of elements would look like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">struct</span> Iterator <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">using</span> iterator_category <span class="op">=</span> <span class="bu">std::</span>forward_iterator_tag<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">using</span> <span class="dt">difference_type</span> <span class="op">=</span> <span class="bu">std::</span>ptrdiff_t<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">using</span> pointer <span class="op">=</span> T<span class="op">*;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">using</span> reference <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="co">// ...rest of iterator implementation here</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This requires you to write a lot of boiler-plate code. While tagging works, it puts an extra-burden on the developer.</p>
</section>
<section id="modern-c-iterators" class="level1">
<h1>Modern C++ iterators</h1>
<p>C++20 has a language feature called <a href="https://quantdev.blog/posts/c++20-concepts/index.html">concepts</a> - a set of named constaints that a type should satisfy. So, we can now implement iterators based on their behavior, rather than their <em>identity</em>. This is often referred to as <strong>duck typing</strong>: the idea that <em>if an entity looks like a duck and quacks like a duck, it must be a duck.</em></p>
<p>A new system of iterators based on concepts has been introduced.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/input_iterator"><code>std::input_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/output_iterator"><code>std::output_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator"><code>std::forward_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator"><code>std::birdirectional_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator"><code>std::random_access_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/contiguous_iterator"><code>std::contiguous_iterator</code></a></li>
</ul>
<p>Before we deep-dive into these iterator concepts, let’s understand <a href="https://en.cppreference.com/w/cpp/iterator/sentinel_for"><code>std::sentinel_for</code></a> concept.</p>
<p>A sentinel signals the end of a sequence of values. Prior to C++20, when traversing a collection, the way you’d check if you’ve hit the end of the collection was to compare your current iterator with an <code>end()</code> iterator.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include</span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="co">// Traverse a std::vector</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">{</span>v<span class="op">.</span>begin<span class="op">()};</span> it<span class="op">!=</span>v<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">){</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="op">*</span>it <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Usually, this end iterator was just a case of your normal iterator that had some internal state identifying it as one past the last element of the container.</p>
<p>Beginning C++20, you can actually use any type as a sentinel for an iterator so long as the type satisfies the <code>std::sentinel_for</code> concept. <code>std::sentinel_for</code> concept requires</p>
<section id="stdinput_or_output_iterator" class="level2">
<h2 class="anchored" data-anchor-id="stdinput_or_output_iterator"><code>std::input_or_output_iterator</code></h2>
<p>The <code>input_or_output_iterator</code> is the basis of the iterator concept taxonomy. It only requires that an iterator type <code>It</code> supports the operations for dereferencing and incrementing the iterator.</p>
</section>
<section id="stdoutput_iterator" class="level2">
<h2 class="anchored" data-anchor-id="stdoutput_iterator"><code>std::output_iterator</code></h2>
<p><code>std::output_iterator</code> concept models the idea of a write-only iterator. E.g. such an iterator can be used to write to the standard output stream. Hence, they can only be dereferenced on the left-hand side of an assignment operator.</p>
<p>Since, they are single pass, we don’t even need to implement an equality comparison operator, because they don’t have an end iterator or sentinel value to compare against.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;concepts&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">struct</span> SimpleOutputIterator <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">using</span> <span class="dt">difference_type</span> <span class="op">=</span> <span class="bu">std::</span>ptrdiff_t<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="kw">using</span> pointer <span class="op">=</span> T<span class="op">*;</span></span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a>    pointer <span class="va">m_buffer_ptr</span><span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="co">// Default constructor</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    SimpleOutputIterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a></span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="co">// Constructor</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    SimpleOutputIterator<span class="op">(</span>pointer start<span class="op">)</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>        <span class="op">:</span> <span class="va">m_buffer_ptr</span><span class="op">{</span>start<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="co">// Dereference operator</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>    T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*()</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>        <span class="cf">return</span> <span class="op">*</span><span class="va">m_buffer_ptr</span><span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24"></a></span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span class="co">// Pre-increment</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>    SimpleOutputIterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>        <span class="op">++</span><span class="va">m_buffer_ptr</span><span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>        <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a>    <span class="co">// Post-increment</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>    SimpleOutputIterator <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>        <span class="kw">auto</span> tmp <span class="op">=</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>        <span class="op">++(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>        <span class="cf">return</span> tmp<span class="op">;</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>    <span class="op">}</span></span>
<span id="cb4-37"><a href="#cb4-37"></a></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="op">};</span></span>
<span id="cb4-39"><a href="#cb4-39"></a></span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>output_iterator<span class="op">&lt;</span>SimpleOutputIterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb4-41"><a href="#cb4-41"></a></span>
<span id="cb4-42"><a href="#cb4-42"></a></span>
<span id="cb4-43"><a href="#cb4-43"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb4-44"><a href="#cb4-44"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-45"><a href="#cb4-45"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/nEEh35q45">Compiler Explorer</a></p>
</section>
<section id="stdinput_iterator" class="level2">
<h2 class="anchored" data-anchor-id="stdinput_iterator"><code>std::input_iterator</code></h2>
<p><code>std::input_iterator</code> concept models the idea of a read-only iterator. Such an iterator, for example, can be used read packets data from a network socket.</p>
<p>Input iterators are also single-pass, because once you’ve read a byte of data from a network socket, you can’t read it again. They must also be comparable to some sentinel value such as <code>EOF</code>, <code>\0</code>, to signal the end of data etc.</p>
<p>However, the equality comparison operator <code>bool operator==(It, Sen)</code> is only used by the algorithm operating on the container, and therefore it’s the responsibility of the algorithm writer to supply an implementation of <code>bool operator==(It, Sen)</code>. This definition is not required in the container implementation.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;concepts&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">struct</span> SimpleInputIterator <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="kw">using</span> <span class="dt">difference_type</span> <span class="op">=</span> <span class="bu">std::</span>ptrdiff_t<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="kw">using</span> pointer <span class="op">=</span> T<span class="op">*;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="kw">using</span> reference <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>    pointer <span class="va">m_socket_fd</span><span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="co">// Default constructor</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>    SimpleInputIterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="co">// Constructor</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    SimpleInputIterator<span class="op">(</span>pointer start<span class="op">)</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>        <span class="op">:</span> <span class="va">m_socket_fd</span><span class="op">{</span>start<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="co">// Dereference operator</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>    <span class="at">const</span> T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>        <span class="cf">return</span> <span class="op">*</span><span class="va">m_socket_fd</span><span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>    <span class="op">}</span></span>
<span id="cb5-25"><a href="#cb5-25"></a></span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span class="co">// Pre-increment</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>    SimpleInputIterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>        <span class="op">++</span><span class="va">m_socket_fd</span><span class="op">;</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>        <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31"></a></span>
<span id="cb5-32"><a href="#cb5-32"></a>    <span class="co">// Post-increment</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>    SimpleInputIterator <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>        <span class="kw">auto</span> tmp <span class="op">=</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>        <span class="op">++(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>        <span class="cf">return</span> tmp<span class="op">;</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span class="op">}</span></span>
<span id="cb5-38"><a href="#cb5-38"></a></span>
<span id="cb5-39"><a href="#cb5-39"></a><span class="op">};</span></span>
<span id="cb5-40"><a href="#cb5-40"></a></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>input_iterator<span class="op">&lt;</span>SimpleInputIterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb5-42"><a href="#cb5-42"></a></span>
<span id="cb5-43"><a href="#cb5-43"></a></span>
<span id="cb5-44"><a href="#cb5-44"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-46"><a href="#cb5-46"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/4ocGnaaPM">Compiler Explorer</a></p>
</section>
<section id="stdforward_iterator" class="level2">
<h2 class="anchored" data-anchor-id="stdforward_iterator"><code>std::forward_iterator</code></h2>
<p><code>std::forward_iterator</code> requires that the iterator type be an input (read-only) iterator and also be <a href="https://en.cppreference.com/w/cpp/iterator/incrementable">std::incrementable</a>.</p>
<p><code>std::input_iterator</code> only requires the iterator be <code>std::weakly_incrementable</code>. So while it supports the increment <code>operator++()</code>, if <code>i</code> and <code>j</code> are two instances of the iterator type <code>It</code>, <code>i == j</code> does not imply <code>++i == ++j</code>. That is, algorithms on weakly-incrementable types must be single-pass algorithms.</p>
<p><code>std::incrementable</code> concept informally means that <code>i == j</code> <span class="math inline">\(\implies\)</span> <code>++i == ++j</code>. Algorithms on incrementable types are multi-pass algorithms.</p>
<p>You might use an iterator satisfying <code>std::forward_iterator</code> concept to traverse through a <code>std::forward_list</code> (a singly linked-list).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;iterator&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;concepts&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">struct</span> list_node <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    T <span class="va">m_data</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    list_node<span class="op">*</span> <span class="va">m_next</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">};</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">struct</span> SimpleForwardIterator <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="kw">using</span> <span class="dt">difference_type</span> <span class="op">=</span> <span class="bu">std::</span>ptrdiff_t<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span> <span class="co">// The value type is T, not list_node&lt;T&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="kw">using</span> pointer <span class="op">=</span> T<span class="op">*;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">using</span> reference <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>    list_node<span class="op">&lt;</span>T<span class="op">&gt;*</span> <span class="va">m_node_ptr</span><span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span class="co">// Default constructor</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>    SimpleForwardIterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="co">// Constructor</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>    SimpleForwardIterator<span class="op">(</span>list_node<span class="op">&lt;</span>T<span class="op">&gt;*</span> start<span class="op">)</span></span>
<span id="cb6-25"><a href="#cb6-25"></a>        <span class="op">:</span> <span class="va">m_node_ptr</span><span class="op">{</span>start<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb6-26"><a href="#cb6-26"></a></span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="co">// Dereference operator</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>    reference <span class="kw">operator</span><span class="op">*()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>        <span class="cf">return</span> <span class="va">m_node_ptr</span><span class="op">-&gt;</span><span class="va">m_data</span><span class="op">;</span> <span class="co">// Return the data stored in the node</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>    <span class="op">}</span></span>
<span id="cb6-31"><a href="#cb6-31"></a></span>
<span id="cb6-32"><a href="#cb6-32"></a>    <span class="co">// Pre-increment</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>    SimpleForwardIterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span></span>
<span id="cb6-34"><a href="#cb6-34"></a>        <span class="va">m_node_ptr</span> <span class="op">=</span> <span class="va">m_node_ptr</span><span class="op">-&gt;</span><span class="va">m_next</span><span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="op">}</span></span>
<span id="cb6-37"><a href="#cb6-37"></a></span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="co">// Post-increment</span></span>
<span id="cb6-39"><a href="#cb6-39"></a>    SimpleForwardIterator <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>        <span class="kw">auto</span> tmp <span class="op">=</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>        <span class="op">++(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>        <span class="cf">return</span> tmp<span class="op">;</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>    <span class="op">}</span></span>
<span id="cb6-44"><a href="#cb6-44"></a></span>
<span id="cb6-45"><a href="#cb6-45"></a>    <span class="co">// Equality comparison</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> SimpleForwardIterator<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>        <span class="cf">return</span> <span class="va">m_node_ptr</span> <span class="op">==</span> other<span class="op">.</span><span class="va">m_node_ptr</span><span class="op">;</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="op">}</span></span>
<span id="cb6-49"><a href="#cb6-49"></a></span>
<span id="cb6-50"><a href="#cb6-50"></a>    <span class="co">// Inequality comparison</span></span>
<span id="cb6-51"><a href="#cb6-51"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span><span class="at">const</span> SimpleForwardIterator<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb6-52"><a href="#cb6-52"></a>        <span class="cf">return</span> <span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> other<span class="op">);</span></span>
<span id="cb6-53"><a href="#cb6-53"></a>    <span class="op">}</span></span>
<span id="cb6-54"><a href="#cb6-54"></a><span class="op">};</span></span>
<span id="cb6-55"><a href="#cb6-55"></a></span>
<span id="cb6-56"><a href="#cb6-56"></a><span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>forward_iterator<span class="op">&lt;</span>SimpleForwardIterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb6-57"><a href="#cb6-57"></a></span>
<span id="cb6-58"><a href="#cb6-58"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-59"><a href="#cb6-59"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-60"><a href="#cb6-60"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/edEr4oedn">Compiler Explorer</a></p>
</section>
<section id="stdbidirectional_iterator" class="level2">
<h2 class="anchored" data-anchor-id="stdbidirectional_iterator"><code>std::bidirectional_iterator</code></h2>
<p>A <code>std::list</code> is a doubly linked that supports both traversals in the forward as well as reverse direction. When we want to be able to move forward and backwards across our collection, we must implement an iterator satisfying <code>std::bidirectional_iterator</code> concept.</p>
<p>You need to implement pre-increment, post-increment, pre-decrement and post-decrement operations.</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="references" class="level1 appendix"><h2 class="anchored quarto-appendix-heading">References</h2><div class="quarto-appendix-contents">

<ul>
<li><a href="https://hitchcock.codes/blog/cpp-iterators-in-depth">cpp iterators in depth</a> by Braden Hitchcock.</li>
</ul>


</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>