<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-01-31">

<title>quantdev.blog - C++ Ranges</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././symbol.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">C++ Ranges</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 31, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#c-ranges" id="toc-c-ranges" class="nav-link active" data-scroll-target="#c-ranges">C++ Ranges</a>
  <ul class="collapse">
  <li><a href="#what-is-a-range" id="toc-what-is-a-range" class="nav-link" data-scroll-target="#what-is-a-range">What is a range?</a></li>
  <li><a href="#understanding-range-concepts-and-views" id="toc-understanding-range-concepts-and-views" class="nav-link" data-scroll-target="#understanding-range-concepts-and-views">Understanding range concepts and views</a></li>
  <li><a href="#understanding-the-constrained-algorithms" id="toc-understanding-the-constrained-algorithms" class="nav-link" data-scroll-target="#understanding-the-constrained-algorithms">Understanding the constrained algorithms</a></li>
  <li><a href="#writing-your-own-range-adaptor" id="toc-writing-your-own-range-adaptor" class="nav-link" data-scroll-target="#writing-your-own-range-adaptor">Writing your own range adaptor</a></li>
  </ul></li>
  
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="c-ranges" class="level1">
<h1>C++ Ranges</h1>
<section id="what-is-a-range" class="level2">
<h2 class="anchored" data-anchor-id="what-is-a-range">What is a range?</h2>
<p>A <strong>range</strong> is a programmatic abstraction for a sequence of elements, bounded by two iterators(one to the first element of the sequence and one to the last element).</p>
<p>Containers such as <code>std::vector</code>, <code>std::list</code> and <code>std::map</code> are concrete implementations of the range abstraction. The standard algorithms are generic. They are container agnostic. They know nothing about <code>std::vector</code>, <code>std::map</code> or <code>std::list</code>. They handle range abstractions with the help of a pair of iterators. However, this has a shortcoming: we always need a <code>begin()</code> and <code>end()</code> iterator from a container. Here are some examples:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">// sort a vector</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">// count the even numbers of an array</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;</span>a<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">auto</span> even_count <span class="op">=</span> <span class="bu">std::</span>count_if<span class="op">(</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    a<span class="op">.</span>begin<span class="op">(),</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    a<span class="op">.</span>end<span class="op">(),</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="op">[](</span><span class="dt">int</span> <span class="at">const</span> n<span class="op">){</span> <span class="cf">return</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are few cases when we only need to process a part of the container’s elements. In the vast majority of the cases, we need to write <code>v.begin()</code> and <code>v.end()</code> over and over again. Ideally, we would prefer to shorten all this and be able to write the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// sort a vector</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">// count the even numbers of an array</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;</span>a<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">auto</span> even_count <span class="op">=</span> <span class="bu">std::</span>count_if<span class="op">(</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    a<span class="op">.</span>begin<span class="op">(),</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    a<span class="op">.</span>end<span class="op">(),</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="op">[](</span><span class="dt">int</span> <span class="at">const</span> n<span class="op">){</span> <span class="cf">return</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On the other hand, we often need to compose multiple operations together. Most of the time that involves many operations and code that is too verbose even when using standard algorithms. Consider the following example: given a sequence of integers, we want to print to the console the square of all even numbers, except the first two, in descending order of their value (not their position in the sequence). There are multiple ways to solve this problem. Here is one possible solution:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">// copy only the even elements</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> temp<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="bu">std::</span>copy_if<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>temp<span class="op">),</span> <span class="op">[](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="cf">return</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="op">});</span></span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">// sort the elements</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="bu">std::</span>sort<span class="op">(</span>temp<span class="op">.</span>begin<span class="op">(),</span> temp<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span> <span class="cf">return</span> a <span class="op">&gt;</span> b<span class="op">;</span> <span class="op">});</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">// remove the first two</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>temp<span class="op">.</span>erase<span class="op">(</span>temp<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> temp<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> temp<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">// transform the elements</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="bu">std::</span>transform<span class="op">(</span>temp<span class="op">.</span>begin<span class="op">(),</span> temp<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="dt">int</span> <span class="at">const</span> n<span class="op">){</span> <span class="cf">return</span> n<span class="op">*</span>n<span class="op">;</span> <span class="op">});</span></span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">// print each element</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="bu">std::</span>for_each<span class="op">(</span>temp<span class="op">.</span>begin<span class="op">(),</span> temp<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="dt">int</span> n<span class="op">){</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, n"</span><span class="op">);</span> <span class="op">});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>While anyone familiar with standard algorithms can read this code, there are several downsides. Its a lot of code to write and also requires a temporary container with repetitive calls to <code>begin()</code> and <code>end()</code>. All of the computation is done eagerly, so the intermediate results of each step are held in memory.</p>
<p>Most people would easily understand the following version of the previous code and also prefer to write it as such:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">using</span> <span class="bu">std::</span>ranges<span class="op"> =</span> stdr<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">using</span> <span class="bu">std::</span>ranges<span class="bu">::</span>views<span class="op"> =</span> stdv<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>stdr<span class="op">::</span>sort<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">auto</span> r <span class="op">=</span> v  <span class="op">|</span> filter<span class="op">([](</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">})</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>            <span class="op">|</span> drop<span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>            <span class="op">|</span> reverse</span>
<span id="cb4-11"><a href="#cb4-11"></a>            <span class="op">|</span> transform<span class="op">([](</span><span class="dt">int</span> n<span class="op">){</span> <span class="cf">return</span> n<span class="op">*</span>n<span class="op">;</span> <span class="op">});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is what the C++20 standard provides with the help of the ranges library. This has two main components:</p>
<ul>
<li><strong>Range algorithms</strong>, which enable us to operate on concrete ranges (standard containers or ranges) and not on abstract ranges delimited by a pair of iterators</li>
<li><strong>Views or range adapters</strong>, which represent non-owning iterable sequences. They enable us to compose operations more easily such as in the last example.</li>
</ul>
</section>
<section id="understanding-range-concepts-and-views" class="level2">
<h2 class="anchored" data-anchor-id="understanding-range-concepts-and-views">Understanding range concepts and views</h2>
<p>The term <em>range</em> refers to an abstraction that defines a sequence of elements bounded by start and end iterators. A range, therefore, represents an iterable sequence of elements. However, such a sequence can be defined in several ways:</p>
<ul>
<li>With a <code>begin</code> iterator and an <code>end</code> sentinel. Such a sequence is iterated from beginning to the end. A <strong>sentinel</strong> is an object that indicates the end of the sequence. It can have the same type as the iuterator type or it can be of a differnt type.</li>
<li>With a start object and a size(number of elements), representing a so-called counted sequence. Such a sequence is iterated <span class="math inline">\(N\)</span> times (where $N represents the size) from the start.</li>
<li>With a start and a predicate, representing a so-called conditionally termninated sequence. Such a sequence is iterated from the start until the predicate returns false.</li>
<li>With only a start value, representing a so-called unbounded sequence. Such a sequence can be iterated indefinitely.</li>
</ul>
<p>All these kinds of iterable sequences are considered ranges. Because a range is an abstraction, the C++20 library defines a series a of concepts to describe the requirements for range types. These are available in the <code>&lt;ranges&gt;</code> header and the <code>std::ranges</code> namespace. The following table presents a list of range concepts:</p>
<table class="table">
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>range</code></td>
<td>Defines the requires for a type <code>R</code> to be a range by provdiding a begin iterator and an end sentinel. The iterator and the sentinel can be of different types.</td>
</tr>
<tr class="even">
<td><code>borrowed_range</code></td>
<td>Defines the requirements for a type <code>R</code> so that a function can take an object of this type by value and return iterators obtained from this object without the danger of dangling.</td>
</tr>
<tr class="odd">
<td><code>sized_range</code></td>
<td>Defines the requirements for a type <code>R</code> to be a range that knows its size in constant time.</td>
</tr>
<tr class="even">
<td><code>common_range</code></td>
<td>Defines the requirements for a type <code>R</code> to be a range whose iterator and sentinel types are equal.</td>
</tr>
<tr class="odd">
<td><code>view</code></td>
<td>Defines the requirements of type <code>R</code> that is a range to have constant-time, copy, move and assignment opertions.</td>
</tr>
<tr class="even">
<td><code>viewable_range</code></td>
<td>Defines the requirements for a range type <code>R</code> to be convertible to a view.</td>
</tr>
</tbody>
</table>
<p>Other range concepts such as <code>input_range</code>, <code>output_range</code>, <code>forward_range</code>, <code>bidirectional_range</code>, <code>random_access_range</code>, <code>contiguous_range</code> are modeled after the corresponding iterator concepts.</p>
<p>A <strong>view</strong> is a lightweight object that applies the transformation only when a new element is requested(iterated) and not hen the view is created. Its key feature is <strong>lazy evaluation</strong>. It is like a stream. So, views are lightweight objects, with non-owning semantics. They don’t own the underlying data.</p>
<p>There is a series of views provided with C++20 and new views have also been included in C++23. Views are available by including the <code>&lt;ranges&gt;</code> header under the <code>std::ranges</code> namespace, for example, <code>std::ranges::iota_view</code>.</p>
<p>The <code>iota</code> view is part of a special category of views called <strong>factories</strong>. These factories are views over newly generated ranges. The following factories are available in the ranges library:</p>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 34%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ranges::empty_view</code></td>
<td><code>ranges::views::empty</code></td>
<td>Generates a view with no elements of <code>T</code> type</td>
</tr>
<tr class="even">
<td><code>ranges::single_view</code></td>
<td><code>ranges::views::single</code></td>
<td>Generates a view with a single element of a <code>T</code> type</td>
</tr>
<tr class="odd">
<td><code>ranges::iota_view</code></td>
<td><code>ranges::views::iota</code></td>
<td>Generates a view of a sequence of consecutive elements, from a start value to an end value (a bounded view) or indefinitely (an unbounded view)</td>
</tr>
<tr class="even">
<td><code>ranges::basic_iostream_view</code></td>
<td><code>ranges::views::istream</code></td>
<td>Generates a view of the sequence of elements by applying the operator <code>&gt;&gt;</code> repeatedly</td>
</tr>
</tbody>
</table>
<p>Here is a quick example for using <code>iota</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// using iota_view</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">namespace</span> stdr <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">namespace</span> stdv <span class="op">=</span> <span class="bu">std::</span>views<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> stdr<span class="op">::</span>iota_view<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">10</span><span class="op">))</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, "</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">// using stdv::iota</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> stdv<span class="op">::</span>iota<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">10</span><span class="op">))</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, "</span><span class="op">,</span> i<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you are wondering why <code>empty_view</code> and <code>single_view</code> are useful, the answer should not be hard to find. These are useful in template code that handles ranges where empty ranges or ranges with one element are valid inputs. you don’t want multiple overloads of a function template for handling these special cases; instead, you can pass an <code>empty_view</code> or <code>single_view</code> range. The following snippets show several examples of using these factories.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">// namespace alias</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">namespace</span> stdr <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">namespace</span> stdv <span class="op">=</span> <span class="bu">std::</span>views<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="kw">constexpr</span> stdr<span class="op">::</span>empty_view<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ev<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">static_assert</span><span class="op">(</span>stdr<span class="op">::</span>empty<span class="op">(</span>ev<span class="op">));</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="kw">static_assert</span><span class="op">(</span>stdr<span class="op">::</span>size<span class="op">(</span>ev<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="kw">static_assert</span><span class="op">(</span>stdr<span class="op">::</span>data<span class="op">(</span>ev<span class="op">)</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="kw">constexpr</span> stdr<span class="op">::</span>single_view<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sv<span class="op">{</span><span class="dv">42</span><span class="op">};</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">static_assert</span><span class="op">(!</span>stdr<span class="op">::</span>empty<span class="op">(</span>sv<span class="op">));</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="kw">static_assert</span><span class="op">(</span>stdr<span class="op">::</span>size<span class="op">(</span>sv<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="kw">static_assert</span><span class="op">(*</span>stdr<span class="op">::</span>data<span class="op">(</span>sv<span class="op">)</span> <span class="op">==</span> <span class="dv">42</span><span class="op">);</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/o1Mo7KGqc">Compiler Explorer</a></p>
<p>For the <code>iota_view</code>, we have already seen a couple of examples with a bounded view. The next snippet shows again an example not only using a bounded view generated with <code>iota</code> but also an unbounded view, also generated with <code>iota</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">namespace</span> stdr <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">namespace</span> stdv <span class="op">=</span> <span class="bu">std::</span>views<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="kw">auto</span> v1 <span class="op">=</span> stdv<span class="op">::</span>iota<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    stdr<span class="op">::</span>for_each<span class="op">(</span>v1<span class="op">,[](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="op">});</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="kw">auto</span> v2 <span class="op">=</span>   stdv<span class="op">::</span>iota<span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>                <span class="op">|</span> stdv<span class="op">::</span>take<span class="op">(</span><span class="dv">9</span><span class="op">);</span></span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a>    stdr<span class="op">::</span>for_each<span class="op">(</span>v2<span class="op">,[](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="op">});</span>                </span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/6cErPYW78">Compiler Explorer</a></p>
<p>The last example utilizes another view called <code>take_view</code>. This produces a view of the first <span class="math inline">\(N\)</span> elements (in my example <span class="math inline">\(9\)</span>) of another view (in my example, the unbounded view produced by <code>iota</code>). I will discuss more on this shortly.</p>
<p>There are other standard views that I implore you to check out on <a href="https://en.cppreference.com/w/cpp/ranges.html#Range_adaptors">cppreference.com</a>. I tried out a few toy examples below:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="kw">namespace</span> stdr <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="kw">namespace</span> stdv <span class="op">=</span> <span class="bu">std::</span>views<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="dt">void</span> print<span class="op">(</span><span class="kw">auto</span> data<span class="op">,</span> <span class="bu">std::</span>string_view<span class="op"> </span>label<span class="op">){</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span> <span class="op">&lt;&lt;</span> label <span class="op">&lt;&lt;</span> <span class="st">": "</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    stdr<span class="op">::</span>for_each<span class="op">(</span>data<span class="op">,[](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>        <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, "</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="op">});</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19"></a></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="kw">auto</span> data <span class="op">=</span> stdr<span class="op">::</span>iota_view<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">9</span><span class="op">);</span></span>
<span id="cb8-22"><a href="#cb8-22"></a></span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="co">// filter_view </span></span>
<span id="cb8-24"><a href="#cb8-24"></a>    <span class="co">// Only include elements satisfying a predicate</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    <span class="kw">auto</span> filter_data <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>filter<span class="op">([](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>        <span class="cf">return</span> n <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>    <span class="op">});</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>    print<span class="op">(</span>filter_data<span class="op">,</span> <span class="st">"filter"</span><span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29"></a></span>
<span id="cb8-30"><a href="#cb8-30"></a>    <span class="co">// transform_view</span></span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="co">// Applies a mapping element-wise</span></span>
<span id="cb8-32"><a href="#cb8-32"></a>    <span class="kw">auto</span> squares <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>transform<span class="op">([](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb8-33"><a href="#cb8-33"></a>        <span class="cf">return</span> n <span class="op">*</span> n<span class="op">;</span></span>
<span id="cb8-34"><a href="#cb8-34"></a>    <span class="op">});</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>    print<span class="op">(</span>squares<span class="op">,</span> <span class="st">"squares"</span><span class="op">);</span></span>
<span id="cb8-36"><a href="#cb8-36"></a></span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="co">// take_view</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>    <span class="co">// Grab the first N elements</span></span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="kw">auto</span> first_ten <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>take<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb8-40"><a href="#cb8-40"></a>    print<span class="op">(</span>first_ten<span class="op">,</span> <span class="st">"first_ten"</span><span class="op">);</span></span>
<span id="cb8-41"><a href="#cb8-41"></a></span>
<span id="cb8-42"><a href="#cb8-42"></a>    <span class="co">// take_while_view</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>    <span class="co">// Grab all elements starting with the first</span></span>
<span id="cb8-44"><a href="#cb8-44"></a>    <span class="co">// until an element is found that no longer </span></span>
<span id="cb8-45"><a href="#cb8-45"></a>    <span class="co">// satisfies the predicate</span></span>
<span id="cb8-46"><a href="#cb8-46"></a>    <span class="kw">auto</span> take_while_rslt <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>take_while<span class="op">([](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb8-47"><a href="#cb8-47"></a>        <span class="cf">return</span> n <span class="op">&lt;=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb8-48"><a href="#cb8-48"></a>    <span class="op">});</span></span>
<span id="cb8-49"><a href="#cb8-49"></a>    print<span class="op">(</span>take_while_rslt<span class="op">,</span> <span class="st">"take_while_rslt"</span><span class="op">);</span></span>
<span id="cb8-50"><a href="#cb8-50"></a></span>
<span id="cb8-51"><a href="#cb8-51"></a>    <span class="co">// drop_view </span></span>
<span id="cb8-52"><a href="#cb8-52"></a>    <span class="co">// skip the first N elements</span></span>
<span id="cb8-53"><a href="#cb8-53"></a>    <span class="kw">auto</span> drop_rslt <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>drop<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb8-54"><a href="#cb8-54"></a>    print<span class="op">(</span>drop_rslt<span class="op">,</span> <span class="st">"drop_rslt"</span><span class="op">);</span></span>
<span id="cb8-55"><a href="#cb8-55"></a></span>
<span id="cb8-56"><a href="#cb8-56"></a>    <span class="co">// drop_while_view</span></span>
<span id="cb8-57"><a href="#cb8-57"></a>    <span class="co">// skip elements until predicate is not met</span></span>
<span id="cb8-58"><a href="#cb8-58"></a>    <span class="kw">auto</span> drop_while_rslt <span class="op">=</span> data <span class="op">|</span> stdv<span class="op">::</span>drop_while<span class="op">([](</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb8-59"><a href="#cb8-59"></a>        <span class="cf">return</span> n <span class="op">&lt;=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb8-60"><a href="#cb8-60"></a>    <span class="op">});</span></span>
<span id="cb8-61"><a href="#cb8-61"></a>    print<span class="op">(</span>drop_while_rslt<span class="op">,</span> <span class="st">"drop_while_rslt"</span><span class="op">);</span></span>
<span id="cb8-62"><a href="#cb8-62"></a></span>
<span id="cb8-63"><a href="#cb8-63"></a>    <span class="co">// join_view</span></span>
<span id="cb8-64"><a href="#cb8-64"></a>    <span class="co">// Provides a view of a sequence generated by</span></span>
<span id="cb8-65"><a href="#cb8-65"></a>    <span class="co">// flattening multiple ranges</span></span>
<span id="cb8-66"><a href="#cb8-66"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals<span class="op">;</span></span>
<span id="cb8-67"><a href="#cb8-67"></a>    <span class="kw">auto</span> strings <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-68"><a href="#cb8-68"></a>        <span class="st">"C++ "</span><span class="bu">sv</span><span class="op">,</span> <span class="st">"is "</span><span class="bu">sv</span><span class="op">,</span> <span class="st">"a "</span><span class="bu">sv</span><span class="op">,</span> <span class="st">"general-purpose "</span><span class="bu">sv</span><span class="op">,</span></span>
<span id="cb8-69"><a href="#cb8-69"></a>        <span class="st">"and "</span><span class="bu">sv</span><span class="op">,</span> <span class="st">"multi-paradigm "</span><span class="bu">sv</span><span class="op">,</span> <span class="st">"programming "</span><span class="bu">sv</span><span class="op">,</span></span>
<span id="cb8-70"><a href="#cb8-70"></a>        <span class="st">"language"</span><span class="bu">sv</span></span>
<span id="cb8-71"><a href="#cb8-71"></a>        <span class="op">};</span></span>
<span id="cb8-72"><a href="#cb8-72"></a>    <span class="kw">auto</span> join_result <span class="op">=</span> stdv<span class="op">::</span>join<span class="op">(</span>strings<span class="op">);</span></span>
<span id="cb8-73"><a href="#cb8-73"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span> <span class="op">&lt;&lt;</span> <span class="st">"join_result: "</span><span class="op">;</span></span>
<span id="cb8-74"><a href="#cb8-74"></a>    <span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="dt">char</span> c<span class="op">:</span> join_result<span class="op">)</span></span>
<span id="cb8-75"><a href="#cb8-75"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> c<span class="op">;</span></span>
<span id="cb8-76"><a href="#cb8-76"></a></span>
<span id="cb8-77"><a href="#cb8-77"></a>    <span class="co">// join_with_view</span></span>
<span id="cb8-78"><a href="#cb8-78"></a>    <span class="co">// Provides a view of a sequence generated by </span></span>
<span id="cb8-79"><a href="#cb8-79"></a>    <span class="co">// flattening multiple ranges with a delimiter </span></span>
<span id="cb8-80"><a href="#cb8-80"></a>    <span class="co">// inserted between the elements of the view.</span></span>
<span id="cb8-81"><a href="#cb8-81"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> rngs <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">}};</span></span>
<span id="cb8-82"><a href="#cb8-82"></a>    <span class="kw">auto</span> join_with_rslt <span class="op">=</span> rngs <span class="op">|</span> stdv<span class="op">::</span>join_with<span class="op">(</span><span class="ch">','</span><span class="op">);</span></span>
<span id="cb8-83"><a href="#cb8-83"></a>    </span>
<span id="cb8-84"><a href="#cb8-84"></a>    <span class="co">// split_view</span></span>
<span id="cb8-85"><a href="#cb8-85"></a>    <span class="co">// Provides view of a sequence of ranges produced</span></span>
<span id="cb8-86"><a href="#cb8-86"></a>    <span class="co">// by splitting a range on a specified delimiter.</span></span>
<span id="cb8-87"><a href="#cb8-87"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> words<span class="op">{</span><span class="st">"Hey,^_^C++^_^23^_^ranges^_^are^_^awesome!"</span><span class="bu">sv</span><span class="op">};</span></span>
<span id="cb8-88"><a href="#cb8-88"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> delim<span class="op">{</span><span class="st">"^_^"</span><span class="bu">sv</span><span class="op">};</span></span>
<span id="cb8-89"><a href="#cb8-89"></a>    <span class="kw">auto</span> split_rslt <span class="op">=</span> words <span class="op">|</span> stdv<span class="op">::</span>split<span class="op">(</span>delim<span class="op">);</span></span>
<span id="cb8-90"><a href="#cb8-90"></a></span>
<span id="cb8-91"><a href="#cb8-91"></a>    <span class="co">// reverse_view</span></span>
<span id="cb8-92"><a href="#cb8-92"></a>    <span class="co">// Provides a view of the elements of the </span></span>
<span id="cb8-93"><a href="#cb8-93"></a>    <span class="co">// underlying range in reverse order</span></span>
<span id="cb8-94"><a href="#cb8-94"></a>    <span class="kw">auto</span> reverse_rslt <span class="op">=</span> stdv<span class="op">::</span>reverse<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb8-95"><a href="#cb8-95"></a>    print<span class="op">(</span>reverse_rslt<span class="op">,</span> <span class="st">"reverse_rslt"</span><span class="op">);</span></span>
<span id="cb8-96"><a href="#cb8-96"></a></span>
<span id="cb8-97"><a href="#cb8-97"></a>    <span class="co">// keys_view, values_view and elements_view </span></span>
<span id="cb8-98"><a href="#cb8-98"></a>    <span class="co">// Provide a view by projecting the first, </span></span>
<span id="cb8-99"><a href="#cb8-99"></a>    <span class="co">// second and nth element respectively</span></span>
<span id="cb8-100"><a href="#cb8-100"></a>    <span class="co">// from a range of tuples.</span></span>
<span id="cb8-101"><a href="#cb8-101"></a>    <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;&gt;</span> quark_mass_charge</span>
<span id="cb8-102"><a href="#cb8-102"></a>    <span class="op">{</span></span>
<span id="cb8-103"><a href="#cb8-103"></a>        <span class="co">// name, MeV/c², has positive electric-charge:</span></span>
<span id="cb8-104"><a href="#cb8-104"></a>        <span class="op">{</span><span class="st">"up"</span><span class="op">,</span> <span class="fl">2.3</span><span class="op">,</span> <span class="kw">true</span><span class="op">},</span> <span class="op">{</span><span class="st">"down"</span><span class="op">,</span> <span class="fl">4.8</span><span class="op">,</span> <span class="kw">false</span><span class="op">},</span></span>
<span id="cb8-105"><a href="#cb8-105"></a>        <span class="op">{</span><span class="st">"charm"</span><span class="op">,</span> <span class="dv">1275</span><span class="op">,</span> <span class="kw">true</span><span class="op">},</span> <span class="op">{</span><span class="st">"strange"</span><span class="op">,</span> <span class="dv">95</span><span class="op">,</span> <span class="kw">false</span><span class="op">},</span></span>
<span id="cb8-106"><a href="#cb8-106"></a>        <span class="op">{</span><span class="st">"top"</span><span class="op">,</span> <span class="dv">173'210</span><span class="op">,</span> <span class="kw">true</span><span class="op">},</span> <span class="op">{</span><span class="st">"bottom"</span><span class="op">,</span> <span class="dv">4'180</span><span class="op">,</span> <span class="kw">false</span><span class="op">},</span></span>
<span id="cb8-107"><a href="#cb8-107"></a>    <span class="op">};</span></span>
<span id="cb8-108"><a href="#cb8-108"></a></span>
<span id="cb8-109"><a href="#cb8-109"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Quark name:  | "</span><span class="op">;</span></span>
<span id="cb8-110"><a href="#cb8-110"></a>    <span class="kw">auto</span> names <span class="op">=</span> stdv<span class="op">::</span>keys<span class="op">(</span>quark_mass_charge<span class="op">);</span></span>
<span id="cb8-111"><a href="#cb8-111"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> name <span class="op">:</span> names<span class="op">)</span></span>
<span id="cb8-112"><a href="#cb8-112"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">9</span><span class="op">)</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">"|"</span><span class="op">;</span></span>
<span id="cb8-113"><a href="#cb8-113"></a></span>
<span id="cb8-114"><a href="#cb8-114"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Mass:        | "</span><span class="op">;</span>    </span>
<span id="cb8-115"><a href="#cb8-115"></a>    <span class="kw">auto</span> masses <span class="op">=</span> stdv<span class="op">::</span>values<span class="op">(</span>quark_mass_charge<span class="op">);</span></span>
<span id="cb8-116"><a href="#cb8-116"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> mass <span class="op">:</span> masses<span class="op">)</span></span>
<span id="cb8-117"><a href="#cb8-117"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">9</span><span class="op">)</span> <span class="op">&lt;&lt;</span> mass <span class="op">&lt;&lt;</span> <span class="st">"|"</span><span class="op">;</span></span>
<span id="cb8-118"><a href="#cb8-118"></a></span>
<span id="cb8-119"><a href="#cb8-119"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">Charge:      | "</span><span class="op">;</span>    </span>
<span id="cb8-120"><a href="#cb8-120"></a>    <span class="kw">auto</span> charges <span class="op">=</span> stdv<span class="op">::</span>elements<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>quark_mass_charge<span class="op">);</span></span>
<span id="cb8-121"><a href="#cb8-121"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> charge <span class="op">:</span> charges<span class="op">)</span></span>
<span id="cb8-122"><a href="#cb8-122"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">9</span><span class="op">)</span> <span class="op">&lt;&lt;</span> charge <span class="op">&lt;&lt;</span> <span class="st">"|"</span><span class="op">;</span>        </span>
<span id="cb8-123"><a href="#cb8-123"></a></span>
<span id="cb8-124"><a href="#cb8-124"></a>    <span class="co">// zip_view</span></span>
<span id="cb8-125"><a href="#cb8-125"></a>    <span class="co">// Create a view of tuples from the elements</span></span>
<span id="cb8-126"><a href="#cb8-126"></a>    <span class="co">// of an array of integers and a vector of</span></span>
<span id="cb8-127"><a href="#cb8-127"></a>    <span class="co">// doubles</span></span>
<span id="cb8-128"><a href="#cb8-128"></a>    <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> a<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb8-129"><a href="#cb8-129"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v<span class="op">{</span><span class="fl">10.0</span><span class="op">,</span> <span class="fl">20.0</span><span class="op">,</span> <span class="fl">30.0</span><span class="op">};</span></span>
<span id="cb8-130"><a href="#cb8-130"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">zip_result: "</span><span class="op">;</span></span>
<span id="cb8-131"><a href="#cb8-131"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> z <span class="op">:</span> stdv<span class="op">::</span>zip<span class="op">(</span>a<span class="op">,</span> v<span class="op">))</span></span>
<span id="cb8-132"><a href="#cb8-132"></a>        <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st"> "</span><span class="op">,</span> z<span class="op">);</span></span>
<span id="cb8-133"><a href="#cb8-133"></a></span>
<span id="cb8-134"><a href="#cb8-134"></a>    <span class="co">// zip_transform </span></span>
<span id="cb8-135"><a href="#cb8-135"></a>    <span class="co">// Create a view with the multiplied elements</span></span>
<span id="cb8-136"><a href="#cb8-136"></a>    <span class="co">// of an array of integers and vector of doubles</span></span>
<span id="cb8-137"><a href="#cb8-137"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">zip_transform_result: "</span><span class="op">;</span></span>
<span id="cb8-138"><a href="#cb8-138"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> z <span class="op">:</span> stdv<span class="op">::</span>zip_transform<span class="op">(</span></span>
<span id="cb8-139"><a href="#cb8-139"></a>        <span class="bu">std::</span>multiplies<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(),</span> a<span class="op">,</span> v</span>
<span id="cb8-140"><a href="#cb8-140"></a>    <span class="op">))</span></span>
<span id="cb8-141"><a href="#cb8-141"></a>        <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st"> "</span><span class="op">,</span> z<span class="op">);</span></span>
<span id="cb8-142"><a href="#cb8-142"></a></span>
<span id="cb8-143"><a href="#cb8-143"></a>    <span class="co">// adjacent_view</span></span>
<span id="cb8-144"><a href="#cb8-144"></a>    <span class="co">// Print the pairs of adjacent elements of a</span></span>
<span id="cb8-145"><a href="#cb8-145"></a>    <span class="co">// sequence of integers</span></span>
<span id="cb8-146"><a href="#cb8-146"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">adjacent_result: "</span><span class="op">;</span></span>
<span id="cb8-147"><a href="#cb8-147"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> v <span class="op">|</span> stdv<span class="op">::</span>adjacent<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;)</span></span>
<span id="cb8-148"><a href="#cb8-148"></a>        <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st"> "</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb8-149"><a href="#cb8-149"></a></span>
<span id="cb8-150"><a href="#cb8-150"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-151"><a href="#cb8-151"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/Gv65nrhrs">Compiler Explorer</a></p>
</section>
<section id="understanding-the-constrained-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="understanding-the-constrained-algorithms">Understanding the constrained algorithms</h2>
<p>The standard library provides over a hundred general-purpose algorithms. Most of these algorithms have a new constrained version in <code>std::ranges</code> namespace. These algorithms are found in the <code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code> and <code>&lt;memory&gt;</code> header.</p>
<ul>
<li>They have the same name as the existing algorithms.</li>
<li>They have overloads that allow you to specify a range, either with a <code>begin</code> iterator and an <code>end</code> sentinel, or as a single range argument.</li>
<li>They have modified return types that provide more information about the execution.</li>
<li>They support projections to apply to the processed elements. A <strong>projection</strong> is an entity that can be invoked. It can be a pointer to a member function, a lambda expression, or a function pointer. Such a projection is applied to the range element <em>before</em> the algorithm logic uses the element.</li>
</ul>
<p>From <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy.html">cppreference.com</a>, the rangified version of the <code>copy_if</code> algorithm has the following overloads:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span><span class="op">&lt;</span> <span class="bu">std::</span>input_iterator<span class="op"> </span>I<span class="op">,</span> <span class="bu">std::</span>sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S<span class="op">,</span> <span class="bu">std::</span>weakly_incrementable<span class="op"> </span>O<span class="op">,</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>          <span class="kw">class</span> Proj <span class="op">=</span> <span class="bu">std::</span>identity<span class="op">,</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>          <span class="bu">std::</span>indirect_unary_predicate<span class="op">&lt;</span><span class="bu">std::</span>projected<span class="op">&lt;</span>I<span class="op">,</span> Proj<span class="op">&gt;&gt;</span> Pred <span class="op">&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">requires</span> <span class="bu">std::</span>indirectly_copyable<span class="op">&lt;</span>I<span class="op">,</span> O<span class="op">&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">constexpr</span> copy_if_result<span class="op">&lt;</span>I<span class="op">,</span> O<span class="op">&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    copy_if<span class="op">(</span> I first<span class="op">,</span> S last<span class="op">,</span> O result<span class="op">,</span> Pred pred<span class="op">,</span> Proj proj <span class="op">=</span> <span class="op">{}</span> <span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span><span class="op">&lt;</span> ranges<span class="op">::</span>input_range R<span class="op">,</span> <span class="bu">std::</span>weakly_incrementable<span class="op"> </span>O<span class="op">,</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>          <span class="kw">class</span> Proj <span class="op">=</span> <span class="bu">std::</span>identity<span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>          <span class="bu">std::</span>indirect_unary_predicate<span class="op">&lt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>              <span class="bu">std::</span>projected<span class="op">&lt;</span>ranges<span class="op">::</span><span class="dt">iterator_t</span><span class="op">&lt;</span>R<span class="op">&gt;,</span> Proj<span class="op">&gt;&gt;</span> Pred <span class="op">&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">requires</span> <span class="bu">std::</span>indirectly_copyable<span class="op">&lt;</span>ranges<span class="op">::</span><span class="dt">iterator_t</span><span class="op">&lt;</span>R<span class="op">&gt;,</span> O<span class="op">&gt;</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">constexpr</span> copy_if_result<span class="op">&lt;</span>ranges<span class="op">::</span><span class="dt">borrowed_iterator_t</span><span class="op">&lt;</span>R<span class="op">&gt;,</span> O<span class="op">&gt;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    copy_if<span class="op">(</span> R<span class="op">&amp;&amp;</span> r<span class="op">,</span> O result<span class="op">,</span> Pred pred<span class="op">,</span> Proj proj <span class="op">=</span> <span class="op">{}</span> <span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The signatures may look cryptic, but it’s easy to code up a few quick examples.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">namespace</span> stdr <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">namespace</span> stdv <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>views<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">13</span><span class="op">};</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> o<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="kw">auto</span> filter_odd <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> n<span class="op">){</span> <span class="cf">return</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="kw">auto</span> e1 <span class="op">=</span> stdr<span class="op">::</span>copy_if<span class="op">(</span>v<span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>o<span class="op">),</span> filter_odd<span class="op">);</span></span>
<span id="cb11-16"><a href="#cb11-16"></a></span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">13</span> <span class="op">};</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="kw">auto</span> e2 <span class="op">=</span> stdr<span class="op">::</span>copy_if<span class="op">(</span>arr<span class="op">,</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>        <span class="bu">std::</span>back_inserter<span class="op">(</span>o<span class="op">),</span> filter_odd</span>
<span id="cb11-20"><a href="#cb11-20"></a>    <span class="op">);</span></span>
<span id="cb11-21"><a href="#cb11-21"></a></span>
<span id="cb11-22"><a href="#cb11-22"></a>    <span class="kw">auto</span> rng <span class="op">=</span> stdr<span class="op">::</span>iota_view<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb11-23"><a href="#cb11-23"></a>    <span class="kw">auto</span> e3 <span class="op">=</span> stdr<span class="op">::</span>copy_if<span class="op">(</span>r<span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>o<span class="op">),</span> filter_odd<span class="op">);</span></span>
<span id="cb11-24"><a href="#cb11-24"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/v4hTef7Wb">Compiler Explorer</a></p>
<p>These examples show two things: how to copy elements from a <code>std::vector</code> object and an array and how to copy elements from a view(a range adaptor). What they don’t show is projections. I’ll explore some examples on this shortly.</p>
<p>Other constrained algorithms like <code>all_of</code>, <code>any_of</code>, <code>none_of</code>, <code>find</code>, <code>find_if</code>, <code>copy</code>, <code>copy_if</code>, <code>move</code>, <code>copy_backward</code>, <code>move_backward</code>, <code>fill</code>, <code>fill_n</code>, <code>transform</code>, <code>sample</code>, <code>fold_left</code>, <code>fold_right</code> are very useful in coding.</p>
<p>A projection is an invocable entity. It’s basically a function adaptor. It affects the predicate, providing a way to perform function composition. It does not provide a way to change the algorithm. For instance, let’s say we have the following type:</p>
<p>Let’s say we have the following type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">struct</span> Point<span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="dt">double</span> x<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">double</span> y<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Also, for the purpose of the explanation, let’s consider the following sequence of points:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> points<span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">},</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="op">{-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">},</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">},</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="op">{-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Projects allow us to perform composition on the predicate. For instance, let’s say we want to copy to a second vector all points below the <span class="math inline">\(x\)</span>-axis (having a negative <span class="math inline">\(y\)</span>-coordinate). We can code up the following:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> points_below_x_axis<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>stdr<span class="op">::</span>copy_if<span class="op">(</span>points<span class="op">,</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="bu">std::</span>back_inserter<span class="op">(</span>points_below_x_axis<span class="op">),</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">[](</span><span class="at">const</span> Point<span class="op">&amp;</span> point<span class="op">){</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="cf">return</span> point<span class="op">.</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, we can also write equivalently:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> points_below_x_axis<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>stdr<span class="op">::</span>copy_if<span class="op">(</span>points<span class="op">,</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="bu">std::</span>back_inserter<span class="op">(</span>points_below_x_axis<span class="op">),</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="op">[](</span><span class="at">const</span> Point<span class="op">&amp;</span> point<span class="op">){</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>        <span class="cf">return</span> x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="op">},</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="op">&amp;</span>Point<span class="op">::</span>x</span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The projection, in this example, is the pointer-to-member expression <code>&amp;Point::x</code> that is applied to each <code>Point</code> element before executing the predicate (which is a lambda expression). This is useful when already have reusable function objects/lambda expressions and you don’t want to write another one for passing different types.</p>
</section>
<section id="writing-your-own-range-adaptor" class="level2">
<h2 class="anchored" data-anchor-id="writing-your-own-range-adaptor">Writing your own range adaptor</h2>
<p>The standard library contains a series of range adaptors that can be used for solving many different tasks. However, there are situations where we’d like to write our own custom randge adaptor.</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="references" class="level1 appendix"><h2 class="anchored quarto-appendix-heading">References</h2><div class="quarto-appendix-contents">

<ul>
<li><em><a href="https://youtu.be/qXdPFj-FTcA?si=3xX3r8eIF4TlWXwr">Ranges and Iterators for numerical Problems</a>, Karsten Ahnert at Meeting C++ 2014</em></li>
<li><em><a href="https://www.youtube.com/watch?v=UsyA7zEC0DE&amp;t=989s">What is a range in C++</a>, Simon Toth, C++ on the Sea, 2024</em></li>
<li><em><a href="https://%20hannes.hauswedell.net/post/2019/11/30/range_intro/">A beginner’s guide to C++ Ranges and Views</a>, Hannes Hauswedell</em></li>
<li><em><a href="https://%20mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-%20and-after-ranges/">C++ Code Samples Before and After Ranges</a>, Marius Bancila</em></li>
</ul>


</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>