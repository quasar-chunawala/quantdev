<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-12-15">

<title>quantdev.blog - Implementing vector<t></t></title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././symbol.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../newsletter.html" rel="" target="">
 <span class="menu-text">Newsletter</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Implementing <code>vector&lt;T&gt;</code></h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 15, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#implementing-vectort" id="toc-implementing-vectort" class="nav-link active" data-scroll-target="#implementing-vectort">Implementing <code>vector&lt;T&gt;</code></a>
  <ul class="collapse">
  <li><a href="#the-problem-statement" id="toc-the-problem-statement" class="nav-link" data-scroll-target="#the-problem-statement">The problem statement</a></li>
  </ul></li>
  <li><a href="#writing-your-own-vectort-training-implementation" id="toc-writing-your-own-vectort-training-implementation" class="nav-link" data-scroll-target="#writing-your-own-vectort-training-implementation">Writing your own <code>vector&lt;T&gt;</code> training implementation</a>
  <ul class="collapse">
  <li><a href="#unit-tests-for-vectort" id="toc-unit-tests-for-vectort" class="nav-link" data-scroll-target="#unit-tests-for-vectort">Unit tests for <code>vector&lt;T&gt;</code></a></li>
  <li><a href="#vector-member-data" id="toc-vector-member-data" class="nav-link" data-scroll-target="#vector-member-data"><code>vector</code> member data</a></li>
  <li><a href="#vector-constructors" id="toc-vector-constructors" class="nav-link" data-scroll-target="#vector-constructors"><code>vector</code> constructors</a></li>
  <li><a href="#basic-services-of-a-vector-like-class" id="toc-basic-services-of-a-vector-like-class" class="nav-link" data-scroll-target="#basic-services-of-a-vector-like-class">Basic services of a vector-like class</a>
  <ul class="collapse">
  <li><a href="#implementing-front-back-and-operatorsize_t-idx" id="toc-implementing-front-back-and-operatorsize_t-idx" class="nav-link" data-scroll-target="#implementing-front-back-and-operatorsize_t-idx">Implementing <code>front()</code>, <code>back()</code> and <code>operator[](size_t idx)</code></a></li>
  <li><a href="#dynamic-memory-allocation-and-deallocation" id="toc-dynamic-memory-allocation-and-deallocation" class="nav-link" data-scroll-target="#dynamic-memory-allocation-and-deallocation">Dynamic memory allocation and deallocation</a></li>
  <li><a href="#implementing-reserve" id="toc-implementing-reserve" class="nav-link" data-scroll-target="#implementing-reserve">Implementing <code>reserve()</code></a></li>
  <li><a href="#implementing-resize" id="toc-implementing-resize" class="nav-link" data-scroll-target="#implementing-resize">Implementing <code>resize()</code></a></li>
  </ul></li>
  <li><a href="#how-to-think-about-adding-elements-to-our-container" id="toc-how-to-think-about-adding-elements-to-our-container" class="nav-link" data-scroll-target="#how-to-think-about-adding-elements-to-our-container">How to think about adding elements to our container?</a>
  <ul class="collapse">
  <li><a href="#push_back_slow_pathvalue" id="toc-push_back_slow_pathvalue" class="nav-link" data-scroll-target="#push_back_slow_pathvalue"><code>push_back_slow_path(value)</code></a></li>
  <li><a href="#push_back_fast_pathvalue" id="toc-push_back_fast_pathvalue" class="nav-link" data-scroll-target="#push_back_fast_pathvalue"><code>push_back_fast_path(value)</code></a></li>
  <li><a href="#edge-case" id="toc-edge-case" class="nav-link" data-scroll-target="#edge-case">Edge-case</a></li>
  <li><a href="#coding-up-emplace_back" id="toc-coding-up-emplace_back" class="nav-link" data-scroll-target="#coding-up-emplace_back">Coding up <code>emplace_back</code></a></li>
  </ul></li>
  <li><a href="#implementing-pop_back" id="toc-implementing-pop_back" class="nav-link" data-scroll-target="#implementing-pop_back">Implementing <code>pop_back()</code></a></li>
  <li><a href="#implementing-insertconst_iterator-position-it-first-it-last" id="toc-implementing-insertconst_iterator-position-it-first-it-last" class="nav-link" data-scroll-target="#implementing-insertconst_iterator-position-it-first-it-last">Implementing <code>insert(const_iterator position, It first, It last)</code></a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="implementing-vectort" class="level1">
<h1>Implementing <code>vector&lt;T&gt;</code></h1>
<section id="the-problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-statement">The problem statement</h2>
<blockquote class="blockquote">
<h4 id="your-task" class="anchored">Your Task</h4>
</blockquote>
<p>Implement your own version of a vector with the following methods:</p>
<ul>
<li><code>push_back</code> – Adds an element to the back.</li>
<li><code>at</code> – Retrieves an element by index.</li>
<li><code>getSize</code> – Gets the size of the container.</li>
<li><code>getCapacity</code> – Gets the capacity of the container.</li>
<li><code>shrinkToFit</code> – Shrinks the capacity to equal the size of the container.</li>
<li><code>pop_back</code> – Removes the last element in the container. Will never be called on an empty container.</li>
</ul>
<blockquote class="blockquote">
<h4 id="requirements" class="anchored">Requirements</h4>
</blockquote>
<ul>
<li>Do not worry about memory alignment or advanced optimizations.</li>
<li>Do not use <code>std::vector</code> in your <code>dev::vector</code> implementation.</li>
<li>Your vector’s capacity must start at 1.</li>
<li>The capacity should triple every time it is reached.</li>
</ul>
<p>For more such C++ coding tasks, visit <a href="https://getcracked.io/problem/1/implement-vector">getcracked.io</a>.</p>
</section>
</section>
<section id="writing-your-own-vectort-training-implementation" class="level1">
<h1>Writing your own <code>vector&lt;T&gt;</code> training implementation</h1>
<blockquote class="blockquote">
<h3 id="if-you-know-stdvector-you-know-half-of-c." class="anchored"><em>If you know <code>std::vector</code>, you know half of C++.</em></h3>
<h3 id="bjarne-stroustrup" class="anchored">- Bjarne Stroustrup</h3>
</blockquote>
<p>The most fundamental STL data-structure is the <code>vector</code>. In this article, I am going to explore writing a custom implementation of the <code>vector</code> data-structure. The standard library implementation <code>std::vector</code> is a work of art, it is extremely efficient at managing memory and has been tested ad nauseam. It is much better, in fact, than a homegrown alternative would be.</p>
<p>Why then write our own custom <code>vector</code>? - Writing a naive implementation is challenging and rewarding. It is a lot of fun! - Coding up these training implementations, thinking about corner cases, getting your code reviewed, revisiting your design is very effective at understanding the inner workings of STL data-strucures and writing good C++ code. - Its a good opportunity to learn about low-level memory management algorithms.</p>
<p>We are not aiming for an exhaustive representation or implementation, but we will write test cases for all basic functionalities expected out of a <code>vector</code> like data-structure.</p>
<p>Informally, a <code>std::vector&lt;T&gt;</code> represents a dynamically allocated array that can grow as needed. As with any array, a <code>std::vector&lt;T&gt;</code> is a sequence of elements of type <code>T</code> arranged contigously in memory. We will put our homegrown version of <code>vector&lt;T&gt;</code> under the <code>dev</code> namespace.</p>
<section id="unit-tests-for-vectort" class="level2">
<h2 class="anchored" data-anchor-id="unit-tests-for-vectort">Unit tests for <code>vector&lt;T&gt;</code></h2>
<p>For low-level data-structures such as the <code>vector</code>, let’s write the unit-tests upfront before the implementation. This will help us think through the interface and corner cases. Tests will also serve as documentation of the expected functionality.</p>
<p>The internal representation of a <code>vector</code> like type has a book-keeping node that consists of: - A pointer to the raw data (a block of memory that will hold elements of type <code>T</code>) - Size of the container(the number of elements in the container) - Capacity</p>
<p><img src="vector.png" class="img-fluid"></p>
<p>It’s important to distinguish between <code>size</code> and <code>capacity</code>. <code>size</code> is the number of elements currently in the container. When <code>size == capacity</code>, the container becomes full and will need to grow, which means allocating more member, copying the elements from the old storage to the new storage and getting rid of the old storage.</p>
<p>Given this background, we assume that the <code>vector</code> is equipped with basic getters such as:</p>
<ul>
<li><code>std::size_t size()</code></li>
<li><code>std::size_t capacity()</code></li>
<li><code>bool empty()</code></li>
<li><code>bool is_full()</code></li>
</ul>
<p>The <code>vector</code> should support various constructors.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> DefaultConstructorTest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>empty<span class="op">(),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> InitializerListTest<span class="op">){</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  EXPECT_EQ<span class="op">(!</span>v<span class="op">.</span>empty<span class="op">(),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>  EXPECT_TRUE<span class="op">(</span>v<span class="op">.</span>capacity<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">){</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>at<span class="op">(</span>i<span class="op">),</span> i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> ParameterizedConstructorTest<span class="op">){</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>  dev<span class="op">::</span>vector v<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="fl">5.5</span><span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">){</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>    EXPECT_EQ<span class="op">(</span>v<span class="op">[</span>i<span class="op">],</span> <span class="fl">5.5</span><span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>  <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> CopyConstructorTest<span class="op">){</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>  dev<span class="op">::</span>vector v1<span class="op">{</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span> <span class="op">};</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>  dev<span class="op">::</span>vector v2<span class="op">(</span>v1<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27"></a></span>
<span id="cb1-28"><a href="#cb1-28"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> v2<span class="op">.</span>size<span class="op">(),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span> <span class="dv">0</span> <span class="op">};</span> i <span class="op">&lt;</span> v1<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>  <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    EXPECT_EQ<span class="op">(</span>v2<span class="op">[</span>i<span class="op">],</span> i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>    EXPECT_EQ<span class="op">(</span>v1<span class="op">[</span>i<span class="op">],</span> v2<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>  <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> MoveConstructorTest<span class="op">){</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb1-39"><a href="#cb1-39"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v1<span class="op">));</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>  EXPECT_EQ<span class="op">(</span>v2<span class="op">.</span>size<span class="op">(),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i<span class="op">&lt;</span>v2<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span> i<span class="op">)</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>    EXPECT_EQ<span class="op">(</span>v2<span class="op">[</span>i<span class="op">],</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46"></a></span>
<span id="cb1-47"><a href="#cb1-47"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> CopyAssignmentTest<span class="op">)</span></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb1-50"><a href="#cb1-50"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">;</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>  v2 <span class="op">=</span> v1<span class="op">;</span></span>
<span id="cb1-52"><a href="#cb1-52"></a></span>
<span id="cb1-53"><a href="#cb1-53"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>size<span class="op">(),</span> v2<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb1-54"><a href="#cb1-54"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>capacity<span class="op">(),</span> v2<span class="op">.</span>capacity<span class="op">());</span></span>
<span id="cb1-55"><a href="#cb1-55"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v1<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>    EXPECT_EQ<span class="op">(</span>v1<span class="op">[</span>i<span class="op">],</span> i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>    EXPECT_EQ<span class="op">(</span>v1<span class="op">[</span>i<span class="op">],</span> v2<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-58"><a href="#cb1-58"></a>  <span class="op">}</span></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> MoveAssignmentTest<span class="op">)</span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="op">{</span></span>
<span id="cb1-63"><a href="#cb1-63"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb1-64"><a href="#cb1-64"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">;</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>  v2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>v1<span class="op">);</span></span>
<span id="cb1-66"><a href="#cb1-66"></a></span>
<span id="cb1-67"><a href="#cb1-67"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-69"><a href="#cb1-69"></a>  EXPECT_EQ<span class="op">(</span>v2<span class="op">.</span>size<span class="op">(),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-70"><a href="#cb1-70"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v1<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-71"><a href="#cb1-71"></a>    EXPECT_EQ<span class="op">(</span>v2<span class="op">[</span>i<span class="op">],</span> i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-72"><a href="#cb1-72"></a>  <span class="op">}</span></span>
<span id="cb1-73"><a href="#cb1-73"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>vector</code> data-structure should support element access through the array subscript operator <code>[]</code>, just like C-style arrays. The <code>T&amp; at(std::size_t idx)</code> could also be used to access the element at index <code>idx</code> with bounds checking.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> AtTest<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>at<span class="op">(</span><span class="dv">0</span><span class="op">),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>at<span class="op">(</span><span class="dv">1</span><span class="op">),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>at<span class="op">(</span><span class="dv">2</span><span class="op">),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a>  EXPECT_THROW<span class="op">(</span>v<span class="op">.</span>at<span class="op">(</span><span class="dv">3</span><span class="op">),</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> SubscriptOperatorTest<span class="op">)</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    EXPECT_EQ<span class="op">(</span>v<span class="op">[</span>i<span class="op">],</span> i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We expect the container to perform the book-keeping of size and capacity correctly.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> EmptyTest<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>empty<span class="op">(),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a>  v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>empty<span class="op">(),</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> SizeAndCapacityTest<span class="op">)</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>  EXPECT_GE<span class="op">(</span>v<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>  v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>  EXPECT_GT<span class="op">(</span>v<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a>  v<span class="op">.</span>push_back<span class="op">(</span>v<span class="op">.</span>back<span class="op">());</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="dv">42</span><span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We expect the container to support the getter methods <code>front()</code> and <code>back()</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> FrontAndBackTest<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>front<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>back<span class="op">(),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The container should support <code>reserve(size_t new_capacity)</code> and <code>resize(size_t new_size)</code>. These are explained at length further ahead.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> ReserveTest<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  v1<span class="op">.</span>reserve<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  EXPECT_GE<span class="op">(</span>v1<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>  EXPECT_EQ<span class="op">(</span>v1<span class="op">.</span>size<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="dt">size_t</span> old_capacity <span class="op">=</span> v2<span class="op">.</span>capacity<span class="op">();</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  EXPECT_GE<span class="op">(</span>v2<span class="op">.</span>capacity<span class="op">(),</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>  EXPECT_EQ<span class="op">(</span>v2<span class="op">.</span>size<span class="op">(),</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span class="dt">size_t</span> new_capacity <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> old_capacity<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  v2<span class="op">.</span>reserve<span class="op">(</span>new_capacity<span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>  EXPECT_GE<span class="op">(</span>v2<span class="op">.</span>capacity<span class="op">(),</span> new_capacity<span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>  EXPECT_EQ<span class="op">(</span>v2<span class="op">.</span>size<span class="op">(),</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> v2<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    EXPECT_EQ<span class="op">(</span>v2<span class="op">[</span>i<span class="op">],</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> ResizeTest<span class="op">)</span></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="op">{</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>  v<span class="op">.</span>resize<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb5-24"><a href="#cb5-24"></a></span>
<span id="cb5-25"><a href="#cb5-25"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i<span class="op">&lt;</span><span class="dv">3</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>    EXPECT_EQ<span class="op">(</span>v<span class="op">[</span>i<span class="op">],</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">4</span><span class="op">],</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-31"><a href="#cb5-31"></a></span>
<span id="cb5-32"><a href="#cb5-32"></a>  v<span class="op">.</span>resize<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The container should support appending elements or removal elements at the back.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> PushBackTest<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>  v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>  v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>  v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i<span class="op">&lt;</span>v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    EXPECT_EQ<span class="op">(</span>v<span class="op">[</span>i<span class="op">],</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> PushBackSelfReferenceTest<span class="op">)</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>  <span class="co">// The design of push_back/insert is slightly hard to get right.</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>  <span class="co">// If the vector is full, then you reallocate(grow) the vector.</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>  <span class="co">// If the value to be added is a reference to an existing</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="co">// vector element, then value in vec.push_back(value) may become</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>  <span class="co">// a dangling reference, if it refers to the old storage (an element of the vector</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>  <span class="co">// itself e.g. vec.back()). This test is meant for such an edge case.</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>    vec<span class="op">.</span>push_back<span class="op">(</span>vec<span class="op">.</span>back<span class="op">());</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>    EXPECT_EQ<span class="op">(</span>vec<span class="op">.</span>back<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-25"><a href="#cb6-25"></a>  <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="op">}</span></span>
<span id="cb6-27"><a href="#cb6-27"></a></span>
<span id="cb6-28"><a href="#cb6-28"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> EmplaceBackTest<span class="op">)</span></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="op">{</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>  <span class="kw">struct</span> Point</span>
<span id="cb6-31"><a href="#cb6-31"></a>  <span class="op">{</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>    Point<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb6-34"><a href="#cb6-34"></a>      <span class="op">:</span> x<span class="op">(</span>a<span class="op">)</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>      <span class="op">,</span> y<span class="op">(</span>b<span class="op">)</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="op">{</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="op">}</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>  <span class="op">};</span></span>
<span id="cb6-39"><a href="#cb6-39"></a></span>
<span id="cb6-40"><a href="#cb6-40"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>  v<span class="op">.</span>emplace_back<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>  v<span class="op">.</span>emplace_back<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-45"><a href="#cb6-45"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">0</span><span class="op">].</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">0</span><span class="op">].</span>y<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">1</span><span class="op">].</span>x<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">[</span><span class="dv">1</span><span class="op">].</span>y<span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb6-49"><a href="#cb6-49"></a><span class="op">}</span></span>
<span id="cb6-50"><a href="#cb6-50"></a></span>
<span id="cb6-51"><a href="#cb6-51"></a>TEST<span class="op">(</span>VectorTest<span class="op">,</span> PopBackTest<span class="op">)</span></span>
<span id="cb6-52"><a href="#cb6-52"></a><span class="op">{</span></span>
<span id="cb6-53"><a href="#cb6-53"></a>  dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb6-54"><a href="#cb6-54"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb6-55"><a href="#cb6-55"></a>  v<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb6-56"><a href="#cb6-56"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-57"><a href="#cb6-57"></a>  EXPECT_EQ<span class="op">(</span>v<span class="op">,</span> dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;({</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}));</span></span>
<span id="cb6-58"><a href="#cb6-58"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The container should support a <code>.insert</code> method that allows us to insert elements from a source range to a specified position in the target vector. You can write a variety tests, like inserting at the beginning, middle, end of the vector, self-referential insertion etc. For brevity, I skip listing all of the tests here. The Compiler Explorer online source listing for this entire article is available in the conclusion section.</p>
</section>
<section id="vector-member-data" class="level2">
<h2 class="anchored" data-anchor-id="vector-member-data"><code>vector</code> member data</h2>
<p>We start with coding up the <code>vector</code> as a class template. It is templated by the type <code>T</code> of the elements stored in the container. We also define various type aliases.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="bu">std::</span>size_t<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="kw">using</span> pointer <span class="op">=</span> T<span class="op">*;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>        <span class="kw">using</span> const_pointer <span class="op">=</span> <span class="at">const</span> T<span class="op">*;</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="kw">using</span> reference <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="kw">using</span> const_reference <span class="op">=</span> <span class="at">const</span> T<span class="op">&amp;;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span class="kw">using</span> iterator <span class="op">=</span> pointer<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span class="kw">using</span> const_iterator <span class="op">=</span> const_pointer<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>        pointer <span class="va">m_data</span><span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>        <span class="dt">size_type</span> <span class="va">m_size</span><span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="dt">size_type</span> <span class="va">m_capacity</span><span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">unsigned</span> <span class="dt">short</span> growth_factor<span class="op">{</span><span class="dv">2</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>C++ containers usually expose iterators as part of their interface and ours will be no exception. We define type aliases for the <code>const</code> and non-<code>const</code> iterator types, as this makes it simpler to implement alternatives.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="co">// ...</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>  iterator begin<span class="op">(){</span> <span class="cf">return</span> <span class="va">m_data</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>  const_iterator begin<span class="op">()</span> <span class="at">const</span><span class="op">{</span> <span class="cf">return</span> <span class="va">m_data</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>  iterator end<span class="op">(){</span> <span class="cf">return</span> begin<span class="op">()</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>  const_iterator end<span class="op">()</span> <span class="at">const</span><span class="op">{</span> <span class="cf">return</span> begin<span class="op">()</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">// ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vector-constructors" class="level2">
<h2 class="anchored" data-anchor-id="vector-constructors"><code>vector</code> constructors</h2>
<p>Alluding to the rule-of-five, we implement a copy constructor, copy-assignment operator, move constructor, move assignment operator and a destructor.</p>
<p>To simplify things, we first code up a private <code>vector(init_capacity_tag)</code> constructor whose job is to allocate memory and construct a <code>vector</code> object.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">class</span> vector<span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">struct</span> init_capacity_tag <span class="op">{</span> <span class="dt">size_type</span> cap<span class="op">;</span> <span class="op">};</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="op">};</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co">// If an exception happens after this has been called,</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">// the destructor will run and deallocate the memory.</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">explicit</span> vector<span class="op">(</span>init_capacity_tag cap<span class="op">)</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="op">:</span> <span class="va">m_data</span><span class="op">{</span> allocate_helper<span class="op">(</span>cap<span class="op">.</span>cap<span class="op">).</span>release<span class="op">()</span> <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="op">,</span> <span class="va">m_capacity</span><span class="op">{</span> cap<span class="op">.</span>cap <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="op">{</span> <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>All other constructors delegate to this private <code>vector(init_capacity_tag)</code> constructor. After that constructor completes, the object is fully constructed, and if any execution happens later which throws, the destructor will always be called.</p>
<p>The destructor is called for all fully constructed objects. The object is considered fully constructed once any constructor has finished, including the delegated constructor.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>vector<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="op">{}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">// If an exception happens after this has been called,</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">// the destructor will run and deallocate the memory.</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">explicit</span> vector<span class="op">(</span>init_capacity_tag cap<span class="op">)</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="op">:</span> <span class="va">m_data</span><span class="op">{</span> allocate_helper<span class="op">(</span>cap<span class="op">.</span>cap<span class="op">).</span>release<span class="op">()</span> <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="op">,</span> <span class="va">m_capacity</span><span class="op">{</span> cap<span class="op">.</span>cap <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">{</span> <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a>vector<span class="op">(</span><span class="dt">size_t</span> n<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> initial_value<span class="op">)</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="op">:</span> vector<span class="op">(</span>init_capacity_tag<span class="op">(</span>n<span class="op">))</span> </span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="bu">std::</span>uninitialized_fill_n<span class="op">(</span><span class="va">m_data</span><span class="op">,</span> n<span class="op">,</span> initial_value<span class="op">);</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="va">m_size</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>vector<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span> list<span class="op">)</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="op">:</span> vector<span class="op">(</span>init_capacity_tag<span class="op">(</span>list<span class="op">.</span>size<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    <span class="bu">std::</span>uninitialized_copy<span class="op">(</span>list<span class="op">.</span>begin<span class="op">(),</span> list<span class="op">.</span>end<span class="op">(),</span> <span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="va">m_size</span> <span class="op">=</span> list<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="op">}</span></span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a>vector<span class="op">(</span>const_iterator first<span class="op">,</span> const_iterator last<span class="op">)</span></span>
<span id="cb10-25"><a href="#cb10-25"></a><span class="op">:</span> vector<span class="op">(</span>init_capacity_tag<span class="op">(</span><span class="bu">std::</span>distance<span class="op">(</span>first<span class="op">,</span> last<span class="op">)))</span></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="op">{</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>        <span class="bu">std::</span>uninitialized_move<span class="op">(</span>first<span class="op">,</span> last<span class="op">,</span> <span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>        <span class="bu">std::</span>uninitialized_copy<span class="op">(</span>first<span class="op">,</span> last<span class="op">,</span> <span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="op">}</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="va">m_size</span> <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span>first<span class="op">,</span> last<span class="op">);</span></span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="op">}</span></span>
<span id="cb10-34"><a href="#cb10-34"></a></span>
<span id="cb10-35"><a href="#cb10-35"></a>vector<span class="op">(</span><span class="at">const</span> vector<span class="op">&amp;</span> other<span class="op">)</span></span>
<span id="cb10-36"><a href="#cb10-36"></a><span class="op">:</span> vector<span class="op">(</span>init_capacity_tag<span class="op">(</span>other<span class="op">.</span>capacity<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>    <span class="co">// Perform a deep-copy of all the Ts</span></span>
<span id="cb10-38"><a href="#cb10-38"></a>    <span class="bu">std::</span>uninitialized_copy<span class="op">(</span>other<span class="op">.</span><span class="va">m_data</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_data</span> <span class="op">+</span> other<span class="op">.</span><span class="va">m_size</span><span class="op">,</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>                            <span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>    <span class="va">m_size</span> <span class="op">=</span> other<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-41"><a href="#cb10-41"></a><span class="op">}</span></span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a>vector<span class="op">(</span>vector<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb10-44"><a href="#cb10-44"></a><span class="op">:</span> <span class="va">m_data</span><span class="op">{</span><span class="bu">std::</span>exchange<span class="op">(</span>other<span class="op">.</span><span class="va">m_data</span><span class="op">,</span> <span class="kw">nullptr</span><span class="op">)},</span></span>
<span id="cb10-45"><a href="#cb10-45"></a><span class="va">m_size</span><span class="op">{</span><span class="bu">std::</span>exchange<span class="op">(</span>other<span class="op">.</span><span class="va">m_size</span><span class="op">,</span> <span class="dv">0</span><span class="op">)},</span></span>
<span id="cb10-46"><a href="#cb10-46"></a><span class="va">m_capacity</span><span class="op">{</span><span class="bu">std::</span>exchange<span class="op">(</span>other<span class="op">.</span><span class="va">m_capacity</span><span class="op">,</span> <span class="dv">0</span><span class="op">)}</span> </span>
<span id="cb10-47"><a href="#cb10-47"></a><span class="op">{}</span></span>
<span id="cb10-48"><a href="#cb10-48"></a></span>
<span id="cb10-49"><a href="#cb10-49"></a><span class="dt">void</span> swap<span class="op">(</span>vector<span class="op">&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb10-50"><a href="#cb10-50"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span><span class="va">m_data</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-51"><a href="#cb10-51"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span><span class="va">m_size</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_size</span><span class="op">);</span></span>
<span id="cb10-52"><a href="#cb10-52"></a>    <span class="bu">std::</span>swap<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span><span class="va">m_capacity</span><span class="op">,</span> other<span class="op">.</span><span class="va">m_capacity</span><span class="op">);</span></span>
<span id="cb10-53"><a href="#cb10-53"></a><span class="op">}</span></span>
<span id="cb10-54"><a href="#cb10-54"></a></span>
<span id="cb10-55"><a href="#cb10-55"></a>vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> vector<span class="op">&amp;</span> other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-56"><a href="#cb10-56"></a>    vector<span class="op">(</span>other<span class="op">).</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb10-57"><a href="#cb10-57"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb10-58"><a href="#cb10-58"></a><span class="op">}</span></span>
<span id="cb10-59"><a href="#cb10-59"></a></span>
<span id="cb10-60"><a href="#cb10-60"></a>vector<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>vector<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-61"><a href="#cb10-61"></a>    vector<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">)).</span>swap<span class="op">(*</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb10-62"><a href="#cb10-62"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb10-63"><a href="#cb10-63"></a><span class="op">}</span></span>
<span id="cb10-64"><a href="#cb10-64"></a></span>
<span id="cb10-65"><a href="#cb10-65"></a><span class="op">~</span>vector<span class="op">(){</span></span>
<span id="cb10-66"><a href="#cb10-66"></a>    <span class="bu">std::</span>destroy<span class="op">(</span>begin<span class="op">(),</span> end<span class="op">());</span></span>
<span id="cb10-67"><a href="#cb10-67"></a>    raw_deleter<span class="op">{}(</span><span class="va">m_data</span><span class="op">);</span></span>
<span id="cb10-68"><a href="#cb10-68"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If any of the delegating constructors such as <code>vector(size_t n, const T&amp; initial_value)</code> fails in the constructor body, the <code>~vector()</code> destructor has to be run. This makes memory handling almost entirely automatic.</p>
</section>
<section id="basic-services-of-a-vector-like-class" class="level2">
<h2 class="anchored" data-anchor-id="basic-services-of-a-vector-like-class">Basic services of a vector-like class</h2>
<section id="implementing-front-back-and-operatorsize_t-idx" class="level3">
<h3 class="anchored" data-anchor-id="implementing-front-back-and-operatorsize_t-idx">Implementing <code>front()</code>, <code>back()</code> and <code>operator[](size_t idx)</code></h3>
<p>There is more to writing a convenient dynamic array type. For example, member functions that let you access the elements at front or rear-end of the vector are to be expected. Similarly, an implementation of <code>operator[]</code> to access the element at a specific index in the array is also expected.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">// ...</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> idx<span class="op">){</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> idx<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span class="cf">return</span> <span class="va">m_data</span><span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co">// precondition: !empty()</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>reference front<span class="op">(){</span> <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)[</span><span class="dv">0</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>const_reference front<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)[</span><span class="dv">0</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>reference back<span class="op">(){</span> <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)[</span><span class="va">m_size</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>const_reference back<span class="op">()</span> <span class="at">const</span><span class="op">{</span> <span class="cf">return</span> <span class="op">(*</span><span class="kw">this</span><span class="op">)[</span><span class="va">m_size</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Comparing two <code>vector&lt;T&gt;</code> objects for equivalence or lack thereof is a relatively easy matter if we use algorithms:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">//...</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> vector<span class="op">&amp;</span> other<span class="op">){</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="cf">return</span> size<span class="op">()</span> <span class="op">==</span> other<span class="op">.</span>size<span class="op">()</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="bu">std::</span>equal<span class="op">(</span>begin<span class="op">(),</span> end<span class="op">(),</span> other<span class="op">.</span>begin<span class="op">());</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="dynamic-memory-allocation-and-deallocation" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-memory-allocation-and-deallocation">Dynamic memory allocation and deallocation</h3>
<p>In general, we want to separate allocation of raw memory from construction of <code>T</code> objects. <code>operator new(size_t count)</code> attempts to allocate <code>count</code> bytes on the heap. The newly allocated memory is <strong>uninitialized</strong>. This is different from the <code>new</code> expression, <code>new T(Args)</code> or <code>new T[]()</code> which performs both allocation and zero initialization (invokes the default constructor <code>T()</code>).</p>
<p>The memory subsystem on a modern CPU is restricted to accessing memory at the granularity and alignment of its word size. The CPU always reads at its word size (<span class="math inline">\(8\)</span> bytes on a <span class="math inline">\(64\)</span>-bit processor), so when you do an unaligned address access — on a processor that supports it — the processor is going to have to read multiple words. The CPU will read each word of memory that your requested address straddles. That’s why it’s important to always align custom types, when allocating memory.</p>
<p>The regular <code>new</code> operator only guarantees alignment upto <code>alignof(std::max_align_t)</code>, it works well for fundamental types. But, for custom types where <code>alignof(T) &gt; alignof(std::max_align_t)</code>, it would fail. C++17 supports an overloaded version of the <code>new</code> operator with alignment as an additional argument.</p>
<p>We introduce the helper functions <code>allocate_helper</code> and a custom deleter function object. We also declare a <code>raw_deleter</code> type alias.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> raw_deleter <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="co">// only frees the memory, doesn't destroy objects</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">*</span> ptr<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>        <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span>ptr<span class="op">,</span> <span class="bu">std::</span>align_val_t<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">value_type</span><span class="op">)));</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">using</span> raw_ptr <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>T<span class="op">,</span> raw_deleter<span class="op">&gt;;</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a>raw_ptr allocate_helper<span class="op">(</span><span class="dt">size_type</span> new_capacity<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">auto</span> ptr <span class="op">=</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>        <span class="kw">sizeof</span><span class="op">(</span><span class="dt">value_type</span><span class="op">)</span> <span class="op">*</span> new_capacity<span class="op">,</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>        <span class="bu">std::</span>align_val_t<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">value_type</span><span class="op">))</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>    <span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="cf">return</span> raw_ptr<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>pointer<span class="op">&gt;(</span>ptr<span class="op">));</span></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In <code>allocate_helper</code>, I chose to wrap the result of <code>operator new</code> into a unique pointer before returning to the caller. Again, this memory management automatic at the call-site.</p>
</section>
<section id="implementing-reserve" class="level3">
<h3 class="anchored" data-anchor-id="implementing-reserve">Implementing <code>reserve()</code></h3>
<p><code>reserve(size_type new_capacity)</code> increases the capacity of the vector(the total number of elements that the vector can hold without requiring reallocation) to a value that’s greater or equal to <code>new_capacity</code>. If <code>new_capacity</code> is greater than the current <code>capacity()</code>, new storage is allocated, otherwise the function does nothing.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">// Copies elements from old storage to new</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">// If T's copy/move ctor throws, the objects already constructed are</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">// destroyed and the exception is propagated to the caller.</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="dt">void</span> copy_old_storage_to_new<span class="op">(</span>pointer source_first<span class="op">,</span> <span class="dt">size_t</span> num_elements<span class="op">,</span> pointer destination_first<span class="op">){</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;){</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>        <span class="bu">std::</span>uninitialized_move<span class="op">(</span>source_first<span class="op">,</span> source_first <span class="op">+</span> num_elements<span class="op">,</span> destination_first<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>        <span class="bu">std::</span>uninitialized_copy<span class="op">(</span>source_first<span class="op">,</span> source_first <span class="op">+</span> num_elements<span class="op">,</span> destination_first<span class="op">);</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="op">}</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="dt">void</span> reserve<span class="op">(</span><span class="dt">size_type</span> new_capacity<span class="op">){</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="cf">if</span><span class="op">(</span>new_capacity <span class="op">&lt;=</span> capacity<span class="op">())</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>    </span>
<span id="cb14-17"><a href="#cb14-17"></a>    raw_ptr mem <span class="op">=</span> allocate_helper<span class="op">(</span>new_capacity<span class="op">);</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>    copy_old_storage_to_new<span class="op">(</span><span class="va">m_data</span><span class="op">,</span> <span class="va">m_size</span><span class="op">,</span> mem<span class="op">.</span>get<span class="op">());</span> <span class="co">// can throw</span></span>
<span id="cb14-19"><a href="#cb14-19"></a></span>
<span id="cb14-20"><a href="#cb14-20"></a>    <span class="bu">std::</span>destroy<span class="op">(</span><span class="va">m_data</span><span class="op">,</span> <span class="va">m_data</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">);</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>    pointer new_ptr <span class="op">=</span> mem<span class="op">.</span>release<span class="op">();</span></span>
<span id="cb14-22"><a href="#cb14-22"></a>    mem<span class="op">.</span>reset<span class="op">(</span><span class="va">m_data</span><span class="op">);</span></span>
<span id="cb14-23"><a href="#cb14-23"></a>    <span class="va">m_data</span> <span class="op">=</span> new_ptr<span class="op">;</span></span>
<span id="cb14-24"><a href="#cb14-24"></a>    <span class="va">m_capacity</span> <span class="op">=</span> new_capacity<span class="op">;</span></span>
<span id="cb14-25"><a href="#cb14-25"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If <code>new_capacity &gt; capacity()</code>, we must:</p>
<ul>
<li>Allocate a chunk <code>new_capacity * sizeof(T)</code> bytes large on the heap dynamically.</li>
<li>Copy the existing container elements from the old storage area to the new block of memory.</li>
<li>Destruct the elements in the old storage and deallocate the memory occupied.</li>
<li>Update the <code>vector</code>’s <code>m_data</code> pointer and <code>m_capacity</code> field.</li>
</ul>
<p>After the allocation, we want to copy the elements in the range <code>m_data[0...m_size-1]</code> to <code>ptr_new_blk</code>. <code>copy_old_storage_to_new</code> is a helper function to copy <code>num_elements</code> from the memory location <code>source_first</code> to <code>destination_first</code>.</p>
<p>C++17 introduced <code>std::uninitialized_copy</code> and <code>std::uninitialized_move</code> algorithms. <code>std::uninitialized_copy(first, last, d_first)</code> accepts a source range <code>[first,last)</code> and copies the elements from the source range to an uninitialized memory area beginning at <code>d_first</code>. The <code>std::uninitialized_move</code> algorithm uses move semantics.</p>
<p>The beauty of these uninitialized memory algorithms are that they are exception safe. If one of the <code>T(const T&amp;)</code> constructors invoked by <code>uninitialized_copy</code> ends up throwing, then the objects it managed to create before the exception was thrown will be destroyed (in an unspecified order), before the exception leaves the function.</p>
<p>The type-trait <code>std::is_move_constructible_v&lt;T&gt;</code> is meta-function that returns <code>true</code>, if the argument <code>T</code> is move constructible.</p>
<p>If <code>copy_old_storage_to_new</code> throws, <code>mem</code> will go out of scope and being a smart pointer, it will automatically release <code>new_capacity</code> on the heap.</p>
<p>There’s a general trick that you would have seen in all of this. Do not modify your object until you know you can safely do it. Try to do the potentially throwing operations first, then do the operations until you can mutate your object. You will sleep better, and the risks of object corruption will be alleviated.</p>
</section>
<section id="implementing-resize" class="level3">
<h3 class="anchored" data-anchor-id="implementing-resize">Implementing <code>resize()</code></h3>
<p>The distinction between <code>resize()</code> and <code>reserve()</code> is that <code>reserve()</code> only affects the capacity of the container, whereas <code>resize()</code> modifies the size and capacity both.</p>
<p>The <code>resize(size_type new_size)</code> method resizes the container to contain <code>count</code> elements:</p>
<ul>
<li>If the <code>new_size</code> is equal to the current size, do nothing.</li>
<li>If the current size is greater than the <code>new_size</code>, the container is reduced to its first <code>new_size</code> elements.</li>
<li>If the current size is less than <code>new_size</code>, then:
<ul>
<li>Additional default-constructed elements are appended.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="dt">void</span> resize<span class="op">(</span><span class="dt">size_type</span> new_size<span class="op">){</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="dt">size_type</span> current_size <span class="op">=</span> <span class="va">m_size</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="cf">if</span><span class="op">(</span>new_size <span class="op">==</span> current_size<span class="op">)</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="cf">if</span><span class="op">(</span>new_size <span class="op">&lt;</span> current_size<span class="op">)</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>        <span class="co">// Reduce the container to count elements</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>        <span class="bu">std::</span>destroy<span class="op">(</span><span class="va">m_data</span> <span class="op">+</span> new_size<span class="op">,</span> <span class="va">m_data</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">);</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11"></a></span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="cf">if</span><span class="op">(</span>new_size <span class="op">&gt;</span> current_size<span class="op">)</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="op">{</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>        reserve<span class="op">(</span>new_size<span class="op">);</span></span>
<span id="cb15-15"><a href="#cb15-15"></a></span>
<span id="cb15-16"><a href="#cb15-16"></a>        <span class="co">// Default construct elements at indicates</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>        <span class="co">// [current_size,...,new_size-1]</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>        <span class="bu">std::</span>uninitialized_value_construct<span class="op">(</span>begin<span class="op">()</span> <span class="op">+</span> current_size<span class="op">,</span> begin<span class="op">()</span> <span class="op">+</span> new_size<span class="op">);</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>    <span class="op">}</span></span>
<span id="cb15-20"><a href="#cb15-20"></a>    <span class="va">m_size</span> <span class="op">=</span> new_size<span class="op">;</span></span>
<span id="cb15-21"><a href="#cb15-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="how-to-think-about-adding-elements-to-our-container" class="level2">
<h2 class="anchored" data-anchor-id="how-to-think-about-adding-elements-to-our-container">How to think about adding elements to our container?</h2>
<p>We will code up a <code>push_back(T&amp;&amp;)</code> member function that accepts a universal reference <code>T&amp;&amp;</code>. If <code>T</code> is move constructible, then the value will be moved. If <code>T</code> is copy constructible then the value will be copied.</p>
<p>The <code>emplace_back(Args...)</code> will take a variadic pack of constructor arguments, and then perfectly forward them to the constructor of a <code>T</code> object, that will be placed at the end of the container. A reference to the newly constructed object is returned by <code>emplace_back()</code>, for convenience, in case the user-code would like to use it right away.</p>
<p>We would like to first check whether the container is full. We have a dichotomy. If the container is full, we take the so-called slow path, else we take the fast lane.</p>
<section id="push_back_slow_pathvalue" class="level3">
<h3 class="anchored" data-anchor-id="push_back_slow_pathvalue"><code>push_back_slow_path(value)</code></h3>
<p>In this case, we would like to grow our container; we allocate more memory, than what the container currently holds. We leave the memory uninitialized. Memory allocation, can of course, fail.</p>
<p>We then add the new value at the index <code>m_size</code>. Appending the new element may fail.</p>
<p>We copy/move construct the existing elements of the container from the old storage to the new block of storage.</p>
<p>If all three steps were successful, we deallocate the old storage and return it back before replacing the values in the member variables <code>m_data</code>, <code>m_size</code> and <code>m_capacity</code>.</p>
<p>If either of the last couple of steps fail, we free the newly obtained block of storage.</p>
</section>
<section id="push_back_fast_pathvalue" class="level3">
<h3 class="anchored" data-anchor-id="push_back_fast_pathvalue"><code>push_back_fast_path(value)</code></h3>
<p>In this case, we simply copy/move construct <code>value</code> at the end of the container and update the size of the container.</p>
</section>
<section id="edge-case" class="level3">
<h3 class="anchored" data-anchor-id="edge-case">Edge-case</h3>
<p>Consider the following edge-case, where the <code>value</code> to be added is an element of the vector itself. If there is a reallocation, then the elements of the container are relocated to a new region. So, <code>value</code> might become a dangling reference.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a>dev<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  vec<span class="op">.</span>push_back<span class="op">(</span>vec<span class="op">.</span>back<span class="op">());</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  EXPECT_EQ<span class="op">(</span>vec<span class="op">.</span>back<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our design takes care of this edge case.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="dt">void</span> push_back_slow_path<span class="op">(</span>U<span class="op">&amp;&amp;</span> value<span class="op">){</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="co">// allocate more memory</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="dt">size_type</span> new_capacity <span class="op">=</span> capacity<span class="op">()</span> <span class="op">?</span> growth_factor <span class="op">*</span> capacity<span class="op">()</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="dt">size_type</span> offset <span class="op">=</span> size<span class="op">();</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="dt">size_type</span> new_size <span class="op">=</span> <span class="va">m_size</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="kw">auto</span> mem <span class="op">=</span> allocate_helper<span class="op">(</span>new_capacity<span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="bu">std::</span>construct_at<span class="op">(</span>mem<span class="op">.</span>get<span class="op">()</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>value<span class="op">));</span></span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="cf">try</span><span class="op">{</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        copy_old_storage_to_new<span class="op">(</span><span class="va">m_data</span><span class="op">,</span> <span class="va">m_size</span><span class="op">,</span> mem<span class="op">.</span>get<span class="op">());</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="op">}</span><span class="cf">catch</span><span class="op">(</span><span class="bu">std::</span>exception<span class="op">&amp;</span> ex<span class="op">){</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="bu">std::</span>destroy_at<span class="op">(</span>mem<span class="op">.</span>get<span class="op">()</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">);</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="op">}</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>    </span>
<span id="cb17-16"><a href="#cb17-16"></a>    pointer ptr_new <span class="op">=</span> mem<span class="op">.</span>release<span class="op">();</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>    mem<span class="op">.</span>reset<span class="op">(</span><span class="va">m_data</span><span class="op">);</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>    <span class="va">m_data</span> <span class="op">=</span> ptr_new<span class="op">;</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="op">++</span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>    <span class="va">m_capacity</span> <span class="op">=</span> new_capacity<span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="op">}</span></span>
<span id="cb17-22"><a href="#cb17-22"></a></span>
<span id="cb17-23"><a href="#cb17-23"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb17-24"><a href="#cb17-24"></a><span class="dt">void</span> push_back_fast_path<span class="op">(</span>U<span class="op">&amp;&amp;</span> value<span class="op">){</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>    <span class="bu">std::</span>construct_at<span class="op">(</span><span class="va">m_data</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>value<span class="op">));</span></span>
<span id="cb17-26"><a href="#cb17-26"></a>    <span class="op">++</span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27"></a><span class="op">}</span>        </span>
<span id="cb17-28"><a href="#cb17-28"></a></span>
<span id="cb17-29"><a href="#cb17-29"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb17-30"><a href="#cb17-30"></a><span class="dt">void</span> push_back<span class="op">(</span>U<span class="op">&amp;&amp;</span> value<span class="op">)</span></span>
<span id="cb17-31"><a href="#cb17-31"></a><span class="op">{</span></span>
<span id="cb17-32"><a href="#cb17-32"></a>    <span class="cf">if</span><span class="op">(</span>is_full<span class="op">())</span></span>
<span id="cb17-33"><a href="#cb17-33"></a>    <span class="op">{</span></span>
<span id="cb17-34"><a href="#cb17-34"></a>        push_back_slow_path<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>value<span class="op">));</span></span>
<span id="cb17-35"><a href="#cb17-35"></a>    <span class="op">}</span></span>
<span id="cb17-36"><a href="#cb17-36"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb17-37"><a href="#cb17-37"></a>        push_back_fast_path<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>value<span class="op">));</span></span>
<span id="cb17-38"><a href="#cb17-38"></a>    <span class="op">}</span></span>
<span id="cb17-39"><a href="#cb17-39"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="coding-up-emplace_back" class="level3">
<h3 class="anchored" data-anchor-id="coding-up-emplace_back">Coding up <code>emplace_back</code></h3>
<p>Similar to <code>push_back</code>, <code>emplace_back</code> also appends an element to the end of the container. The only difference is, <code>emplace_back</code> constructs a <code>T</code> element in-place in the <code>vector</code>, using the constructor arguments of type <code>T</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="bu">std::</span>construct_at<span class="op">(</span>mem<span class="op">.</span>get<span class="op">()</span> <span class="op">+</span> <span class="va">m_size</span><span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)...);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="implementing-pop_back" class="level2">
<h2 class="anchored" data-anchor-id="implementing-pop_back">Implementing <code>pop_back()</code></h2>
<p><code>pop_back()</code> should call the destructor of the element at index <code>m_size - 1</code>. <code>std::destroy_at(T* p)</code> calls the destructor of the object pointed to by <code>p</code>. It is equivalent to <code>p-&gt;~T()</code>. We must not forget to decrement the size of the container.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> pop_back<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>    T<span class="op">*</span> ptr_to_last <span class="op">=</span> <span class="va">m_data</span> <span class="op">+</span> <span class="va">m_size</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="bu">std::</span>destroy_at<span class="op">(</span>ptr_to_last<span class="op">);</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="op">--</span><span class="va">m_size</span><span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="implementing-insertconst_iterator-position-it-first-it-last" class="level2">
<h2 class="anchored" data-anchor-id="implementing-insertconst_iterator-position-it-first-it-last">Implementing <code>insert(const_iterator position, It first, It last)</code></h2>
<p>The <code>insert</code> function inserts the given value into the vector before the specified <code>position</code>, possibly using move-semantics. Note that, this kind of operation could be expensive for a vector, and if it is frequently used, it can trigger reallocation.</p>
<p>Our <code>insert</code> function will be generic enough with the following interface:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> It<span class="op">&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>iterator insert<span class="op">(</span>const_iterator pos<span class="op">,</span> It first<span class="op">,</span> It last<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It inserts the range <code>[first,last)</code> at position <code>pos</code> (immediately prior to element currently at <code>pos</code>).</p>
<p>I spent some time thinking about <code>.insert</code>, and drawing some quick diagrams helped me generalize the algorithm.</p>
<p>Step 1. We first determine if the elements in the range <code>[first,last)</code> can fit into the <code>remaining_capacity = capacity() - size()</code>. If <code>n</code> exceeds the <code>remaining_capacity</code>, the <code>excess_capacity_reqd</code> we require is <code>std::max(n - remaining_capacity,0)</code>. So, we invoke <code>reserve(capacity() + excess_capacity_reqd)</code>.</p>
<p>Step 2. Assume that we have sufficient room for the range <code>[first,last)</code>.</p>
<p>How many elements should be copied from the <code>[begin(), end())</code> sequqence to the raw memory block at the end of the container?</p>
<p>Consider the scenario, where the range <code>[first,last)</code> is smaller than <code>[pos,end)</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Screenshot 2025-12-31 at 06.08.02.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Screenshot 2025-12-31 at 06.08.02</figcaption>
</figure>
</div>
<p>In this scenario, the elements <code>[end()-n, end())</code> need to be copied or moved to the uninitialized memory.</p>
<p>If there are elements to copy or move from <code>[pos,end())</code> sequence as a replacement to existing objects in the container(there could be none), how many should be there? Looking at the figure below, the subsequence <code>[pos, end() - n)</code> will be mapped to <code>[pos + n, end())</code> upon insertion.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Screenshot 2025-12-31 at 06.31.33.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Screenshot 2025-12-31 at 06.31.33</figcaption>
</figure>
</div>
<p>Consider the scenario, where the range <code>[first,last)</code> is larger than <code>[pos,end)</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Screenshot 2025-12-31 at 06.38.57.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Screenshot 2025-12-31 at 06.38.57</figcaption>
</figure>
</div>
<p>In this case, let’s define <code>num_tail</code> as the trailing number of elements from the source range <code>[first,last)</code> that would be copied/moved to uninitialized memory. Clearly, <code>num_tail = std::max(n - end() + pos,0)</code>. So, the tail <code>[last-num_tail,last)</code> will be mapped to <code>[end(),end()+num_tail)</code> upon insertion.</p>
<p>To make room for the insertion, the elements <code>[pos,end())</code> will have to be moved to <code>[end() + num_tail, end() + num_tail + end() - pos)</code>.</p>
<p>Here is a possible implementation based on our ideas above:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>iterator insert<span class="op">(</span>const_iterator pos<span class="op">,</span> It first<span class="op">,</span> It last<span class="op">){</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>  <span class="kw">auto</span> <span class="va">pos_</span> <span class="op">=</span> <span class="kw">const_cast</span><span class="op">&lt;</span>iterator<span class="op">&gt;(</span>pos<span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="kw">auto</span> <span class="va">first_</span> <span class="op">=</span> first<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="kw">auto</span> <span class="va">last_</span> <span class="op">=</span> last<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a>  <span class="cf">if</span><span class="op">(</span>first <span class="op">!=</span> last<span class="op">)</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  <span class="op">{</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="dt">size_type</span> offset <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span>begin<span class="op">(),</span> <span class="va">pos_</span><span class="op">);</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="dt">size_type</span> n <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span>first<span class="op">,</span> last<span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="dt">size_type</span> num_elems_to_shift <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> end<span class="op">());</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>    <span class="dt">size_type</span> remaining_capacity <span class="op">=</span> capacity<span class="op">()</span> <span class="op">-</span> size<span class="op">();</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>    </span>
<span id="cb21-14"><a href="#cb21-14"></a>    dev<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> temp<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15"></a>    <span class="co">// handle self-referential insertion</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>    <span class="cf">if</span><span class="op">((</span><span class="va">first_</span> <span class="op">&gt;=</span> begin<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="va">first_</span> <span class="op">&lt;</span> end<span class="op">())</span> </span>
<span id="cb21-17"><a href="#cb21-17"></a>    <span class="op">&amp;&amp;</span> <span class="va">last_</span> <span class="op">&gt;</span> begin<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="va">last_</span> <span class="op">&lt;=</span> end<span class="op">())</span></span>
<span id="cb21-18"><a href="#cb21-18"></a>    <span class="op">{</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>      <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it<span class="op">{</span><span class="va">first_</span><span class="op">};</span> it<span class="op">!=</span><span class="va">last_</span><span class="op">;</span> <span class="op">++</span>it<span class="op">)</span></span>
<span id="cb21-20"><a href="#cb21-20"></a>        temp<span class="op">.</span>push_back<span class="op">(*</span>it<span class="op">);</span></span>
<span id="cb21-21"><a href="#cb21-21"></a></span>
<span id="cb21-22"><a href="#cb21-22"></a>      <span class="va">first_</span> <span class="op">=</span> temp<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb21-23"><a href="#cb21-23"></a>      <span class="va">last_</span> <span class="op">=</span> temp<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb21-24"><a href="#cb21-24"></a>    <span class="op">}</span></span>
<span id="cb21-25"><a href="#cb21-25"></a></span>
<span id="cb21-26"><a href="#cb21-26"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&gt;</span> remaining_capacity<span class="op">)</span></span>
<span id="cb21-27"><a href="#cb21-27"></a>    <span class="op">{</span></span>
<span id="cb21-28"><a href="#cb21-28"></a>      <span class="dt">size_type</span> excess_capacity_reqd <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>n <span class="op">-</span> remaining_capacity<span class="op">,</span> <span class="dv">0</span><span class="bu">uz</span><span class="op">);</span></span>
<span id="cb21-29"><a href="#cb21-29"></a>      reserve<span class="op">(</span>capacity<span class="op">()</span> <span class="op">+</span> excess_capacity_reqd<span class="op">);</span></span>
<span id="cb21-30"><a href="#cb21-30"></a>      <span class="co">// The iterator pos is invalidated. Update it.</span></span>
<span id="cb21-31"><a href="#cb21-31"></a>      <span class="va">pos_</span> <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>begin<span class="op">(),</span> offset<span class="op">);</span></span>
<span id="cb21-32"><a href="#cb21-32"></a>    <span class="op">}</span></span>
<span id="cb21-33"><a href="#cb21-33"></a></span>
<span id="cb21-34"><a href="#cb21-34"></a>    <span class="co">// objects to displace (move or copy) from the </span></span>
<span id="cb21-35"><a href="#cb21-35"></a>    <span class="co">// [begin, end()] sequence into raw uninitialized</span></span>
<span id="cb21-36"><a href="#cb21-36"></a>    <span class="co">// memory </span></span>
<span id="cb21-37"><a href="#cb21-37"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&lt;</span> num_elems_to_shift<span class="op">)</span></span>
<span id="cb21-38"><a href="#cb21-38"></a>    <span class="op">{</span></span>
<span id="cb21-39"><a href="#cb21-39"></a>      <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span></span>
<span id="cb21-40"><a href="#cb21-40"></a>      <span class="op">{</span></span>
<span id="cb21-41"><a href="#cb21-41"></a>        <span class="bu">std::</span>uninitialized_move<span class="op">(</span>end<span class="op">()</span> <span class="op">-</span> n<span class="op">,</span> end<span class="op">(),</span> end<span class="op">());</span></span>
<span id="cb21-42"><a href="#cb21-42"></a>      <span class="op">}</span></span>
<span id="cb21-43"><a href="#cb21-43"></a>      <span class="cf">else</span></span>
<span id="cb21-44"><a href="#cb21-44"></a>      <span class="op">{</span></span>
<span id="cb21-45"><a href="#cb21-45"></a>        <span class="bu">std::</span>uninitialized_copy<span class="op">(</span>end<span class="op">()</span> <span class="op">-</span> n<span class="op">,</span> end<span class="op">(),</span> end<span class="op">());</span></span>
<span id="cb21-46"><a href="#cb21-46"></a>      <span class="op">}</span></span>
<span id="cb21-47"><a href="#cb21-47"></a></span>
<span id="cb21-48"><a href="#cb21-48"></a>    <span class="op">}</span><span class="cf">else</span><span class="op">{</span></span>
<span id="cb21-49"><a href="#cb21-49"></a>      <span class="dt">size_type</span> num_tail <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>n <span class="op">-</span> num_elems_to_shift<span class="op">,</span> <span class="dv">0</span><span class="bu">uz</span><span class="op">);</span></span>
<span id="cb21-50"><a href="#cb21-50"></a>      <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span></span>
<span id="cb21-51"><a href="#cb21-51"></a>      <span class="op">{</span></span>
<span id="cb21-52"><a href="#cb21-52"></a>        <span class="bu">std::</span>uninitialized_move<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> end<span class="op">(),</span> end<span class="op">()</span> <span class="op">+</span> num_tail<span class="op">);</span></span>
<span id="cb21-53"><a href="#cb21-53"></a>      <span class="op">}</span></span>
<span id="cb21-54"><a href="#cb21-54"></a>      <span class="cf">else</span></span>
<span id="cb21-55"><a href="#cb21-55"></a>      <span class="op">{</span></span>
<span id="cb21-56"><a href="#cb21-56"></a>        <span class="bu">std::</span>uninitialized_copy<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> end<span class="op">(),</span> end<span class="op">()</span> <span class="op">+</span> num_tail<span class="op">);</span></span>
<span id="cb21-57"><a href="#cb21-57"></a>      <span class="op">}</span></span>
<span id="cb21-58"><a href="#cb21-58"></a>    <span class="op">}</span></span>
<span id="cb21-59"><a href="#cb21-59"></a></span>
<span id="cb21-60"><a href="#cb21-60"></a>    <span class="co">// objects to displace (copy or move) from [pos,end()]</span></span>
<span id="cb21-61"><a href="#cb21-61"></a>    <span class="co">// to the end of the container</span></span>
<span id="cb21-62"><a href="#cb21-62"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&lt;</span> num_elems_to_shift<span class="op">)</span></span>
<span id="cb21-63"><a href="#cb21-63"></a>    <span class="op">{</span></span>
<span id="cb21-64"><a href="#cb21-64"></a>      <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span></span>
<span id="cb21-65"><a href="#cb21-65"></a>      <span class="op">{</span></span>
<span id="cb21-66"><a href="#cb21-66"></a>        <span class="bu">std::</span>move_backward<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> end<span class="op">()</span> <span class="op">-</span> n<span class="op">,</span> end<span class="op">());</span></span>
<span id="cb21-67"><a href="#cb21-67"></a>      <span class="op">}</span></span>
<span id="cb21-68"><a href="#cb21-68"></a>      <span class="cf">else</span></span>
<span id="cb21-69"><a href="#cb21-69"></a>      <span class="op">{</span></span>
<span id="cb21-70"><a href="#cb21-70"></a>        <span class="bu">std::</span>copy_backward<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> end<span class="op">()</span> <span class="op">-</span> n<span class="op">,</span> end<span class="op">());</span></span>
<span id="cb21-71"><a href="#cb21-71"></a>      <span class="op">}</span></span>
<span id="cb21-72"><a href="#cb21-72"></a>    <span class="op">}</span></span>
<span id="cb21-73"><a href="#cb21-73"></a></span>
<span id="cb21-74"><a href="#cb21-74"></a>    <span class="co">// objects from [first,last) to insert into raw</span></span>
<span id="cb21-75"><a href="#cb21-75"></a>    <span class="co">// uninitialized memory</span></span>
<span id="cb21-76"><a href="#cb21-76"></a>    <span class="at">const</span> <span class="dt">size_type</span> num_tail <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>n <span class="op">-</span> num_elems_to_shift<span class="op">,</span> <span class="dv">0</span><span class="bu">uz</span><span class="op">);</span></span>
<span id="cb21-77"><a href="#cb21-77"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&gt;=</span> num_elems_to_shift<span class="op">)</span></span>
<span id="cb21-78"><a href="#cb21-78"></a>    <span class="op">{</span></span>
<span id="cb21-79"><a href="#cb21-79"></a>      <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span></span>
<span id="cb21-80"><a href="#cb21-80"></a>      <span class="op">{</span></span>
<span id="cb21-81"><a href="#cb21-81"></a>        <span class="bu">std::</span>uninitialized_move<span class="op">(</span><span class="va">last_</span> <span class="op">-</span> num_tail<span class="op">,</span> <span class="va">last_</span><span class="op">,</span> end<span class="op">());</span></span>
<span id="cb21-82"><a href="#cb21-82"></a>      <span class="op">}</span></span>
<span id="cb21-83"><a href="#cb21-83"></a>      <span class="cf">else</span></span>
<span id="cb21-84"><a href="#cb21-84"></a>      <span class="op">{</span></span>
<span id="cb21-85"><a href="#cb21-85"></a>        <span class="bu">std::</span>uninitialized_copy<span class="op">(</span><span class="va">last_</span> <span class="op">-</span> num_tail<span class="op">,</span> <span class="va">last_</span><span class="op">,</span> end<span class="op">());</span></span>
<span id="cb21-86"><a href="#cb21-86"></a>      <span class="op">}</span></span>
<span id="cb21-87"><a href="#cb21-87"></a>    <span class="op">}</span></span>
<span id="cb21-88"><a href="#cb21-88"></a>    </span>
<span id="cb21-89"><a href="#cb21-89"></a>    <span class="co">// objects to copy from [first,last) to pos</span></span>
<span id="cb21-90"><a href="#cb21-90"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&lt;</span> num_elems_to_shift<span class="op">)</span></span>
<span id="cb21-91"><a href="#cb21-91"></a>    <span class="op">{</span></span>
<span id="cb21-92"><a href="#cb21-92"></a>      <span class="bu">std::</span>copy<span class="op">(</span><span class="va">first_</span><span class="op">,</span> <span class="va">last_</span><span class="op">,</span> <span class="va">pos_</span><span class="op">);</span></span>
<span id="cb21-93"><a href="#cb21-93"></a>    <span class="op">}</span></span>
<span id="cb21-94"><a href="#cb21-94"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb21-95"><a href="#cb21-95"></a>      <span class="bu">std::</span>copy<span class="op">(</span><span class="va">first_</span><span class="op">,</span> <span class="va">first_</span> <span class="op">+</span> n <span class="op">-</span> num_tail<span class="op">,</span> <span class="va">pos_</span><span class="op">);</span></span>
<span id="cb21-96"><a href="#cb21-96"></a>    <span class="op">}</span></span>
<span id="cb21-97"><a href="#cb21-97"></a></span>
<span id="cb21-98"><a href="#cb21-98"></a>    <span class="va">m_size</span> <span class="op">+=</span> n<span class="op">;</span></span>
<span id="cb21-99"><a href="#cb21-99"></a>  <span class="op">}</span></span>
<span id="cb21-100"><a href="#cb21-100"></a>  <span class="cf">return</span> <span class="va">pos_</span><span class="op">;</span></span>
<span id="cb21-101"><a href="#cb21-101"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Implementing a custom <code>vector&lt;T&gt;</code> from scratch is a rewarding exercise that deepens understanding of C++ fundamentals.</p>
<p>The standard library implementation handles additional complexities I haven’t addressed: custom allocator support, small object optimizations, and numerous other edge cases discovered through decades of production use.</p>
<p>Instead of pointer/size/capacity, we may use <span class="math inline">\(3\)</span> pointers: <code>m_start</code>, <code>m_end</code> and <code>m_end_of_storage</code>. While both layouts occupy <span class="math inline">\(3\)</span> words (<span class="math inline">\(24\)</span> bytes on a <span class="math inline">\(64\)</span>-bit machine), <code>end()</code> is marginally faster, does not require pointer arithmetic and generates fewer assembly instructions.</p>
<p>However, the journey of building this container teaches invaluable lessons. You learn to think carefully about exception safety, understand the tradeoffs between copy and move operations, appreciate the elegance of algorithms like <code>std::uninitialized_copy</code>, and recognize why seemingly simple operations like <code>insert()</code> require careful reasoning about memory layout and iterator invalidation.</p>
<p>If you enjoyed this deep dive, I recommend exploring <code>deque</code>, <code>std::inplace_vector</code>, or the more complex associative containers. Each presents unique challenges and design decisions that will further sharpen your C++ skills.</p>
<p>You can find the complete source listing and unit tests online at <a href="https://compiler-explorer.com/z/9ToK7cdMY">https://compiler-explorer.com/z/9ToK7cdMY</a>.</p>
<p><img src="qr_code.png" width="200" height="200"></p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://www.amazon.co.uk/Memory-Management-leaner-memory-management-techniques/dp/1805129805">C++ Memory Management</a>, by Patrice Roy, Packt Publishing.</li>
<li>The deepest code review of the simplest data structure, <code>vector</code> <a href="https://www.youtube.com/watch?v=GfIxO_vpM4g">https://www.youtube.com/watch?v=GfIxO_vpM4g</a></li>
<li>libstdc++ <code>vector</code> test suite, <a href="https://gnu.googlesource.com/gcc/+/trunk/libstdc++-v3/testsuite/23_containers/vector">https://gnu.googlesource.com/gcc/+/trunk/libstdc++-v3/testsuite/23_containers/vector</a></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>