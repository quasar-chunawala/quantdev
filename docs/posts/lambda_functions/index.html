<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-12-13">

<title>quantdev.blog - Lambda Functions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././symbol.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Lambda Functions</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 13, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#lambdas-in-c11" id="toc-lambdas-in-c11" class="nav-link" data-scroll-target="#lambdas-in-c11">Lambdas in C++11</a>
  <ul class="collapse">
  <li><a href="#core-definitions" id="toc-core-definitions" class="nav-link" data-scroll-target="#core-definitions">Core Definitions</a></li>
  <li><a href="#constructors-and-copying" id="toc-constructors-and-copying" class="nav-link" data-scroll-target="#constructors-and-copying">Constructors and copying</a></li>
  <li><a href="#captures" id="toc-captures" class="nav-link" data-scroll-target="#captures">Captures</a>
  <ul class="collapse">
  <li><a href="#the-mutable-keyword" id="toc-the-mutable-keyword" class="nav-link" data-scroll-target="#the-mutable-keyword">The <code>mutable</code> keyword</a></li>
  <li><a href="#capturing-global-variables" id="toc-capturing-global-variables" class="nav-link" data-scroll-target="#capturing-global-variables">Capturing Global Variables</a></li>
  <li><a href="#capturing-static-variables" id="toc-capturing-static-variables" class="nav-link" data-scroll-target="#capturing-static-variables">Capturing <code>static</code> variables</a></li>
  <li><a href="#caturing-a-class-member-and-the-this-pointer" id="toc-caturing-a-class-member-and-the-this-pointer" class="nav-link" data-scroll-target="#caturing-a-class-member-and-the-this-pointer">Caturing a class member and the <code>this</code> pointer</a></li>
  <li><a href="#moveable-only-objects" id="toc-moveable-only-objects" class="nav-link" data-scroll-target="#moveable-only-objects">Moveable-only objects</a></li>
  <li><a href="#preserving-const" id="toc-preserving-const" class="nav-link" data-scroll-target="#preserving-const">Preserving <code>const</code></a></li>
  <li><a href="#capturing-a-parameter-pack" id="toc-capturing-a-parameter-pack" class="nav-link" data-scroll-target="#capturing-a-parameter-pack">Capturing a parameter pack</a></li>
  </ul></li>
  <li><a href="#return-type" id="toc-return-type" class="nav-link" data-scroll-target="#return-type">Return Type</a></li>
  <li><a href="#iife---immediately-invoked-functional-expression" id="toc-iife---immediately-invoked-functional-expression" class="nav-link" data-scroll-target="#iife---immediately-invoked-functional-expression">IIFE - Immediately Invoked Functional Expression</a></li>
  </ul></li>
  <li><a href="#lambdas-in-c14" id="toc-lambdas-in-c14" class="nav-link" data-scroll-target="#lambdas-in-c14">Lambdas in C++14</a>
  <ul class="collapse">
  <li><a href="#default-parameters-for-lambda-functions" id="toc-default-parameters-for-lambda-functions" class="nav-link" data-scroll-target="#default-parameters-for-lambda-functions">Default parameters for lambda functions</a></li>
  <li><a href="#captures-with-an-initialiser" id="toc-captures-with-an-initialiser" class="nav-link" data-scroll-target="#captures-with-an-initialiser">Captures with an initialiser</a>
  <ul class="collapse">
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  <li><a href="#one-gotcha-with-stdfunction" id="toc-one-gotcha-with-stdfunction" class="nav-link" data-scroll-target="#one-gotcha-with-stdfunction">One gotcha with <code>std::function</code></a></li>
  </ul></li>
  <li><a href="#optimisation" id="toc-optimisation" class="nav-link" data-scroll-target="#optimisation">Optimisation</a></li>
  <li><a href="#capturing-a-class-data-member" id="toc-capturing-a-class-data-member" class="nav-link" data-scroll-target="#capturing-a-class-data-member">Capturing a class data member</a></li>
  <li><a href="#generic-lambdas" id="toc-generic-lambdas" class="nav-link" data-scroll-target="#generic-lambdas">Generic Lambdas</a></li>
  <li><a href="#variadic-generic-arguments" id="toc-variadic-generic-arguments" class="nav-link" data-scroll-target="#variadic-generic-arguments">Variadic Generic Arguments</a></li>
  <li><a href="#perfect-forwarding-with-generic-lambdas" id="toc-perfect-forwarding-with-generic-lambdas" class="nav-link" data-scroll-target="#perfect-forwarding-with-generic-lambdas">Perfect forwarding with generic lambdas</a></li>
  </ul></li>
  <li><a href="#lambdas-in-c17" id="toc-lambdas-in-c17" class="nav-link" data-scroll-target="#lambdas-in-c17">Lambdas in C++17</a>
  <ul class="collapse">
  <li><a href="#overloaded-pattern" id="toc-overloaded-pattern" class="nav-link" data-scroll-target="#overloaded-pattern">Overloaded pattern</a></li>
  <li><a href="#deriving-from-multiple-lambdas" id="toc-deriving-from-multiple-lambdas" class="nav-link" data-scroll-target="#deriving-from-multiple-lambdas">Deriving from multiple lambdas</a>
  <ul class="collapse">
  <li><a href="#custom-template-argument-deduction-rules" id="toc-custom-template-argument-deduction-rules" class="nav-link" data-scroll-target="#custom-template-argument-deduction-rules">Custom Template Argument Deduction Rules</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>I’ve got my hands on the <a href="https://leanpub.com/cpplambda">C++ lambda story</a> by <a href="https://leanpub.com/u/fenbf">Bartłomiej Filipek</a> and wanted to try out a few of the examples.</p>
</section>
<section id="lambdas-in-c11" class="level1">
<h1>Lambdas in C++11</h1>
<p>An example of the most minimal lambda expression is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">// 1. the simplest lambda</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="op">[]{};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>[]</code> section is called the lambda introducer and the empty <code>{}</code> part is for the function body.</p>
<p>By capturing a variable, you create a member copy of that variable in the closure type. Then, inside the lambda body, you can access it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// with a parameter</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">auto</span> area <span class="op">=</span> <span class="op">[](</span><span class="dt">double</span> radius<span class="op">){</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="cf">return</span> <span class="bu">std::</span>pi<span class="op"> *</span> radius <span class="op">*</span> radius<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The arguments are passed into a lambda function like any regular function. The return type is not needed as the compiler will automatically deduce it.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">auto</span> norm <span class="op">=</span> <span class="op">[](</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span><span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">double</span> result<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> i<span class="op">{</span><span class="dv">0</span><span class="bu">uz</span><span class="op">};</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>        result <span class="op">+=</span> v<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> v<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>result<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the above example, we explicitly set a return type. The trailing return type is also available for regular function declaration since C++11.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">auto</span> f <span class="op">=</span> <span class="op">[</span>x<span class="op">](</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">)</span> <span class="at">mutable</span><span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="op">++</span>x<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="cf">return</span> a <span class="op">&lt;</span> b<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="op">};</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">auto</span> g <span class="op">=</span> <span class="op">[](</span><span class="dt">float</span> param<span class="op">)</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    rrtutn param <span class="op">*</span> param<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="op">};</span></span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="kw">auto</span> h <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="at">mutable</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="op">++</span>x<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">return</span> a <span class="op">&lt;</span> b<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Before the body of the lambda, you can use other specifiers. In the code, we used <code>mutable</code> (so that we can change the captured variable) and also <code>noexcept</code>. The third lambda uses <code>mutable</code> and <code>noexcept</code> and they have to appear in that order (you cannot write <code>noexcept mutable</code> as the compiler will reject it).</p>
<p>While the <code>()</code> part is optional, if you want to apply <code>mutable</code> or <code>noexcept</code> then <code>()</code> needs to be in the expression.</p>
<section id="core-definitions" class="level2">
<h2 class="anchored" data-anchor-id="core-definitions">Core Definitions</h2>
<p>The core definition from the C++ standard from <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#2">expr.prim.lambda#2</a> says:</p>
<blockquote class="blockquote">
<p>The evaluation of a lambda-expression results in a <em>prvalue</em> temporary. This temporary is called the <em>closure object</em>.</p>
</blockquote>
<p>From the above definition, we can understand that the compiler generates a unique wrapper class (closure type) from a lambda expression.</p>
<p>Consider the following code snip:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">auto</span> cum_normal_cdf <span class="op">=</span> <span class="op">[](</span><span class="dt">double</span> x<span class="op">){</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="cf">return</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1.0</span> <span class="op">-</span> <span class="bu">std::</span>erf<span class="op">(-</span>x<span class="op">/</span><span class="bu">std::</span>sqrt<span class="op">(</span><span class="fl">2.0</span><span class="op">)))</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://cppinsights.io/s/4f8ddfcc">CppInsights</a> reveals that the C++ compiler creates the following class, where the function call operator <code>()</code> is overloaded.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb6-1"><a href="#cb6-1"></a>class __lambda_4_23</span>
<span id="cb6-2"><a href="#cb6-2"></a>{</span>
<span id="cb6-3"><a href="#cb6-3"></a>  public: </span>
<span id="cb6-4"><a href="#cb6-4"></a>  inline /*constexpr */ double operator()(double x) const</span>
<span id="cb6-5"><a href="#cb6-5"></a>  {</span>
<span id="cb6-6"><a href="#cb6-6"></a>    return 0.5 * (1.0 - erf(-x / sqrt(2.0)));</span>
<span id="cb6-7"><a href="#cb6-7"></a>  }  </span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>  /* ... */</span>
<span id="cb6-10"><a href="#cb6-10"></a>};</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a>__lambda_4_23 cum_normal_cdf = __lambda_4_23{};</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="constructors-and-copying" class="level2">
<h2 class="anchored" data-anchor-id="constructors-and-copying">Constructors and copying</h2>
<p>In the specification of the feature at <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#19">expr.prim.lambda</a>, we can also read the following:</p>
<blockquote class="blockquote">
<p>The closure-type associated with a lambda expression has a deleted default constructor and a deleted copy assignment operator.</p>
</blockquote>
<p>That’s why you cannot write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">double</span> x<span class="op">{</span><span class="dv">10</span><span class="op">},</span> y<span class="op">{</span><span class="dv">20</span><span class="op">};</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">]{</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">++</span>y<span class="op">;</span> <span class="op">};</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">decltype</span><span class="op">(</span>foo<span class="op">)</span> fooCopy<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/7q9bbhro1">Compiler Explorer</a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb8-1"><a href="#cb8-1"></a>&lt;source&gt;: In function 'int main()':</span>
<span id="cb8-2"><a href="#cb8-2"></a>&lt;source&gt;:9:19: error: use of deleted function 'main()::&lt;lambda()&gt;::&lt;lambda&gt;()'</span>
<span id="cb8-3"><a href="#cb8-3"></a>    9 |     decltype(foo) fooCopy;</span>
<span id="cb8-4"><a href="#cb8-4"></a>      |                   ^~~~~~~</span>
<span id="cb8-5"><a href="#cb8-5"></a>&lt;source&gt;:5:23: note: a lambda closure type has a deleted default constructor</span>
<span id="cb8-6"><a href="#cb8-6"></a>    5 |     auto foo = [&amp;x, &amp;y] {</span>
<span id="cb8-7"><a href="#cb8-7"></a>      |                       ^</span>
<span id="cb8-8"><a href="#cb8-8"></a>&lt;source&gt;:9:19: note: use '-fdiagnostics-all-candidates' to display considered candidates</span>
<span id="cb8-9"><a href="#cb8-9"></a>    9 |     decltype(foo) fooCopy;</span>
<span id="cb8-10"><a href="#cb8-10"></a>      |  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, we can copy lambdas:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">using</span> Point <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="kw">auto</span> distance <span class="op">=</span> <span class="op">[](</span>Point x<span class="op">,</span> Point y<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>        <span class="cf">return</span> sqrt<span class="op">(</span>pow<span class="op">((</span>x<span class="op">.</span>first <span class="op">-</span> y<span class="op">.</span>first<span class="op">),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>                    pow<span class="op">((</span>x<span class="op">.</span>second <span class="op">-</span> y<span class="op">.</span>second<span class="op">),</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="op">};</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a>    Point p<span class="op">{</span><span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">};</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>    Point origin<span class="op">{</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">"Distance to (3,4) from the origin = </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> distance<span class="op">(</span>p<span class="op">,</span> origin<span class="op">));</span></span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a>    <span class="kw">auto</span> distance_copy <span class="op">=</span> distance<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>distance<span class="op">),</span> <span class="kw">decltype</span><span class="op">(</span>distance_copy<span class="op">)&gt;);</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/nf7MWaY4z">Compiler Explorer</a></p>
</section>
<section id="captures" class="level2">
<h2 class="anchored" data-anchor-id="captures">Captures</h2>
<p>The <code>[]</code> does not only introduce the lambda but also holds the list of <em>captured variables</em>. It’s called the <em>capture clause</em>. By capturing a variable from outside the scope of the lambda, you create a non-static data member in the closure type. Then, inside the lambda body, you can access it.</p>
<p>The syntax for captures in C++11 are:</p>
<div id="tbl-lambda-syntax" class="anchored">
<table class="table">
<caption>Table&nbsp;1: Lambda capture syntax in C++</caption>
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<thead>
<tr class="header">
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[&amp;]</code></td>
<td>Capture by reference all automatic storage duration variables declared in the reaching scope.</td>
</tr>
<tr class="even">
<td><code>[=]</code></td>
<td>Capture by value (create a copy) all automatic storage duration variables declared in the reaching scope.</td>
</tr>
<tr class="odd">
<td><code>[x, &amp;y]</code></td>
<td>Capture <code>x</code> by value, capture <code>y</code> by reference</td>
</tr>
<tr class="even">
<td><code>[args...]</code></td>
<td>Capture a template argument pack all by value</td>
</tr>
<tr class="odd">
<td><code>[&amp;args...]</code></td>
<td>Capture a template argument pack all by reference</td>
</tr>
<tr class="even">
<td><code>[this]</code></td>
<td>Captures the <code>this</code> pointer inside the member function</td>
</tr>
</tbody>
</table>
</div>
<p>Note that for <code>[=]</code> and <code>[&amp;]</code> cases, the compiler generates data members for all used variables inside the lambda body. This is a convenient syntax where you don’t want to explicitly mention which variables you capture.</p>
<section id="the-mutable-keyword" class="level3">
<h3 class="anchored" data-anchor-id="the-mutable-keyword">The <code>mutable</code> keyword</h3>
<p>By default the <code>operator()</code> of the closure type is marked as <code>const</code> and you cannot modify the captured variables inside the body of the lambda. If you want to change this behavior, you need to add the <code>mutable</code> keyword after the parameter list. This syntax removes the <code>const</code> from the call operator declaration in the closure type.</p>
<p>If you have a simple lambda expression with a <code>mutable</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">int</span> x<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[</span>x<span class="op">]()</span> <span class="at">mutable</span> <span class="op">{</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It will be expanded into the following function object:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb11-1"><a href="#cb11-1"></a>struct __lambda_x1 {</span>
<span id="cb11-2"><a href="#cb11-2"></a>    void operator()() { ++x; }</span>
<span id="cb11-3"><a href="#cb11-3"></a>    int x;</span>
<span id="cb11-4"><a href="#cb11-4"></a>};</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The call operator can change the value of the member-fields(capture variables).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="at">const</span> <span class="kw">auto</span> print <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> str<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> str <span class="op">&lt;&lt;</span> <span class="st">": "</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">" "</span> <span class="op">&lt;&lt;</span> y <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="op">};</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="dt">int</span> x<span class="op">{</span><span class="dv">1</span><span class="op">},</span> y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    print<span class="op">(</span><span class="st">"in main"</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">,</span> <span class="op">&amp;</span>print<span class="op">]()</span> <span class="at">mutable</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="op">++</span>x<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>        <span class="op">++</span>y<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>        print<span class="op">(</span><span class="st">"in foo"</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="op">};</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>    foo<span class="op">();</span></span>
<span id="cb12-16"><a href="#cb12-16"></a>    print<span class="op">(</span><span class="st">"in main()"</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/9Tncca1do">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb13-1"><a href="#cb13-1"></a>in main: 1 1</span>
<span id="cb13-2"><a href="#cb13-2"></a>in foo: 2 2</span>
<span id="cb13-3"><a href="#cb13-3"></a>in main(): 1 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the above example, we can change the values of <code>x</code> and <code>y</code>. Since those are only the copies of <code>x</code> and <code>y</code> from the enclosing scope, we don’t see their new values after <code>foo</code> is invoked.</p>
<p>On the other hand, if you capture by reference, you don’t need to apply the <code>mutable</code> keyword to modify the value. This is because the captured data members are references which means that you cannot rebound them to a new object anyway, but you can change the referenced values.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">int</span> x<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="at">const</span> <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[&amp;</span>x<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">};</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    foo<span class="op">();</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/Yjjqdd3zf">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb15-1"><a href="#cb15-1"></a>Program stdout</span>
<span id="cb15-2"><a href="#cb15-2"></a>1</span>
<span id="cb15-3"><a href="#cb15-3"></a>2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the above example, the lambda is not specified with <code>mutable</code> but it can change the referenced value.</p>
<p>One important thing is that when you apply <code>mutable</code>, then you canot mark your resulting closure object with <code>const</code> as it prevents you from invoking the lambda!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="dt">int</span> x<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="at">const</span> <span class="kw">auto</span> lam <span class="op">=</span> <span class="op">[</span>x<span class="op">]()</span> <span class="at">mutable</span> <span class="op">{</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">};</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">// lam(); // compile eror</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The last line won’t compile as we cannot call a non-<code>const</code> member function on a <code>const</code> object.</p>
</section>
<section id="capturing-global-variables" class="level3">
<h3 class="anchored" data-anchor-id="capturing-global-variables">Capturing Global Variables</h3>
<p>If you have a global variable and you use <code>[=]</code> in your lambda, you might think that your global object is also captured by value. But, it’s not.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="dt">int</span> global<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> global <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[=]()</span> <span class="at">mutable</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>global<span class="op">;</span> <span class="op">};</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    foo<span class="op">();</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> global <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="at">const</span> <span class="kw">auto</span> increaseGlobal <span class="op">=</span> <span class="op">[]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>global<span class="op">;</span> <span class="op">};</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>    increaseGlobal<span class="op">();</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> global <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>    <span class="at">const</span> <span class="kw">auto</span> moreIncreaseGlobal <span class="op">=</span> <span class="op">[</span>global<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>global<span class="op">;</span> <span class="op">};</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>    moreIncreaseGlobal<span class="op">();</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> global <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/aTG3qP5vM">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb18-1"><a href="#cb18-1"></a>10</span>
<span id="cb18-2"><a href="#cb18-2"></a>11</span>
<span id="cb18-3"><a href="#cb18-3"></a>12</span>
<span id="cb18-4"><a href="#cb18-4"></a>13</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the above example, we have defined a static variable <code>global</code> and then used it with several lambdas defined in the <code>main()</code> function. If you run the code, then no matter the way you captgure, it will always point to the global object, and no local copies will be created.</p>
<p>Line 13 of the code causes the compiler to generate the following warning:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb19-1"><a href="#cb19-1"></a>source&gt;: In function 'int main()':</span>
<span id="cb19-2"><a href="#cb19-2"></a>&lt;source&gt;:13:38: warning: capture of variable 'global' with non-automatic storage duration</span>
<span id="cb19-3"><a href="#cb19-3"></a>   13 |     const auto moreIncreaseGlobal = [global]() noexcept { ++global; };</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It’s because only variables with automatic storage duration can be captured.</p>
<p>If you use <code>[=]</code> explicitly, the compiler won’t help you and it generates an error.</p>
</section>
<section id="capturing-static-variables" class="level3">
<h3 class="anchored" data-anchor-id="capturing-static-variables">Capturing <code>static</code> variables</h3>
<p>Similar to capturing global variables, you’ll get the same issues with <code>static</code> objects:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="dt">void</span> bar<span class="op">()</span> <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="at">static</span> <span class="dt">int</span> static_int<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> static_int <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[=]()</span> <span class="at">mutable</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>static_int<span class="op">;</span> <span class="op">};</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>    foo<span class="op">();</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> static_int <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="at">const</span> <span class="kw">auto</span> increase <span class="op">=</span> <span class="op">[]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>static_int<span class="op">;</span> <span class="op">};</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    increase<span class="op">();</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> static_int <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="at">const</span> <span class="kw">auto</span> moreIncrease <span class="op">=</span> <span class="op">[</span>static_int<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>static_int<span class="op">;</span> <span class="op">};</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>    moreIncrease<span class="op">();</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> static_int <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="op">}</span></span>
<span id="cb20-16"><a href="#cb20-16"></a></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    bar<span class="op">();</span></span>
<span id="cb20-19"><a href="#cb20-19"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-20"><a href="#cb20-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/xbGbh3hTW">Compiler Explorer</a></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb21-1"><a href="#cb21-1"></a>10</span>
<span id="cb21-2"><a href="#cb21-2"></a>11</span>
<span id="cb21-3"><a href="#cb21-3"></a>12</span>
<span id="cb21-4"><a href="#cb21-4"></a>13</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="caturing-a-class-member-and-the-this-pointer" class="level3">
<h3 class="anchored" data-anchor-id="caturing-a-class-member-and-the-this-pointer">Caturing a class member and the <code>this</code> pointer</h3>
<p>Things get a bit more complicated where you’re in a class member function and you want to capture a data member. Since all non-static data members are related to the <code>this</code> pointer, it also has to be stored somewhere.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">struct</span> Baz<span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="dt">void</span> foo<span class="op">(){</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>        <span class="at">const</span> <span class="kw">auto</span> lam <span class="op">=</span> <span class="op">[</span>s<span class="op">](){</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> s<span class="op">;</span> <span class="op">};</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>        lam<span class="op">();</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    <span class="op">}</span></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a>    <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="op">};</span></span>
<span id="cb22-11"><a href="#cb22-11"></a></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="op">{</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>    Baz b<span class="op">;</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>    b<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/x3b3GEnox">Compiler Explorer</a></p>
<p>The code tries to capture <code>s</code> which is a data-member. But the compiler will emit the following message:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb23-1"><a href="#cb23-1"></a>&lt;source&gt;: In member function 'void Baz::foo()':</span>
<span id="cb23-2"><a href="#cb23-2"></a>&lt;source&gt;:5:27: error: capture of non-variable 'Baz::s'</span>
<span id="cb23-3"><a href="#cb23-3"></a>    5 |         const auto lam = [s]() { std::cout &lt;&lt; s; };</span>
<span id="cb23-4"><a href="#cb23-4"></a>      |                           ^</span>
<span id="cb23-5"><a href="#cb23-5"></a>&lt;source&gt;:9:17: note: 'std::string Baz::s' declared here</span>
<span id="cb23-6"><a href="#cb23-6"></a>    9 |     std::string s;</span>
<span id="cb23-7"><a href="#cb23-7"></a>      |                 ^</span>
<span id="cb23-8"><a href="#cb23-8"></a>&lt;source&gt;: In lambda function:</span>
<span id="cb23-9"><a href="#cb23-9"></a>&lt;source&gt;:5:47: error: 'this' was not captured for this lambda function</span>
<span id="cb23-10"><a href="#cb23-10"></a>    5 |         const auto lam = [s]() { std::cout &lt;&lt; s; };</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To solve this issue, we have to capture the <code>this</code> pointer. Then, we have access to the data members. We can updaten the code to:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">struct</span> Baz<span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="dt">void</span> foo<span class="op">(){</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>        <span class="at">const</span> <span class="kw">auto</span> lam <span class="op">=</span> <span class="op">[</span><span class="kw">this</span><span class="op">](){</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> s<span class="op">;</span> <span class="op">};</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>        lam<span class="op">();</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8"></a></span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="op">};</span></span>
<span id="cb24-11"><a href="#cb24-11"></a></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="op">{</span></span>
<span id="cb24-14"><a href="#cb24-14"></a>    Baz b<span class="op">;</span></span>
<span id="cb24-15"><a href="#cb24-15"></a>    b<span class="op">.</span>foo<span class="op">();</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/jxfEEaT1b">Compiler Explorer</a></p>
<p>There are no compiler errors now.</p>
<p>We can also use <code>[=]</code> or <code>[&amp;]</code> to capture <code>this</code>. They both have the same effect in C++11/14. Note that, we captured <code>this</code> by value to a pointer. That’s why we have access to the initial data-member and not its copy.</p>
<p>The value of the value-captured variable is the value at the time the lambda is defined - not when it is used. The value of a ref-captured variable is the value when the lambda is used - not when it is defined.</p>
<p>The C++ closures do not extend the lifetimes of the captured references. We must be sure that the capture variable still lives when the lambda is invoked.</p>
</section>
<section id="moveable-only-objects" class="level3">
<h3 class="anchored" data-anchor-id="moveable-only-objects">Moveable-only objects</h3>
<p>If you have an object that is moveable only(for example a <code>unique_ptr</code>), then we can move the object into a member of the closure type:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> p <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"Before definition pointer in main(): "</span> <span class="op">&lt;&lt;</span> p<span class="op">.</span>get<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>    <span class="at">const</span> <span class="kw">auto</span> bar <span class="op">=</span> <span class="op">[</span>ptr <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>p<span class="op">)]</span> <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"pointer in lambda: "</span> <span class="op">&lt;&lt;</span> ptr<span class="op">.</span>get<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"value in lambda: "</span> <span class="op">&lt;&lt;</span> <span class="op">*</span>ptr <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="op">};</span></span>
<span id="cb25-12"><a href="#cb25-12"></a></span>
<span id="cb25-13"><a href="#cb25-13"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"After definition pointer in main(): "</span> <span class="op">&lt;&lt;</span> p<span class="op">.</span>get<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14"></a>    bar<span class="op">();</span></span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/Te795K88b">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb26-1"><a href="#cb26-1"></a>Before definition pointer in main(): 0x209772b0</span>
<span id="cb26-2"><a href="#cb26-2"></a>After definition pointer in main(): 0</span>
<span id="cb26-3"><a href="#cb26-3"></a>pointer in lambda: 0x209772b0</span>
<span id="cb26-4"><a href="#cb26-4"></a>value in lambda: 10</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="preserving-const" class="level3">
<h3 class="anchored" data-anchor-id="preserving-const">Preserving <code>const</code></h3>
<p>If you capture a <code>const</code> variable, then the <code>const</code>-ness is preserved:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="at">const</span> <span class="dt">int</span> x<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[</span>x<span class="op">]()</span> <span class="at">mutable</span><span class="op">{</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>is_const<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>x<span class="op">)&gt;::</span>value <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>        x <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="op">}</span></span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a>    foo<span class="op">();</span></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/GEGnYh81K">Compiler Explorer</a></p>
<p>This code will not compile.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb28-1"><a href="#cb28-1"></a>&lt;source&gt;: In lambda function:</span>
<span id="cb28-2"><a href="#cb28-2"></a>&lt;source&gt;:9:15: error: assignment of read-only variable 'x'</span>
<span id="cb28-3"><a href="#cb28-3"></a>    9 |             x = 11;</span>
<span id="cb28-4"><a href="#cb28-4"></a>      |             ~~^~~~</span>
<span id="cb28-5"><a href="#cb28-5"></a>&lt;source&gt;: In function 'int main()':</span>
<span id="cb28-6"><a href="#cb28-6"></a>&lt;source&gt;:12:5: error: expected ',' or ';' before 'foo'</span>
<span id="cb28-7"><a href="#cb28-7"></a>   12 |     foo();</span>
<span id="cb28-8"><a href="#cb28-8"></a>      |     ^~~</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="capturing-a-parameter-pack" class="level3">
<h3 class="anchored" data-anchor-id="capturing-a-parameter-pack">Capturing a parameter pack</h3>
<p>We can also leverage captures with variadic templates. The compiler expands the pack into a list of non-static data members whihc might be handy, if you want to use lambda in templated code.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="dt">void</span> captureTest<span class="op">(</span>Args<span class="op">...</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>    <span class="at">const</span> <span class="kw">auto</span> lambda <span class="op">=</span> <span class="op">[</span>args<span class="op">...]</span> <span class="op">{</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>        <span class="at">const</span> <span class="kw">auto</span> tup <span class="op">=</span> <span class="bu">std::</span>make_tuple<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"tuple size: "</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>tuple_size<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>tup<span class="op">)&gt;::</span>value</span>
<span id="cb29-9"><a href="#cb29-9"></a>                  <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"tuple 1st: "</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>tup<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="op">};</span></span>
<span id="cb29-12"><a href="#cb29-12"></a>    lambda<span class="op">();</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>    captureTest<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb29-17"><a href="#cb29-17"></a>    captureTest<span class="op">(</span><span class="st">"Hello World"</span><span class="op">,</span> <span class="fl">10.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb29-18"><a href="#cb29-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/eGYEPxo8M">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb30-1"><a href="#cb30-1"></a>tuple size: 4</span>
<span id="cb30-2"><a href="#cb30-2"></a>tuple 1st: 1</span>
<span id="cb30-3"><a href="#cb30-3"></a>tuple size: 2</span>
<span id="cb30-4"><a href="#cb30-4"></a>tuple 1st: Hello World</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="return-type" class="level2">
<h2 class="anchored" data-anchor-id="return-type">Return Type</h2>
<p>In most cases, you can skip the return type of the lambda and the compiler will deduce the typename for you. The compiler is able to deduce the return type as long as all of your return statements are of the same type.</p>
</section>
<section id="iife---immediately-invoked-functional-expression" class="level2">
<h2 class="anchored" data-anchor-id="iife---immediately-invoked-functional-expression">IIFE - Immediately Invoked Functional Expression</h2>
<p>In most of the examples, we’ve seen so far, notice that we defined ht lambda and then immediately called it later. However, you can also invoke a lambda immediately.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="dt">int</span> x<span class="op">{</span><span class="dv">1</span><span class="op">},</span> y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="op">[&amp;]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">++</span>y<span class="op">;</span> <span class="op">}();</span>     <span class="co">// call</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">", "</span> <span class="op">&lt;&lt;</span> y<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="lambdas-in-c14" class="level1">
<h1>Lambdas in C++14</h1>
<section id="default-parameters-for-lambda-functions" class="level2">
<h2 class="anchored" data-anchor-id="default-parameters-for-lambda-functions">Default parameters for lambda functions</h2>
<p>Let’s start with smaller updates. In C++14, you can use default parameters in a lambda function definition.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    <span class="at">const</span> <span class="kw">auto</span> lam <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">){</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>    lam<span class="op">();</span></span>
<span id="cb32-7"><a href="#cb32-7"></a>    lam<span class="op">(</span><span class="dv">100</span><span class="op">);</span></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/W7ne1jKh5">Compiler Explorer</a></p>
</section>
<section id="captures-with-an-initialiser" class="level2">
<h2 class="anchored" data-anchor-id="captures-with-an-initialiser">Captures with an initialiser</h2>
<p>We recall that, in a lambda expression, we can capture variables form the outside scope. The compiler expands that capture syntax and creates corresponding non-static data members in the closure type.</p>
<p>In C++14, you can create new data-members and initialize them in the capture clause. Then, you can access those variables inside the lambda. It’s called <em>capture with an initialiser</em> or another name for this feature is <em>generalized lambda capture</em>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="dt">int</span> x<span class="op">{</span><span class="dv">30</span><span class="op">};</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="dt">int</span> y<span class="op">{</span><span class="dv">12</span><span class="op">};</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="at">const</span> <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[</span>z <span class="op">=</span> x <span class="op">+</span> y<span class="op">]{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> z <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>    x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>    y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>    foo<span class="op">();</span></span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/9czGEbY4v">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb34-1"><a href="#cb34-1"></a>42</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Keep in mind, that the new variable is initialized at the place where you define the lambda and not where you invoke it.</p>
<p>Creating variables through an initialiser is also flexible, since you can, for example, create references to variables from outside scope.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="dt">int</span> x<span class="op">{</span><span class="dv">30</span><span class="op">};</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="at">const</span> <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[&amp;</span>z <span class="op">=</span> x<span class="op">]()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> z <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>    foo<span class="op">();</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>    x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>    foo<span class="op">();</span></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb36-1"><a href="#cb36-1"></a>30</span>
<span id="cb36-2"><a href="#cb36-2"></a>0</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<p>Note, that while you can capture by reference with an initialiser, it’s not possible to write <em>rvalue</em> reference <code>&amp;&amp;</code>. So, the below code would be invalid.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="op">[&amp;&amp;</span>z <span class="op">=</span> x<span class="op">]</span>   <span class="co">//invalid syntax!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="one-gotcha-with-stdfunction" class="level3">
<h3 class="anchored" data-anchor-id="one-gotcha-with-stdfunction">One gotcha with <code>std::function</code></h3>
<p>Having a moveable-only captured variable in a lambda makes the closure object not copyable. This might be an issue if you want to store such a lambda in <code>std::function</code> which accepts only copyable copy objects.</p>
</section>
</section>
<section id="optimisation" class="level2">
<h2 class="anchored" data-anchor-id="optimisation">Optimisation</h2>
<p>Another idea is to use capture initialisers as a potential optimisation technique. Rather than computing some value every time, we invoke a lambda, we can compute it once in. the initialiser:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb38-5"><a href="#cb38-5"></a></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="op">{</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>string_literals<span class="op">;</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>    <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> vs <span class="op">=</span> <span class="op">{</span></span>
<span id="cb38-10"><a href="#cb38-10"></a>        <span class="st">"apple"</span><span class="op">,</span> <span class="st">"orange"</span><span class="op">,</span></span>
<span id="cb38-11"><a href="#cb38-11"></a>        <span class="st">"foobar"</span><span class="op">,</span> <span class="st">"lemon"</span></span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="op">};</span></span>
<span id="cb38-13"><a href="#cb38-13"></a>    <span class="at">const</span> <span class="kw">auto</span> prefix <span class="op">=</span> <span class="st">"foo"</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14"></a></span>
<span id="cb38-15"><a href="#cb38-15"></a>    <span class="kw">auto</span> result <span class="op">=</span> <span class="bu">std::</span>find_if<span class="op">(</span>vs<span class="op">.</span>begin<span class="op">(),</span> vs<span class="op">.</span>end<span class="op">(),</span></span>
<span id="cb38-16"><a href="#cb38-16"></a>        <span class="op">[&amp;</span>prefix<span class="op">](</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb38-17"><a href="#cb38-17"></a>            <span class="cf">return</span> s <span class="op">==</span> prefix <span class="op">+</span> <span class="st">"bar"</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb38-18"><a href="#cb38-18"></a>        <span class="op">}</span></span>
<span id="cb38-19"><a href="#cb38-19"></a>    <span class="op">);</span></span>
<span id="cb38-20"><a href="#cb38-20"></a></span>
<span id="cb38-21"><a href="#cb38-21"></a>    <span class="cf">if</span><span class="op">(</span>result <span class="op">!=</span> vs<span class="op">.</span>end<span class="op">())</span></span>
<span id="cb38-22"><a href="#cb38-22"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> prefix <span class="op">&lt;&lt;</span> <span class="st">"-something found!</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb38-23"><a href="#cb38-23"></a></span>
<span id="cb38-24"><a href="#cb38-24"></a>    result <span class="op">=</span> std<span class="op">:</span>find_if<span class="op">(</span>vs<span class="op">.</span>begin<span class="op">(),</span> vs<span class="op">.</span>end<span class="op">(),</span></span>
<span id="cb38-25"><a href="#cb38-25"></a>        <span class="op">[</span>savedString <span class="op">=</span> prefix <span class="op">+</span> <span class="st">"bar"</span><span class="bu">s</span><span class="op">](</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb38-26"><a href="#cb38-26"></a>            <span class="cf">return</span> s <span class="op">==</span> savedString<span class="op">;</span></span>
<span id="cb38-27"><a href="#cb38-27"></a>        <span class="op">}</span></span>
<span id="cb38-28"><a href="#cb38-28"></a>    <span class="op">);</span></span>
<span id="cb38-29"><a href="#cb38-29"></a></span>
<span id="cb38-30"><a href="#cb38-30"></a>    <span class="cf">if</span><span class="op">(</span>result <span class="op">!=</span> vs<span class="op">.</span>end<span class="op">())</span></span>
<span id="cb38-31"><a href="#cb38-31"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> prefix <span class="op">&lt;&lt;</span> <span class="st">"-something found!</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb38-32"><a href="#cb38-32"></a></span>
<span id="cb38-33"><a href="#cb38-33"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-34"><a href="#cb38-34"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The code above shows two calls to <code>std::find_if</code>. In the first scernario, we capture <code>prefix</code> and compare the input value against <code>prefix + "bar"s</code>. Everytime the lambda is invokes, a temporary value that stores the sum of those strings has to be created and computed.</p>
<p>The second call to <code>find_if</code> shows an optimisation: we create a captured variable <code>savedString</code> that computes the sum of the strings. then, we can safely refer to it in the lambda body. The sum of the strings will run only once and not with every invocation of the lambda.</p>
</section>
<section id="capturing-a-class-data-member" class="level2">
<h2 class="anchored" data-anchor-id="capturing-a-class-data-member">Capturing a class data member</h2>
<p>An initialiser can also be used to capture data members without worrying about <code>*this</code> pointer. We can capgture a copy of a data member and not bother with dangling references.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3"></a></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="kw">struct</span> Baz<span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>    <span class="kw">auto</span> foo<span class="op">()</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>        <span class="cf">return</span> <span class="op">[</span>s<span class="op">=</span>s<span class="op">]{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb39-7"><a href="#cb39-7"></a>    <span class="op">}</span></span>
<span id="cb39-8"><a href="#cb39-8"></a></span>
<span id="cb39-9"><a href="#cb39-9"></a>    <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="op">};</span></span>
<span id="cb39-11"><a href="#cb39-11"></a></span>
<span id="cb39-12"><a href="#cb39-12"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb39-13"><a href="#cb39-13"></a><span class="op">{</span></span>
<span id="cb39-14"><a href="#cb39-14"></a>    <span class="at">const</span> <span class="kw">auto</span> f1 <span class="op">=</span> Baz<span class="op">{</span><span class="st">"abc"</span><span class="op">}.</span>foo<span class="op">();</span></span>
<span id="cb39-15"><a href="#cb39-15"></a>    <span class="at">const</span> <span class="kw">auto</span> f2 <span class="op">=</span> Baz<span class="op">{</span><span class="st">"xyz"</span><span class="op">}.</span>foo<span class="op">();</span></span>
<span id="cb39-16"><a href="#cb39-16"></a>    f1<span class="op">();</span></span>
<span id="cb39-17"><a href="#cb39-17"></a>    f2<span class="op">();</span></span>
<span id="cb39-18"><a href="#cb39-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/TY98T8nxM">Compiler Explorer</a></p>
</section>
<section id="generic-lambdas" class="level2">
<h2 class="anchored" data-anchor-id="generic-lambdas">Generic Lambdas</h2>
<p>The early specification of lambda expressions allowed us to create anonymous function objects (closure types) and pass them to various generic algorithms from the standard library. However, closures were not generic on their own. For example, you couldn’t specify a template parameter as a lambda parameter.</p>
<p>Fortunately, since C++14, the Standard introduced <em>generic lambdas</em> and now we can write:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="at">const</span> <span class="kw">auto</span> foo <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span> <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span> <span class="op">};</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>foo<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>foo<span class="op">(</span><span class="fl">10.1234</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>foo<span class="op">(</span><span class="st">"hello world"</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Please notice <code>auto x</code> as a parameter to the lambda. This is equivalent to using a template declaration in the call operator of the closure type:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">struct</span><span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>Tx<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>        <span class="bu">std::</span>print<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>    <span class="op">}</span></span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="op">}</span> someInstance<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If there are more <code>auto</code> arguments, then the code expands to separate template parameters:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="at">const</span> <span class="kw">auto</span> fooDouble <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> x<span class="op">,</span> <span class="kw">auto</span> y<span class="op">){</span> <span class="co">/*...*/</span> <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>expands into:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">struct</span><span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> typenname U<span class="op">&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>Tx<span class="op">,</span> U y<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>        <span class="co">/* ... */</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="op">}</span></span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="op">}</span> someInstance<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="variadic-generic-arguments" class="level2">
<h2 class="anchored" data-anchor-id="variadic-generic-arguments">Variadic Generic Arguments</h2>
<p>If we need more function parameters, then we can also go <em>variadic</em>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="kw">auto</span> sum<span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-5"><a href="#cb44-5"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="op">}</span></span>
<span id="cb44-7"><a href="#cb44-7"></a></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T1<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb44-9"><a href="#cb44-9"></a><span class="kw">auto</span> sum<span class="op">(</span>T1 s<span class="op">,</span> T<span class="op">...</span> ts<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-10"><a href="#cb44-10"></a>    <span class="cf">return</span> s <span class="op">+</span> sum<span class="op">(</span>ts<span class="op">...);</span></span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="op">}</span></span>
<span id="cb44-12"><a href="#cb44-12"></a></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb44-14"><a href="#cb44-14"></a>    <span class="at">const</span> <span class="kw">auto</span> sumLambda <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">...</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-15"><a href="#cb44-15"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"sum of: "</span> <span class="op">&lt;&lt;</span> <span class="kw">sizeof</span><span class="op">...(</span>args<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">" numbers</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb44-16"><a href="#cb44-16"></a>        <span class="cf">return</span> sum<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb44-17"><a href="#cb44-17"></a>    <span class="op">};</span></span>
<span id="cb44-18"><a href="#cb44-18"></a></span>
<span id="cb44-19"><a href="#cb44-19"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> sumLambda<span class="op">(</span><span class="fl">1.1</span><span class="op">,</span> <span class="fl">2.2</span><span class="op">,</span> <span class="fl">3.3</span><span class="op">,</span> <span class="fl">4.4</span><span class="op">,</span> <span class="fl">5.5</span><span class="op">,</span> <span class="fl">6.6</span><span class="op">,</span> <span class="fl">7.7</span><span class="op">,</span> <span class="fl">8.8</span><span class="op">,</span> <span class="fl">9.9</span><span class="op">);</span></span>
<span id="cb44-20"><a href="#cb44-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/z34cTcabh">Compiler Explorer</a></p>
</section>
<section id="perfect-forwarding-with-generic-lambdas" class="level2">
<h2 class="anchored" data-anchor-id="perfect-forwarding-with-generic-lambdas">Perfect forwarding with generic lambdas</h2>
<p>With generic lambdas, we’re not restricted to using <code>auto x</code>, we can add any qualifiers as with other <code>auto</code> variables such as <code>auto&amp;</code>, <code>const auto&amp;</code> or <code>auto&amp;&amp;</code>. One of the handy use cases is that we can specify <code>auto&amp;&amp; x</code> which becomes a forwarding(universal) reference.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="dt">void</span> foo<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> <span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"foo(const string&amp;)"</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="dt">void</span> foo<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;)</span>  <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"foo(std::string&amp;&amp;)"</span><span class="op">);</span> <span class="op">}</span> </span>
<span id="cb45-6"><a href="#cb45-6"></a></span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="op">{</span></span>
<span id="cb45-9"><a href="#cb45-9"></a>    <span class="at">const</span> <span class="kw">auto</span> callFoo <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> str<span class="op">){</span></span>
<span id="cb45-10"><a href="#cb45-10"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Calling foo() on: </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> str<span class="op">);</span></span>
<span id="cb45-11"><a href="#cb45-11"></a>        foo<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>str<span class="op">)&gt;(</span>str<span class="op">));</span></span>
<span id="cb45-12"><a href="#cb45-12"></a>    <span class="op">};</span></span>
<span id="cb45-13"><a href="#cb45-13"></a></span>
<span id="cb45-14"><a href="#cb45-14"></a>    <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>str <span class="op">=</span> <span class="st">"Hello World"</span><span class="op">;</span></span>
<span id="cb45-15"><a href="#cb45-15"></a>    callFoo<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb45-16"><a href="#cb45-16"></a>    callFoo<span class="op">(</span><span class="st">"Helo World Ref Ref"</span><span class="op">);</span></span>
<span id="cb45-17"><a href="#cb45-17"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/rdEsPK8va">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb46-1"><a href="#cb46-1"></a>Calling foo() on: Hello World</span>
<span id="cb46-2"><a href="#cb46-2"></a>foo(const string&amp;)</span>
<span id="cb46-3"><a href="#cb46-3"></a>Calling foo() on: Helo World Ref Ref</span>
<span id="cb46-4"><a href="#cb46-4"></a>foo(std::string&amp;&amp;)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="lambdas-in-c17" class="level1">
<h1>Lambdas in C++17</h1>
<p>C++17 brought one major enhancement to lambdas: they can be declared <code>constexpr</code>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> square <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> n<span class="op">){</span> <span class="cf">return</span> n<span class="op">*</span>n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">static_assert</span><span class="op">(</span>square<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How about some more practical examples? It’s fun to write a simple compile-time hash function for strings.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb48-4"><a href="#cb48-4"></a></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="kw">constexpr</span> <span class="kw">auto</span> hornerHash <span class="op">=</span> <span class="op">[](</span><span class="bu">std::</span>string_view<span class="op"> </span>s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>    <span class="kw">auto</span> hash_value <span class="op">=</span> <span class="bu">std::</span>accumulate<span class="op">(</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>        s<span class="op">.</span>begin<span class="op">(),</span> s<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="bu">ull</span><span class="op">,</span> <span class="op">[](</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> accum<span class="op">,</span> <span class="dt">char</span> element<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>            <span class="cf">return</span> <span class="op">(</span>accum <span class="op">*</span> <span class="dv">31</span> <span class="op">+</span> element<span class="op">);</span></span>
<span id="cb48-9"><a href="#cb48-9"></a>        <span class="op">});</span></span>
<span id="cb48-10"><a href="#cb48-10"></a></span>
<span id="cb48-11"><a href="#cb48-11"></a>    <span class="cf">return</span> hash_value<span class="op">;</span></span>
<span id="cb48-12"><a href="#cb48-12"></a><span class="op">};</span></span>
<span id="cb48-13"><a href="#cb48-13"></a></span>
<span id="cb48-14"><a href="#cb48-14"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-15"><a href="#cb48-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> hashCode <span class="op">=</span> hornerHash<span class="op">(</span><span class="st">"hello world"</span><span class="op">);</span></span>
<span id="cb48-16"><a href="#cb48-16"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-17"><a href="#cb48-17"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/7hh15dbbo">Compiler Explorer</a></p>
<p>You can also capture <code>constexpr</code> variables in lambdas.</p>
<section id="overloaded-pattern" class="level2">
<h2 class="anchored" data-anchor-id="overloaded-pattern">Overloaded pattern</h2>
<p>It might be surprising to see, but you can derive from a lambda! Since the compiler expands a lambda expression into a function object with <code>operator()</code>, we can inherit from this type.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Callable<span class="op">&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="kw">class</span> ComplexFn <span class="op">:</span> <span class="kw">public</span> Callable<span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>    <span class="kw">explicit</span> ComplexFn<span class="op">(</span>Callable f<span class="op">)</span> <span class="op">:</span> Callable<span class="op">(</span>f<span class="op">){}</span></span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="op">};</span></span>
<span id="cb49-7"><a href="#cb49-7"></a></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Callable<span class="op">&gt;</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>ComplexFn<span class="op">&lt;</span>Callable<span class="op">&gt;</span> MakeComplexFunctionObject<span class="op">(</span>Callable<span class="op">&amp;&amp;</span> callable<span class="op">){</span></span>
<span id="cb49-10"><a href="#cb49-10"></a>    <span class="cf">return</span> ComplexFn<span class="op">&lt;</span>Callable<span class="op">&gt;(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Callable<span class="op">&gt;(</span>callable<span class="op">));</span></span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="op">}</span></span>
<span id="cb49-12"><a href="#cb49-12"></a></span>
<span id="cb49-13"><a href="#cb49-13"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="op">{</span></span>
<span id="cb49-15"><a href="#cb49-15"></a>    <span class="at">const</span> <span class="kw">auto</span> func <span class="op">=</span> MakeComplexFunctionObject<span class="op">(</span></span>
<span id="cb49-16"><a href="#cb49-16"></a>        <span class="op">[]{</span></span>
<span id="cb49-17"><a href="#cb49-17"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Hello, complex function object!"</span><span class="op">);</span></span>
<span id="cb49-18"><a href="#cb49-18"></a>        <span class="op">}</span></span>
<span id="cb49-19"><a href="#cb49-19"></a>    <span class="op">);</span></span>
<span id="cb49-20"><a href="#cb49-20"></a>    func<span class="op">();</span> </span>
<span id="cb49-21"><a href="#cb49-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the example, there’s the <code>ComplexFn</code> class which derives from <code>Callable</code> which is a template parameter. If we want to derive from a lambda, we need to do a little trick, as we cannot spell out the exact type of the closure type(unless we wrap it into a <code>std::function</code>). That’s why, we need the <code>MakeComplexFnObject</code> function that can perform template argument deduction and get the type of the lambda closure.</p>
<p>The <code>ComplexFn</code> apart from it’s name is just a simple wrapper without much of a use. Are there any use-cases for such code patterns?</p>
<p>We can extend the code above and inherit from two lambdas and create an overloaded set:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2"></a></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TCall<span class="op">,</span> <span class="kw">typename</span> UCall<span class="op">&gt;</span></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="kw">class</span> SimpleOverloaded <span class="op">:</span> <span class="kw">public</span> TCall<span class="op">,</span> UCall <span class="op">{</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>   <span class="kw">public</span><span class="op">:</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>    SimpleOverloaded<span class="op">(</span>TCall tf<span class="op">,</span> UCall uf<span class="op">)</span> <span class="op">:</span> TCall<span class="op">(</span>tf<span class="op">),</span> UCall<span class="op">(</span>uf<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb50-7"><a href="#cb50-7"></a></span>
<span id="cb50-8"><a href="#cb50-8"></a>    <span class="kw">using</span> TCall<span class="op">::</span><span class="kw">operator</span><span class="op">();</span></span>
<span id="cb50-9"><a href="#cb50-9"></a>    <span class="kw">using</span> UCall<span class="op">::</span><span class="kw">operator</span><span class="op">();</span></span>
<span id="cb50-10"><a href="#cb50-10"></a><span class="op">};</span></span>
<span id="cb50-11"><a href="#cb50-11"></a></span>
<span id="cb50-12"><a href="#cb50-12"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TCall<span class="op">,</span> <span class="kw">typename</span> UCall<span class="op">&gt;</span></span>
<span id="cb50-13"><a href="#cb50-13"></a>SimpleOverloaded<span class="op">&lt;</span>TCall<span class="op">,</span> UCall<span class="op">&gt;</span> MakeOverloaded<span class="op">(</span>TCall<span class="op">&amp;&amp;</span> tf<span class="op">,</span> UCall<span class="op">&amp;&amp;</span> uf<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-14"><a href="#cb50-14"></a>    <span class="cf">return</span> SimpleOverloaded<span class="op">&lt;</span>TCall<span class="op">,</span> UCall<span class="op">&gt;(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>TCall<span class="op">&gt;(</span>tf<span class="op">),</span></span>
<span id="cb50-15"><a href="#cb50-15"></a>                                          <span class="bu">std::</span>forward<span class="op">&lt;</span>UCall<span class="op">&gt;(</span>uf<span class="op">));</span></span>
<span id="cb50-16"><a href="#cb50-16"></a><span class="op">}</span></span>
<span id="cb50-17"><a href="#cb50-17"></a></span>
<span id="cb50-18"><a href="#cb50-18"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb50-19"><a href="#cb50-19"></a>    <span class="at">const</span> <span class="kw">auto</span> func <span class="op">=</span> MakeOverloaded<span class="op">([](</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Int!"</span><span class="op">);</span> <span class="op">},</span></span>
<span id="cb50-20"><a href="#cb50-20"></a>                                     <span class="op">[](</span><span class="dt">float</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Float!"</span><span class="op">);</span> <span class="op">});</span></span>
<span id="cb50-21"><a href="#cb50-21"></a></span>
<span id="cb50-22"><a href="#cb50-22"></a>    func<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb50-23"><a href="#cb50-23"></a>    func<span class="op">(</span><span class="fl">10.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb50-24"><a href="#cb50-24"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/81hM5cGbr">Compiler Explorer</a></p>
<p>This time we have more code and we derive from two template parameters, but we also need to expose their call operators explicitly. It’s because when looking for the correct function overload, the compiler requires the candidates to be in the same scope.</p>
<p>Now, how about using a variable number of base classes, which means a variable number of lambdas?</p>
</section>
<section id="deriving-from-multiple-lambdas" class="level2">
<h2 class="anchored" data-anchor-id="deriving-from-multiple-lambdas">Deriving from multiple lambdas</h2>
<p>In C++17, we have a handy pattern for this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2"></a></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="kw">struct</span> overloaded <span class="op">:</span> Ts<span class="op">...</span> <span class="op">{</span></span>
<span id="cb51-5"><a href="#cb51-5"></a>    <span class="kw">using</span> Ts<span class="op">::</span><span class="kw">operator</span><span class="op">()...;</span></span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="op">};</span></span>
<span id="cb51-7"><a href="#cb51-7"></a></span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb51-9"><a href="#cb51-9"></a>overloaded<span class="op">(</span>Ts<span class="op">...)</span> <span class="op">-&gt;</span> overloaded<span class="op">&lt;</span>Ts<span class="op">...&gt;;</span></span>
<span id="cb51-10"><a href="#cb51-10"></a></span>
<span id="cb51-11"><a href="#cb51-11"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-12"><a href="#cb51-12"></a>    <span class="at">const</span> <span class="kw">auto</span> test <span class="op">=</span> overloaded<span class="op">{</span></span>
<span id="cb51-13"><a href="#cb51-13"></a>        <span class="op">[](</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"int: </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span> <span class="op">},</span></span>
<span id="cb51-14"><a href="#cb51-14"></a>        <span class="op">[](</span><span class="at">const</span> <span class="dt">float</span><span class="op">&amp;</span> f<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"float: </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> f<span class="op">);</span> <span class="op">},</span></span>
<span id="cb51-15"><a href="#cb51-15"></a>        <span class="op">[](</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"string: </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span> <span class="op">},</span></span>
<span id="cb51-16"><a href="#cb51-16"></a>    <span class="op">};</span></span>
<span id="cb51-17"><a href="#cb51-17"></a></span>
<span id="cb51-18"><a href="#cb51-18"></a>    test<span class="op">(</span><span class="st">"10.0f"</span><span class="op">);</span></span>
<span id="cb51-19"><a href="#cb51-19"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/5sf3We9zY">Compiler Explorer</a></p>
<p>Let’s deep-dive into the basic mechanics of this pattern. It benefits from three features:</p>
<ul>
<li>Pack expansions in <code>using</code> declarations.</li>
<li>Custom template argument deduction rules - that allows converting a list of lambda objects into a list of base classes for the <code>overloaded</code> class. (not needed in C++20!)</li>
<li>Extension to aggregate initialisation - before C++17, you couldn’t aggregate initialise type that derives from other types.</li>
</ul>
<p>The <code>using</code> declaration is important for bringing the function call operator - <code>operator()</code> into the same scope of the <code>overloaded</code> structure. In C++17, we got a syntax that supports variadic templates, which was not possible in the previous revisions of the language.</p>
<p>Let’s try and understand the remaining features:</p>
<section id="custom-template-argument-deduction-rules" class="level3">
<h3 class="anchored" data-anchor-id="custom-template-argument-deduction-rules">Custom Template Argument Deduction Rules</h3>
<p>We derive from lambdas, and then we expose their <code>operator()</code> as we saw in the previous section. But, how can we create objects of this <code>overload</code> type?</p>
<p>As you know, there’s no way to know up-front, the type of the lambda, as compiler has to generate some unique typename for each of them. For example, we cannot just write:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a>overload<span class="op">&lt;</span>LambdaType1<span class="op">,</span> LambdaType2<span class="op">&gt;</span> myOverload<span class="op">{...}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The only way that could work would be some <code>make</code> function (as template argument deduction works for function templates):</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_overloader<span class="op">(</span>T<span class="op">&amp;&amp;...</span> t<span class="op">){</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>    <span class="cf">return</span> overloaded<span class="op">&lt;</span>T<span class="op">...&gt;{</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)...};</span></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With the template argument deduction rules that were added in C++17, we can simplify the creation of common template types and the <code>make_overloader</code> function is not needed. For simple types, we can write:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="bu">std::</span>pair<span class="op"> </span>strDouble<span class="op">{</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">"Hello"</span><span class="op">},</span> <span class="fl">10.0</span> <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There’s also the option to define custom deduction guides. The standard library uses a lot of them, for exmaple, for <code>std::array</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> U<span class="op">&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="bu">std::</span>array<span class="op">(</span>T<span class="op">,</span>U<span class="op">...)</span> <span class="op">-&gt;</span> array<span class="op">&lt;</span>T<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> <span class="kw">sizeof</span><span class="op">...(</span>U<span class="op">)&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and the above rules allows us to write:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a><span class="bu">std::</span>array<span class="op"> </span>test<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the <code>overloaded</code> pattern, we can specify a custom deduction guide:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> overloaded<span class="op">(</span>Ts<span class="op">...)</span> <span class="op">-&gt;</span> overloaded<span class="op">&lt;</span>Ts<span class="op">...&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>