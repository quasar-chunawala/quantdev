<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-12-18">

<title>quantdev.blog - C++ Type erasure</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././symbol.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../newsletter.html" rel="" target="">
 <span class="menu-text">Newsletter</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">C++ Type erasure</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 18, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#how-does-type-erasure-look-like" id="toc-how-does-type-erasure-look-like" class="nav-link" data-scroll-target="#how-does-type-erasure-look-like">How does type erasure look like?</a></li>
  <li><a href="#type-erasure---the-basic-mechanics" id="toc-type-erasure---the-basic-mechanics" class="nav-link" data-scroll-target="#type-erasure---the-basic-mechanics">Type erasure - the basic mechanics</a>
  <ul class="collapse">
  <li><a href="#step-1---how-to-write-a-container-that-holds-unrelated-types" id="toc-step-1---how-to-write-a-container-that-holds-unrelated-types" class="nav-link" data-scroll-target="#step-1---how-to-write-a-container-that-holds-unrelated-types">Step 1 - How to write a container that holds unrelated types?</a></li>
  <li><a href="#step-2---can-m_func-be-a-polymorphic-pointer-to-a-place-on-the-heap-that-will-hold-these-unrelated-types" id="toc-step-2---can-m_func-be-a-polymorphic-pointer-to-a-place-on-the-heap-that-will-hold-these-unrelated-types" class="nav-link" data-scroll-target="#step-2---can-m_func-be-a-polymorphic-pointer-to-a-place-on-the-heap-that-will-hold-these-unrelated-types">Step 2 - Can <code>m_func</code> be a polymorphic pointer to a place on the heap that will hold these unrelated types?</a></li>
  <li><a href="#polishing-our-design-for-stdfunction-like-container" id="toc-polishing-our-design-for-stdfunction-like-container" class="nav-link" data-scroll-target="#polishing-our-design-for-stdfunction-like-container">Polishing our design for <code>std::function</code> like container</a></li>
  </ul></li>
  <li><a href="#type-safety-in-type-erasure" id="toc-type-safety-in-type-erasure" class="nav-link" data-scroll-target="#type-safety-in-type-erasure">Type safety in type erasure</a></li>
  <li><a href="#type-erasure---adding-support-for-a-custom-deleter-to-the-shared_ptr" id="toc-type-erasure---adding-support-for-a-custom-deleter-to-the-shared_ptr" class="nav-link" data-scroll-target="#type-erasure---adding-support-for-a-custom-deleter-to-the-shared_ptr">Type erasure - Adding support for a custom deleter to the <code>shared_ptr</code></a>
  <ul class="collapse">
  <li><a href="#step-1---code-up-a-container-that-can-hold-unrelated-different-types" id="toc-step-1---code-up-a-container-that-can-hold-unrelated-different-types" class="nav-link" data-scroll-target="#step-1---code-up-a-container-that-can-hold-unrelated-different-types">Step 1 - Code up a container that can hold unrelated different types</a></li>
  <li><a href="#step-2---coding-up-a-type-agnostic-interface-and-a-type-dependent-implementation" id="toc-step-2---coding-up-a-type-agnostic-interface-and-a-type-dependent-implementation" class="nav-link" data-scroll-target="#step-2---coding-up-a-type-agnostic-interface-and-a-type-dependent-implementation">Step 2 - Coding up a type-agnostic interface and a type-dependent implementation</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Once you instantiate a <code>std::function</code> object, how is it, that <em>you are able to stick objects of different actual types e.g.&nbsp;an anonymous lambda, a free-standing function or a function-pointer (with only a common function signature)</em> to it? This is achieved through <strong>type erasure</strong>.</p>
<p>Type erasure is a programming technique by which the explicit type information is removed from the program. It is a type of <em>abstraction</em> that ensures that the program does not explicitly depend on some of the data-types. You might wonder, how is it, that a program is written in a strongly typed language but does not use the actual types?</p>
</section>
<section id="how-does-type-erasure-look-like" class="level1">
<h1>How does type erasure look like?</h1>
<p>The ultimate type-erased object in C++ is <code>std::function</code>. Another one is <code>std::any</code>. Consider the following code snip:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="dt">void</span> print_num<span class="op">(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">auto</span> display_lambda <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="op">};</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">struct</span> PrintFunctor<span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="op">};</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> f_print_num <span class="op">=</span> print_num<span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> f_display_lambda <span class="op">=</span> display_lambda<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> f_print_functor <span class="op">=</span> PrintFunctor<span class="op">{};</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/1Tz7dWqM7">Compiler Explorer</a></p>
<p>The free-standing function <code>print_num</code>, the lambda function <code>diplay_lambda</code> and the functor <code>PrintFunctor</code> are objects with different types. So, the type of object being assigned to the <code>std::function</code> changed, but on the left hand side we have the same type. <code>std::function&lt;void(int)&gt;</code> can store any of these callable objects. Somehow, we can stick all these different types into it.</p>
<p>If you look at it from the design point of view, what it does is, it abstracts away all the behavior of the type you erase, except the set of behaviors you consider relevant. It’s a very flexible abstraction. In my case, I say, what’s relevant is, I can invoke this type with a <code>int</code> and I get back a <code>void</code>.</p>
</section>
<section id="type-erasure---the-basic-mechanics" class="level1">
<h1>Type erasure - the basic mechanics</h1>
<section id="step-1---how-to-write-a-container-that-holds-unrelated-types" class="level2">
<h2 class="anchored" data-anchor-id="step-1---how-to-write-a-container-that-holds-unrelated-types">Step 1 - How to write a container that holds unrelated types?</h2>
<p>On cppreference.com, <code>std::function</code> is defined as follows:</p>
<div class="callout callout-style-simple callout-none no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span> <span class="kw">class</span> R<span class="op">,</span> <span class="kw">class</span><span class="op">...</span> Args <span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">class</span> function<span class="op">&lt;</span>R<span class="op">(</span>Args<span class="op">...)&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><em>The class template <code>std::function</code> is a general-purpose polymorphic function wrapper.</em></p>
</div>
</div>
</div>
<p><code>std::function</code> has to be polymorphic, meaning it has to be able to hold completely unrelated types. They don’t have to be bound by an inheritance-hierarchy or any other sort of thing.</p>
<p>Our end-goal looks something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">struct</span> MagicFunctionContainer</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">{};</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>MagicFunctionContainer f1 <span class="op">=</span> print_num<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>MagicFunctionContainer f2 <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> i<span class="op">){</span> <span class="bu">std::</span>println<span class="op">({},</span> i<span class="op">);</span> <span class="op">};</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>MagicFunctionContainer f3 <span class="op">=</span> PrintFunctor<span class="op">{};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We should be able to assign different objects of types like a free-standing function, a lambda expression or a functor to this <code>MagicFunctionContainer</code>.</p>
<p>Let’s start with designing a container, which is constructible from completely unrelated types:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">struct</span> MagicFunctionContainer<span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Func<span class="op">&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    MagicFunctionContainer<span class="op">(</span>Func<span class="op">&amp;&amp;</span> func<span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="op">:</span> <span class="va">m_func</span><span class="op">{</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Func<span class="op">&gt;(</span>func<span class="op">)}</span> </span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="op">{}</span></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>        <span class="va">m_func</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="co">//void(*)(int) m_func;   // we need to think</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>                             <span class="co">// of m_func's type</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We see that, there’s this container called <code>MagicFunctionContainer</code>. The most important thing to note is that, its constructor is now a templated constructor, so you can pass any type into the <code>MaginFunctionContainer</code> constructor, and it simply forwards the object <code>func</code> into <code>m_func</code>. We need to think, what the type of <code>m_func</code> is. We see that this function container also implements a function call operator <code>operator()</code>, which accepts an integer and returns type <code>void</code>. So, when this function container object is invoked with an integer <code>i</code>, it simply calls <code>m_func(i)</code> under the hood.</p>
<p>As long as we have defined the type of <code>m_func</code>, and its the correct type, this code satisfies our requirements. We now have a container, that can be constructed from completely unrelated types. How do we store these unrelated types? How do we now define what the type of <code>m_func</code> should be? The answer to this puzzle is step-2 of our design.</p>
</section>
<section id="step-2---can-m_func-be-a-polymorphic-pointer-to-a-place-on-the-heap-that-will-hold-these-unrelated-types" class="level2">
<h2 class="anchored" data-anchor-id="step-2---can-m_func-be-a-polymorphic-pointer-to-a-place-on-the-heap-that-will-hold-these-unrelated-types">Step 2 - Can <code>m_func</code> be a polymorphic pointer to a place on the heap that will hold these unrelated types?</h2>
<p>The classic type erasure pattern can be realized by first coding up a <em>type-agnostic interface</em> (a <code>Concept</code> class). Then we use an <code>Impl</code> class that wraps up the concrete type &amp; provides the <em>type-dependent implementation</em>. Finally, we use dynamic polymorphism via virtual functions, but the caller only sees the interface.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// Type erasure 101</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">namespace</span> dev<span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="kw">struct</span> Concept<span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="kw">virtual</span> <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="op">~</span><span class="kw">virtual</span> Concept<span class="op">(){}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="op">};</span></span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Callable<span class="op">&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="kw">struct</span> Impl<span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a>        Impl<span class="op">(</span><span class="at">const</span> Callable<span class="op">&amp;</span> callable<span class="op">)</span> </span>
<span id="cb5-15"><a href="#cb5-15"></a>        <span class="op">:</span> <span class="va">m_callable</span><span class="op">{</span>callable<span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>        <span class="op">{}</span></span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a>        <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>            <span class="va">m_callable</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>        <span class="op">}</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>        </span>
<span id="cb5-22"><a href="#cb5-22"></a>        Callable <span class="va">m_callable</span><span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>    <span class="op">};</span></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each time I get any new type <code>Callable</code>, I am creating an implementation <code>Impl&lt;Callable&gt;</code>, and passing that object into this new type.</p>
<p>Any type <code>Callable</code> that implements <code>operator()(int)</code> can be stored in <code>Impl&lt;Callable&gt;</code>. And <code>Impl&lt;Callable&gt;</code> inherits from <code>Concept</code>.</p>
<p>Now, what we’ve achieved so far is, that any <code>Impl&lt;Callable&gt;</code> object, as long as <code>Callable</code> implements the function call operator <code>operator()</code>, accepts an <code>int</code>, returns <code>void</code> can be assigned to a pointer to <code>Concept</code>, <code>Concept*</code>. Remember, all types <code>Impl&lt;Callable_1&gt;</code>, <code>Impl&lt;Callable_2&gt;</code>, …, <code>Impl&lt;Callable_n&gt;</code> inherit from <code>Concept</code>.</p>
<p>We can now finish the revisit the definition of <code>MagicFunctionContainer</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">struct</span> MagicFunctionContainer<span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Func<span class="op">&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    MagicFunctionContainer<span class="op">(</span>Func<span class="op">&amp;&amp;</span> func<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="op">:</span> <span class="va">m_func</span><span class="op">{</span><span class="kw">new</span> Impl<span class="op">&lt;</span>Func<span class="op">&gt;(</span>func<span class="op">)}</span> </span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="op">{}</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="cf">if</span><span class="op">(</span><span class="va">m_func</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>            <span class="cf">throw</span> <span class="bu">std::</span>bad_function_call<span class="op">();</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a>        <span class="op">(*</span><span class="va">m_func</span><span class="op">)(</span>i<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    Concept<span class="op">*</span> <span class="va">m_func</span><span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span>   </span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the <code>MagicFunctionContainer</code>, I have still got the templated constructor. I have still got the function call operator. But, now I have type for <code>m_func</code>. <code>m_func</code> is a pointer to <code>Concept</code>. In the templated constructor, now what I’m doing is, each time I get any type <code>Func</code>, I am passing that object into this new type <code>Impl&lt;Func&gt;</code>. So, essentially a <code>Concept*</code> pointer is always pointing to an <code>Impl&lt;Func&gt;</code>.</p>
<p>As a result what happens is, although the <code>MagicFunctionContainer</code> is not templated itself, its constructor is templated and it’s <code>m_func</code> member variable is able to store different unrelated types.</p>
</section>
<section id="polishing-our-design-for-stdfunction-like-container" class="level2">
<h2 class="anchored" data-anchor-id="polishing-our-design-for-stdfunction-like-container">Polishing our design for <code>std::function</code> like container</h2>
<p>We can add some template magic and use concepts to constrain our template type parameter <code>Func</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;concepts&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">namespace</span> dev<span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="kw">struct</span> Concept<span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span class="kw">virtual</span> R <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">...</span> args<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span class="kw">virtual</span> <span class="op">~</span>Concept<span class="op">(){}</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="op">};</span></span>
<span id="cb7-12"><a href="#cb7-12"></a></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Func<span class="op">,</span> <span class="kw">typename</span> R<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="kw">struct</span> Impl <span class="op">:</span> Concept<span class="op">&lt;</span>R<span class="op">,</span> Args<span class="op">...&gt;{</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        Impl<span class="op">(</span>Func func<span class="op">)</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="op">:</span> <span class="va">m_func</span><span class="op">{</span> func <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>        <span class="op">{}</span></span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>        R <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">...</span> args<span class="op">)</span> <span class="kw">override</span><span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>            <span class="cf">return</span> <span class="va">m_func</span><span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>        <span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a>        Func <span class="va">m_func</span><span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    <span class="op">};</span></span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>    <span class="kw">class</span> function<span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>        <span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-29"><a href="#cb7-29"></a>        <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Func<span class="op">&gt;</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>        <span class="kw">requires</span> <span class="bu">std::</span>invocable<span class="op">&lt;</span>Func<span class="op">,</span> Args<span class="op">...&gt;</span></span>
<span id="cb7-31"><a href="#cb7-31"></a>        function<span class="op">(</span>Func func<span class="op">)</span> </span>
<span id="cb7-32"><a href="#cb7-32"></a>        <span class="op">:</span> <span class="va">m_func</span><span class="op">{</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Impl<span class="op">&lt;</span>Func<span class="op">,</span>R<span class="op">,</span>Args<span class="op">...&gt;&gt;(</span>func<span class="op">)}</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>        <span class="op">{}</span></span>
<span id="cb7-34"><a href="#cb7-34"></a></span>
<span id="cb7-35"><a href="#cb7-35"></a>        R <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>            <span class="cf">return</span> <span class="op">(*</span><span class="va">m_func</span><span class="op">)(</span>args<span class="op">...);</span></span>
<span id="cb7-37"><a href="#cb7-37"></a>        <span class="op">}</span></span>
<span id="cb7-38"><a href="#cb7-38"></a></span>
<span id="cb7-39"><a href="#cb7-39"></a>        <span class="kw">private</span><span class="op">:</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>        <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Concept<span class="op">&lt;</span>R<span class="op">,</span> Args<span class="op">...&gt;&gt;</span> <span class="va">m_func</span><span class="op">;</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>    <span class="op">};</span></span>
<span id="cb7-42"><a href="#cb7-42"></a><span class="op">}</span></span>
<span id="cb7-43"><a href="#cb7-43"></a></span>
<span id="cb7-44"><a href="#cb7-44"></a></span>
<span id="cb7-45"><a href="#cb7-45"></a><span class="dt">void</span> print_num<span class="op">(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb7-46"><a href="#cb7-46"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb7-47"><a href="#cb7-47"></a><span class="op">}</span></span>
<span id="cb7-48"><a href="#cb7-48"></a></span>
<span id="cb7-49"><a href="#cb7-49"></a><span class="kw">auto</span> display_lambda <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb7-50"><a href="#cb7-50"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb7-51"><a href="#cb7-51"></a><span class="op">};</span></span>
<span id="cb7-52"><a href="#cb7-52"></a></span>
<span id="cb7-53"><a href="#cb7-53"></a><span class="kw">struct</span> PrintFunctor<span class="op">{</span></span>
<span id="cb7-54"><a href="#cb7-54"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">){</span></span>
<span id="cb7-55"><a href="#cb7-55"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb7-56"><a href="#cb7-56"></a>    <span class="op">}</span></span>
<span id="cb7-57"><a href="#cb7-57"></a><span class="op">};</span></span>
<span id="cb7-58"><a href="#cb7-58"></a></span>
<span id="cb7-59"><a href="#cb7-59"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-60"><a href="#cb7-60"></a><span class="op">{</span></span>
<span id="cb7-61"><a href="#cb7-61"></a>    dev<span class="op">::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> f_print_num <span class="op">=</span> print_num<span class="op">;</span></span>
<span id="cb7-62"><a href="#cb7-62"></a>    dev<span class="op">::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> f_display_lambda <span class="op">=</span> display_lambda<span class="op">;</span></span>
<span id="cb7-63"><a href="#cb7-63"></a>    dev<span class="op">::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> f_print_functor <span class="op">=</span> PrintFunctor<span class="op">{};</span></span>
<span id="cb7-64"><a href="#cb7-64"></a></span>
<span id="cb7-65"><a href="#cb7-65"></a>    f_print_num<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb7-66"><a href="#cb7-66"></a>    f_display_lambda<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb7-67"><a href="#cb7-67"></a>    f_print_functor<span class="op">(</span><span class="dv">17</span><span class="op">);</span></span>
<span id="cb7-68"><a href="#cb7-68"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-69"><a href="#cb7-69"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/e8rKhPzYK">Compiler Explorer</a></p>
</section>
</section>
<section id="type-safety-in-type-erasure" class="level1">
<h1>Type safety in type erasure</h1>
<p>The type erased container should have the ability to hold unrelated types. In addition to this, there is one other requirement. <em>The type erased container should retain the type information of the assigned object</em>.</p>
<p>Consider the following example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">struct</span> Foo<span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    Foo<span class="op">(){</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Constructed Foo()"</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="op">~</span>Foo<span class="op">(){</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Destructed ~Foo()"</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="op">};</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="dt">void</span><span class="op">*</span> foo_ptr <span class="op">=</span> <span class="kw">new</span> Foo<span class="op">();</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">delete</span> foo_ptr<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I have a type agnostic <code>foo_ptr</code> and I am assigning it an object of type <code>Foo</code>. When a <code>Foo</code> object is constructed, it prints the text <code>Constructed Foo()</code> to the console, when it is destructed, it prints <code>Destructed ~Foo()</code> to the console. Do you think this code compiles?</p>
<p><code>gcc</code> issues the following warning:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb9-1"><a href="#cb9-1"></a>&lt;source&gt;: In function 'int main()':</span>
<span id="cb9-2"><a href="#cb9-2"></a>&lt;source&gt;:11:12: warning: deleting 'void*' is undefined [-Wdelete-incomplete]</span>
<span id="cb9-3"><a href="#cb9-3"></a>   11 |     delete foo_ptr;</span>
<span id="cb9-4"><a href="#cb9-4"></a>      |            ^~~~~~~</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s try something else:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> uptr<span class="op">{</span> <span class="kw">new</span> Foo<span class="op">()</span> <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Do you think this code builds?</p>
<p>It’s the same thing. As per the standard, deleteing a <code>void*</code> pointer is undefined behavior. In this particular case, <code>unique_ptr</code> has a static assertion built in to ensure that we don’t use a type-agnostic pointer.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb11-1"><a href="#cb11-1"></a>&lt;source&gt;:11:43:   </span>
<span id="cb11-2"><a href="#cb11-2"></a>   11 |     std::unique_ptr&lt;void&gt; uptr{ new Foo() };</span>
<span id="cb11-3"><a href="#cb11-3"></a>      |                                           ^</span>
<span id="cb11-4"><a href="#cb11-4"></a>/cefs/e6/e6c9babfba5a70d326be2358_gcc-trunk-20251219/include/c++/16.0.0/bits/unique_ptr.h:88:38: error: static assertion failed: can't delete pointer to incomplete type</span>
<span id="cb11-5"><a href="#cb11-5"></a>   88 |         static_assert(!is_void&lt;_Tp&gt;::value,</span>
<span id="cb11-6"><a href="#cb11-6"></a>      |                                      ^~~~~</span>
<span id="cb11-7"><a href="#cb11-7"></a>  '!(bool)std::integral_constant&lt;bool, true&gt;::value' evaluates to false</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ve seen that raw-pointers and <code>unique_ptr</code> don’t work. How about a <code>shared_ptr</code>? Do you think this builds?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> sptr<span class="op">{</span> <span class="kw">new</span> Foo<span class="op">()</span> <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this case, we see the following output:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb13-1"><a href="#cb13-1"></a>Constructed Foo()</span>
<span id="cb13-2"><a href="#cb13-2"></a>Destructed ~Foo()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is suprising! Is the <code>shared_ptr</code> not storing a raw pointer of <code>void*</code>, whilst the <code>unique_ptr</code> is? How does <code>shared_ptr</code> even able to delete the object correctly? Usually, once you assign a typed address <code>T*</code> to a pointer-to-void <code>void*</code>, you have lost the type information. How is <code>shared_ptr</code> still able to store the original type <code>Foo</code> in order to be able to destruct it correctly?</p>
<p>This is what we mean by type-safety in type erasure. From cppreference.com, if you look at the declarations for the <code>unique_ptr</code> and <code>shared_ptr</code>, they look something like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span><span class="op">&lt;</span> <span class="kw">class</span> T <span class="op">&gt;</span> <span class="kw">class</span> shared_ptr<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">template</span><span class="op">&lt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">class</span> T<span class="op">,</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="kw">class</span> Deleter <span class="op">=</span> <span class="bu">std::</span>default_delete<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="kw">class</span> unique_ptr<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>shared_ptr</code> only has a template type parameter <code>T</code>. But, magically it also stores the object type information and called the correct destructor. <code>unique_ptr&lt;T&gt;</code> only stores the template type information.</p>
<p>The signature of the <code>shared_ptr</code> templated class kind of gives this away. It doesn’t have a deleter as a template type parameter. The deleter type is erased. In <code>shared_ptr</code> the deleter is based on the object type being passed during construction(and not the template type).</p>
</section>
<section id="type-erasure---adding-support-for-a-custom-deleter-to-the-shared_ptr" class="level1">
<h1>Type erasure - Adding support for a custom deleter to the <code>shared_ptr</code></h1>
<p>Let’s use our learnings above to add support for a custom deleter to the <code>shared_ptr</code>. The <code>shared_ptr</code> needs to be aware of the actual type being passed during construction in order to delete the object correctly. Let’s see how we can achieve that.</p>
<p>A <code>shared_ptr&lt;T1&gt;</code> can store objects of any type <code>T2</code> as long as <code>T2*</code> is convertible to <code>T1*</code>. It type erases <code>T2</code>. Upon destruction, the <code>shared_ptr</code> will call the correct destructor of type <code>T2</code>, that is the destructor of the actual object stored, instead of type <code>T1</code>.</p>
<p>Here is a quick overview of the <code>shared_ptr</code>. Typical implementations of <code>shared_ptr</code> look like as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb15-1"><a href="#cb15-1"></a>+-------------------+</span>
<span id="cb15-2"><a href="#cb15-2"></a>|    shared_ptr&lt;T&gt;  |</span>
<span id="cb15-3"><a href="#cb15-3"></a>+-------------------+</span>
<span id="cb15-4"><a href="#cb15-4"></a>|                   |</span>
<span id="cb15-5"><a href="#cb15-5"></a>|  +--------------+ |        +------------+</span>
<span id="cb15-6"><a href="#cb15-6"></a>|  |   T* ptr     |-|-------&gt;|  T object  | </span>
<span id="cb15-7"><a href="#cb15-7"></a>|  +--------------+ |        |   (heap)   | </span>
<span id="cb15-8"><a href="#cb15-8"></a>|                   |        +------------+ </span>
<span id="cb15-9"><a href="#cb15-9"></a>|  +--------------+ |                       </span>
<span id="cb15-10"><a href="#cb15-10"></a>|  | ControlBlock*| |        +------------------------------------------+               </span>
<span id="cb15-11"><a href="#cb15-11"></a>|  |    cb_ptr    |-|-------&gt;|         Control Block (heap)             |</span>
<span id="cb15-12"><a href="#cb15-12"></a>|  +--------------+ |        +------------------------------------------+</span>
<span id="cb15-13"><a href="#cb15-13"></a>|                   |        |                                          |</span>
<span id="cb15-14"><a href="#cb15-14"></a>+------------------+|        |  +------------------------------------+  |</span>
<span id="cb15-15"><a href="#cb15-15"></a>                             |  |  size_t reference_count            |  |</span>
<span id="cb15-16"><a href="#cb15-16"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-17"><a href="#cb15-17"></a>                             |                                          |</span>
<span id="cb15-18"><a href="#cb15-18"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-19"><a href="#cb15-19"></a>                             |  |  size_t weak_count                 |  |</span>
<span id="cb15-20"><a href="#cb15-20"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-21"><a href="#cb15-21"></a>                             |                                          |</span>
<span id="cb15-22"><a href="#cb15-22"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-23"><a href="#cb15-23"></a>                             |  |  Deleter (custom or                |  |</span>
<span id="cb15-24"><a href="#cb15-24"></a>                             |  |  default delete)                   |  |</span>
<span id="cb15-25"><a href="#cb15-25"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-26"><a href="#cb15-26"></a>                             |                                          |</span>
<span id="cb15-27"><a href="#cb15-27"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-28"><a href="#cb15-28"></a>                             |  |  Allocator (optional)              |  |</span>
<span id="cb15-29"><a href="#cb15-29"></a>                             |  +------------------------------------+  |</span>
<span id="cb15-30"><a href="#cb15-30"></a>                             |                                          |</span>
<span id="cb15-31"><a href="#cb15-31"></a>                             +------------------------------------------+</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You have a <code>shared_ptr</code> of type <code>T</code>. It stores a raw underlying pointer-to-<code>T</code> and a pointer to a control block. The <code>control_block</code> is a different from the managed object. It stores the reference count, the weak count and some additional data. The custom deleter is going to delete the object type passed during <code>shared_ptr</code> construction and not the type <code>T</code>.</p>
<section id="step-1---code-up-a-container-that-can-hold-unrelated-different-types" class="level2">
<h2 class="anchored" data-anchor-id="step-1---code-up-a-container-that-can-hold-unrelated-different-types">Step 1 - Code up a container that can hold unrelated different types</h2>
<p>We start with thinking about our <code>shared_ptr</code> class. So, we write a templated constructor <code>shared_ptr(Y* ptr)</code>. You should be used to this by now - I can pass in any object to this. I later constrain this using the <code>std::is_convertible_v&lt;Y*, T*&gt;</code> type trait, to enforce that <code>Y*</code> is indeed convertible to <code>T*</code>.</p>
<p>We have another constructor that takes two parameters : a pointer to <code>Y</code> and a custom deleter.</p>
<p>Now, the pointer to <code>Y</code>, <code>Y*</code> is convertible to pointer to <code>T</code>, <code>T*</code>. So, the pointer(address) itself is simply stored in the class as a <code>T*</code> member variable. So, I have a member variable <code>T* m_underlying_ptr</code> at the bottom. The question is how do we store the original object type <code>Y*</code> and the deleter type <code>Deleter</code>. As soon as I assign <code>Y* ptr</code> to <code>T* m_underlying_ptr</code>, I have lost information about the original object type <code>Y*</code>. How do we store the deleter and the true object type <code>Y</code>?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">class</span> shared_ptr<span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">&gt;</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="kw">requires</span> <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>Y<span class="op">*,</span> T<span class="op">*&gt;</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">)</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="op">:</span> shared_ptr<span class="op">(</span>ptr<span class="op">,</span> <span class="bu">std::</span>default_delete<span class="op">&lt;</span>Y<span class="op">&gt;{})</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="op">{}</span></span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="co">// Templated constructor</span></span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">,</span> <span class="kw">typename</span> Deleter<span class="op">&gt;</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">,</span> Deleter deleter<span class="op">)</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>    <span class="op">:</span> <span class="va">m_underlying_ptr</span><span class="op">{</span>ptr<span class="op">}</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>    <span class="co">// ???  </span></span>
<span id="cb16-18"><a href="#cb16-18"></a>    <span class="op">{}</span></span>
<span id="cb16-19"><a href="#cb16-19"></a></span>
<span id="cb16-20"><a href="#cb16-20"></a>    <span class="co">// Destructor</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>    <span class="op">~</span>shared_ptr<span class="op">(){</span></span>
<span id="cb16-22"><a href="#cb16-22"></a>        <span class="co">// Decrement the ref-count. If m_ref_count == 0, </span></span>
<span id="cb16-23"><a href="#cb16-23"></a>        <span class="co">// delete m_underlying_ptr using deleter </span></span>
<span id="cb16-24"><a href="#cb16-24"></a>    <span class="op">}</span></span>
<span id="cb16-25"><a href="#cb16-25"></a></span>
<span id="cb16-26"><a href="#cb16-26"></a>    <span class="co">// Pointer like functions</span></span>
<span id="cb16-27"><a href="#cb16-27"></a>    <span class="at">const</span> T<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb16-28"><a href="#cb16-28"></a>        <span class="cf">return</span> <span class="va">m_underlying_ptr</span><span class="op">;</span></span>
<span id="cb16-29"><a href="#cb16-29"></a>    <span class="op">}</span></span>
<span id="cb16-30"><a href="#cb16-30"></a></span>
<span id="cb16-31"><a href="#cb16-31"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb16-32"><a href="#cb16-32"></a>    T<span class="op">*</span> <span class="va">m_underlying_ptr</span><span class="op">;</span></span>
<span id="cb16-33"><a href="#cb16-33"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="step-2---coding-up-a-type-agnostic-interface-and-a-type-dependent-implementation" class="level2">
<h2 class="anchored" data-anchor-id="step-2---coding-up-a-type-agnostic-interface-and-a-type-dependent-implementation">Step 2 - Coding up a type-agnostic interface and a type-dependent implementation</h2>
<p>Let’s now write a <code>Concept</code> and <code>Impl</code> class that supports destruction using an instance of the custom <code>Impl&lt;ObjType, Deleter&gt;</code> type. We can actually define a <code>ControlBlockBase</code> and <code>ControlBlockImpl&lt;ObjType, Deleter&gt;</code> classes.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">namespace</span> dev <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="co">// Type-agnostic Concept class</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="kw">struct</span> ControlBlockBase<span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>        <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="bu">std::</span>size_t<span class="op">&gt;</span> <span class="va">m_ref_count</span><span class="op">{</span><span class="dv">1</span><span class="bu">uz</span><span class="op">};</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>        <span class="kw">virtual</span> <span class="op">~</span>ControlBlockBase<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="op">};</span></span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="co">// Type dependent Impl&lt;ObjType,Deleter&gt; implementation</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> ObjType<span class="op">,</span> <span class="kw">typename</span> Deleter<span class="op">&gt;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="kw">struct</span> ControlBlock <span class="op">:</span> ControlBlockBase<span class="op">{</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        ControlBlock<span class="op">(</span> ObjType<span class="op">*</span> object_ptr<span class="op">,</span> Deleter deleter<span class="op">)</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="op">:</span> <span class="va">m_object_ptr</span><span class="op">{</span> object_ptr <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="op">,</span> <span class="va">m_deleter</span><span class="op">{</span> deleter <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>        <span class="op">{}</span></span>
<span id="cb17-15"><a href="#cb17-15"></a></span>
<span id="cb17-16"><a href="#cb17-16"></a>        <span class="op">~</span>ControlBlock<span class="op">()</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>        <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>            <span class="va">m_deleter</span><span class="op">(</span><span class="va">m_object_ptr</span><span class="op">);</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>        <span class="op">}</span></span>
<span id="cb17-20"><a href="#cb17-20"></a></span>
<span id="cb17-21"><a href="#cb17-21"></a>        <span class="kw">private</span><span class="op">:</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>        ObjType<span class="op">*</span> <span class="va">m_object_ptr</span><span class="op">;</span></span>
<span id="cb17-23"><a href="#cb17-23"></a>        Deleter <span class="va">m_deleter</span><span class="op">;</span></span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="op">};</span></span>
<span id="cb17-25"><a href="#cb17-25"></a><span class="op">}</span>  <span class="co">// namespace dev</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>ControlBlock</code> inherits from <code>ControlBlockBase</code> and it is templated. <code>Concept</code> itself is not templated, but the implementation <code>control_block</code> class is. In this case, it is templated on the <code>ObjectType</code> and the <code>Deleter</code> type. The constructor <code>control_block(ObjectType*, Deleter)</code> takes two parameters - the object type and the deleter. <code>ObjectType</code> is not the type parameter of the <code>shared_ptr</code>, which is <code>T</code>, but the type of the object passed to the <code>shared_ptr()</code> during construction.</p>
<p>On destruction of the control block, it calls the deleter on a pointer to <code>ObjType</code> - the correct type. It’s not going to call the deleter on the template type. We can now, finish up with our definition of the <code>shared_ptr</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">class</span> shared_ptr<span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>    <span class="kw">requires</span> <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>Y<span class="op">*,</span> T<span class="op">*&gt;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">)</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="op">:</span> shared_ptr<span class="op">(</span>ptr<span class="op">,</span> <span class="bu">std::</span>default_delete<span class="op">&lt;</span>Y<span class="op">&gt;{})</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="op">{}</span></span>
<span id="cb18-12"><a href="#cb18-12"></a></span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="co">// Templated constructor</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">,</span> <span class="kw">typename</span> Deleter<span class="op">&gt;</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">,</span> Deleter deleter<span class="op">)</span></span>
<span id="cb18-16"><a href="#cb18-16"></a>    <span class="op">:</span> <span class="va">m_underlying_ptr</span><span class="op">{</span>ptr<span class="op">}</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>    <span class="op">,</span> <span class="va">m_control_block_ptr</span><span class="op">{</span> <span class="kw">new</span> ControlBlock<span class="op">&lt;</span>Y<span class="op">,</span>Deleter<span class="op">&gt;(</span>deleter<span class="op">)</span> <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="op">{}</span></span>
<span id="cb18-19"><a href="#cb18-19"></a></span>
<span id="cb18-20"><a href="#cb18-20"></a>    <span class="co">// Destructor</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>    <span class="op">~</span>shared_ptr<span class="op">(){</span></span>
<span id="cb18-22"><a href="#cb18-22"></a>        <span class="co">// Decrement the ref-count. If m_ref_count == 0, </span></span>
<span id="cb18-23"><a href="#cb18-23"></a>        <span class="co">// delete the control_block_ptr which will destroy the managed object </span></span>
<span id="cb18-24"><a href="#cb18-24"></a>        <span class="kw">delete</span> <span class="va">m_control_block_ptr</span><span class="op">;</span></span>
<span id="cb18-25"><a href="#cb18-25"></a>    <span class="op">}</span></span>
<span id="cb18-26"><a href="#cb18-26"></a></span>
<span id="cb18-27"><a href="#cb18-27"></a>    <span class="co">// Pointer like functions</span></span>
<span id="cb18-28"><a href="#cb18-28"></a>    <span class="at">const</span> T<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb18-29"><a href="#cb18-29"></a>        <span class="cf">return</span> <span class="va">m_underlying_ptr</span><span class="op">;</span></span>
<span id="cb18-30"><a href="#cb18-30"></a>    <span class="op">}</span></span>
<span id="cb18-31"><a href="#cb18-31"></a></span>
<span id="cb18-32"><a href="#cb18-32"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb18-33"><a href="#cb18-33"></a>    T<span class="op">*</span> <span class="va">m_underlying_ptr</span><span class="op">;</span></span>
<span id="cb18-34"><a href="#cb18-34"></a>    ControlBlockBase<span class="op">*</span> <span class="va">m_control_block_ptr</span><span class="op">;</span>  <span class="co">// Concept* pointer</span></span>
<span id="cb18-35"><a href="#cb18-35"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Observe that, as long as the two <code>shared_ptr</code> types share the same signature, they can be assigned to each other and the destruction is going to be correct.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">struct</span> Foo<span class="op">{};</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="kw">struct</span> Bar<span class="op">{};</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> ptr1<span class="op">{</span> <span class="kw">new</span> Foo<span class="op">()</span> <span class="op">};</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> ptr2<span class="op">{</span> <span class="kw">new</span> Bar<span class="op">()</span> <span class="op">};</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>    ptr1 <span class="op">=</span> ptr2<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/xboYxMsYd">Compiler Explorer</a></p>
<p>I was explaining earlier why a <code>shared_ptr&lt;void&gt;</code> is allowed whereas a <code>unique_ptr&lt;void&gt;</code> won’t compile.</p>
<p>You can see that, what the <code>shared_ptr</code> design does is, in the single parameter constructor, when you don’t pass a deleter, it uses a default deleter of the actual object type. It retains the information of the actual object type. It does not use a default deleter of template type parameter <code>T</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">class</span> shared_ptr<span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="kw">requires</span> <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>Y<span class="op">*,</span> T<span class="op">*&gt;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">)</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="op">:</span> shared_ptr<span class="op">(</span>ptr<span class="op">,</span> <span class="bu">std::</span>default_delete<span class="op">&lt;</span>Y<span class="op">&gt;{})</span> <span class="co">// default deleter of ObjType</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="op">{}</span></span>
<span id="cb20-12"><a href="#cb20-12"></a></span>
<span id="cb20-13"><a href="#cb20-13"></a>    <span class="co">// Templated constructor</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Y<span class="op">,</span> <span class="kw">typename</span> Deleter<span class="op">&gt;</span></span>
<span id="cb20-15"><a href="#cb20-15"></a>    shared_ptr<span class="op">(</span>Y<span class="op">*</span> ptr<span class="op">,</span> Deleter deleter<span class="op">)</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>    <span class="op">:</span> <span class="va">m_underlying_ptr</span><span class="op">{</span>ptr<span class="op">}</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>    <span class="op">,</span> <span class="va">m_control_block_ptr</span><span class="op">{</span> <span class="kw">new</span> ControlBlock<span class="op">&lt;</span>Y<span class="op">,</span>Deleter<span class="op">&gt;(</span>deleter<span class="op">)</span> <span class="op">}</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    <span class="op">{}</span></span>
<span id="cb20-19"><a href="#cb20-19"></a></span>
<span id="cb20-20"><a href="#cb20-20"></a>    <span class="co">// ...</span></span>
<span id="cb20-21"><a href="#cb20-21"></a></span>
<span id="cb20-22"><a href="#cb20-22"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb20-23"><a href="#cb20-23"></a>    T<span class="op">*</span> <span class="va">m_underlying_ptr</span><span class="op">;</span></span>
<span id="cb20-24"><a href="#cb20-24"></a>    ControlBlockBase<span class="op">*</span> <span class="va">m_control_block_ptr</span><span class="op">;</span>  <span class="co">// Concept* pointer</span></span>
<span id="cb20-25"><a href="#cb20-25"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>