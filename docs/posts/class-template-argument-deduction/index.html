<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2024-11-25">

<title>quantdev.blog - Class Template Argument Deduction(CTAD)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Class Template Argument Deduction(CTAD)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 25, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#function-template-argument-deduction." id="toc-function-template-argument-deduction." class="nav-link active" data-scroll-target="#function-template-argument-deduction.">Function Template Argument Deduction.</a></li>
  <li><a href="#ctad-class-template-argument-deduction." id="toc-ctad-class-template-argument-deduction." class="nav-link" data-scroll-target="#ctad-class-template-argument-deduction.">CTAD (Class Template Argument Deduction).</a>
  <ul class="collapse">
  <li><a href="#the-basic-mechanics." id="toc-the-basic-mechanics." class="nav-link" data-scroll-target="#the-basic-mechanics.">The basic mechanics.</a></li>
  </ul></li>
  <li><a href="#deduction-guides." id="toc-deduction-guides." class="nav-link" data-scroll-target="#deduction-guides.">Deduction Guides.</a>
  <ul class="collapse">
  <li><a href="#list-initialization-has-priority" id="toc-list-initialization-has-priority" class="nav-link" data-scroll-target="#list-initialization-has-priority">List initialization has priority</a></li>
  </ul></li>
  <li><a href="#sequence-containers" id="toc-sequence-containers" class="nav-link" data-scroll-target="#sequence-containers">Sequence Containers</a></li>
  <li><a href="#locks-and-mutexes." id="toc-locks-and-mutexes." class="nav-link" data-scroll-target="#locks-and-mutexes.">Locks and Mutexes.</a></li>
  <li><a href="#smart-pointers." id="toc-smart-pointers." class="nav-link" data-scroll-target="#smart-pointers.">Smart Pointers.</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="function-template-argument-deduction." class="level2">
<h2 class="anchored" data-anchor-id="function-template-argument-deduction.">Function Template Argument Deduction.</h2>
<p>Its super-helpful to have a good low-level hang of the template argument deduction rules (more on deduction guides in another post). Essentially, since C++17, you can just declare, <code>std::vector{1.0, 2.0, 3.0, 4.0, 5.0}</code> - clean and nice instead of <code>std::vector&lt;double&gt;{1.0, 2.0, 3.0, 4.0, 5.0}</code>.</p>
<p>When the compiler tries to deduce the template arguments, it performs matching of the type template parameters with the types of arguments used to invoke the function.</p>
<p>Very succinctly, the compiler can match: - Types of the form <code>T</code>, <code>T const</code>, <code>T volatile</code> - Pointers <code>T*</code>, lvalue references <code>T&amp;</code> and universal references <code>T&amp;&amp;</code> - Arrays such as <code>T[5]</code> and <code>C[5][n]</code> - Pointers to functions - Pointers to member-functions and data-members.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> vec<span class="op">){</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span> i <span class="op">&lt;</span> vec<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span> i<span class="op">){</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        out <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">["</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">"] = "</span> <span class="op">&lt;&lt;</span> vec<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="kw">struct</span> BondDiscountingCurve<span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>year_month_day<span class="op">,</span><span class="dt">double</span><span class="op">&gt;&gt;</span> discountFactorCurve<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="op">};</span></span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="kw">struct</span> CustomBond<span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> cashflows<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>year_month_day<span class="op">&gt;</span> cashflow_dates<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="dt">double</span> pv<span class="op">(</span>BondDiscountingCurve disc<span class="op">){</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="dt">double</span> result<span class="op">{</span><span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span>i <span class="op">&lt;</span> cashflows<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>        <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            <span class="dt">double</span> df <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>disc<span class="op">.</span>discountFactorCurve<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>            result <span class="op">+=</span> cashflows<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> df<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>        <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="op">};</span></span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="kw">struct</span> Leg<span class="op">{</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="co">// A cashflow is a 4-tuple (Cashflow date, Cashflow amount, Cap, Floor)</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="kw">using</span> flow <span class="op">=</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>year_month_day<span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;;</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>flow<span class="op">&gt;</span> flows<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="op">};</span></span>
<span id="cb1-40"><a href="#cb1-40"></a></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="kw">struct</span> AssetSwap<span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    Leg bondLeg<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>    Leg fundingLeg<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a>    Leg getBondLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> bondLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>    Leg getFundingLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> fundingLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="op">};</span></span>
<span id="cb1-48"><a href="#cb1-48"></a></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="dt">void</span> process01<span class="op">(</span>T bond<span class="op">){</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span class="dt">void</span> process02<span class="op">(</span>T <span class="at">const</span><span class="op">){</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T const</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-54"><a href="#cb1-54"></a></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-56"><a href="#cb1-56"></a><span class="dt">void</span> process03<span class="op">(</span>T <span class="at">volatile</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T volatile</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-57"><a href="#cb1-57"></a></span>
<span id="cb1-58"><a href="#cb1-58"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">*)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63"></a></span>
<span id="cb1-64"><a href="#cb1-64"></a><span class="co">// Universal reference</span></span>
<span id="cb1-65"><a href="#cb1-65"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="dt">void</span> process05<span class="op">(</span>T<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T&amp;&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-67"><a href="#cb1-67"></a></span>
<span id="cb1-68"><a href="#cb1-68"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-69"><a href="#cb1-69"></a><span class="dt">void</span> process06<span class="op">(</span>T<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T[5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70"></a></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-72"><a href="#cb1-72"></a><span class="dt">void</span> process07<span class="op">(</span>T<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T[3][5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-73"><a href="#cb1-73"></a></span>
<span id="cb1-74"><a href="#cb1-74"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-75"><a href="#cb1-75"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-76"><a href="#cb1-76"></a></span>
<span id="cb1-77"><a href="#cb1-77"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-78"><a href="#cb1-78"></a><span class="dt">void</span> process08<span class="op">(</span>CustomBond <span class="op">(*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"C (*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79"></a></span>
<span id="cb1-80"><a href="#cb1-80"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-82"><a href="#cb1-82"></a></span>
<span id="cb1-83"><a href="#cb1-83"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-84"><a href="#cb1-84"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (C::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-85"><a href="#cb1-85"></a></span>
<span id="cb1-86"><a href="#cb1-86"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-87"><a href="#cb1-87"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (C::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-88"><a href="#cb1-88"></a></span>
<span id="cb1-89"><a href="#cb1-89"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-90"><a href="#cb1-90"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (U::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91"></a></span>
<span id="cb1-92"><a href="#cb1-92"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb1-93"><a href="#cb1-93"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)(</span>V<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T (U::*)(V)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-94"><a href="#cb1-94"></a></span>
<span id="cb1-95"><a href="#cb1-95"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-96"><a href="#cb1-96"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"C (T::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-97"><a href="#cb1-97"></a></span>
<span id="cb1-98"><a href="#cb1-98"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-99"><a href="#cb1-99"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"C (T::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-100"><a href="#cb1-100"></a></span>
<span id="cb1-101"><a href="#cb1-101"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>AssetSwap<span class="op">::*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"D (C::*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-103"><a href="#cb1-103"></a></span>
<span id="cb1-104"><a href="#cb1-104"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-105"><a href="#cb1-105"></a><span class="dt">void</span> process10<span class="op">(</span>T CustomBond<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T C::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106"></a></span>
<span id="cb1-107"><a href="#cb1-107"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-108"><a href="#cb1-108"></a><span class="dt">void</span> process10<span class="op">(</span>Leg T<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"C T::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-109"><a href="#cb1-109"></a></span>
<span id="cb1-110"><a href="#cb1-110"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-111"><a href="#cb1-111"></a><span class="dt">void</span> process10<span class="op">(</span>T U<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"T U::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-112"><a href="#cb1-112"></a></span>
<span id="cb1-113"><a href="#cb1-113"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-114"><a href="#cb1-114"></a><span class="op">{</span></span>
<span id="cb1-115"><a href="#cb1-115"></a>    CustomBond bond<span class="op">(</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>        <span class="op">{</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">1.05</span><span class="op">},</span></span>
<span id="cb1-117"><a href="#cb1-117"></a>        <span class="op">{</span><span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">}</span></span>
<span id="cb1-118"><a href="#cb1-118"></a>    <span class="op">);</span></span>
<span id="cb1-119"><a href="#cb1-119"></a></span>
<span id="cb1-120"><a href="#cb1-120"></a>    AssetSwap assetSwap<span class="op">;</span></span>
<span id="cb1-121"><a href="#cb1-121"></a></span>
<span id="cb1-122"><a href="#cb1-122"></a>    process01<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>    process02<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T const</span></span>
<span id="cb1-124"><a href="#cb1-124"></a>    process03<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T volatile</span></span>
<span id="cb1-125"><a href="#cb1-125"></a>    process04<span class="op">(&amp;</span>bond<span class="op">);</span>   <span class="co">// T*</span></span>
<span id="cb1-126"><a href="#cb1-126"></a>    process04<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;</span></span>
<span id="cb1-127"><a href="#cb1-127"></a>    process05<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;&amp;; deduced as CustomBond&amp; </span></span>
<span id="cb1-128"><a href="#cb1-128"></a></span>
<span id="cb1-129"><a href="#cb1-129"></a>    CustomBond bondsArray<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span>  <span class="co">//Create an array of custom bonds</span></span>
<span id="cb1-130"><a href="#cb1-130"></a>    process06<span class="op">(</span>bondsArray<span class="op">);</span>  <span class="co">// T[5]</span></span>
<span id="cb1-131"><a href="#cb1-131"></a>    process06<span class="op">(&amp;</span>bond<span class="op">);</span>       <span class="co">// T[5]</span></span>
<span id="cb1-132"><a href="#cb1-132"></a></span>
<span id="cb1-133"><a href="#cb1-133"></a>    CustomBond bondsByMaturityAndRating<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span> </span>
<span id="cb1-134"><a href="#cb1-134"></a>    process07<span class="op">(</span>bondsByMaturityAndRating<span class="op">);</span>    <span class="co">//C[5][n]</span></span>
<span id="cb1-135"><a href="#cb1-135"></a></span>
<span id="cb1-136"><a href="#cb1-136"></a>    CustomBond <span class="op">(*</span>funcptr1<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-137"><a href="#cb1-137"></a>    CustomBond <span class="op">(*</span>funcptr2<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-138"><a href="#cb1-138"></a>    <span class="dt">double</span>     <span class="op">(*</span>funcptr3<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-139"><a href="#cb1-139"></a></span>
<span id="cb1-140"><a href="#cb1-140"></a>    process08<span class="op">(</span>funcptr1<span class="op">);</span>    <span class="co">//T(*)()</span></span>
<span id="cb1-141"><a href="#cb1-141"></a>    process08<span class="op">(</span>funcptr2<span class="op">);</span>    <span class="co">//C(*)(T)</span></span>
<span id="cb1-142"><a href="#cb1-142"></a>    process08<span class="op">(</span>funcptr3<span class="op">);</span>    <span class="co">//T(*)(U)</span></span>
<span id="cb1-143"><a href="#cb1-143"></a></span>
<span id="cb1-144"><a href="#cb1-144"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc1<span class="op">)</span> <span class="op">()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-145"><a href="#cb1-145"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc2<span class="op">)(</span>BondDiscountingCurve<span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>CustomBond<span class="op">::</span>pv<span class="op">;</span></span>
<span id="cb1-146"><a href="#cb1-146"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">(</span>Leg<span class="op">::*</span>ptrmemfunc3<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-147"><a href="#cb1-147"></a>    <span class="dt">double</span><span class="op">(</span>AssetSwap<span class="op">::*</span>getLegPv<span class="op">)(</span>Leg<span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-148"><a href="#cb1-148"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>ptrmemfunc4<span class="op">)()</span> <span class="op">=</span> <span class="op">&amp;</span>AssetSwap<span class="op">::</span>getFundingLeg<span class="op">;</span></span>
<span id="cb1-149"><a href="#cb1-149"></a>    Leg<span class="op">(</span>Leg<span class="op">::*</span>applyScaleToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-150"><a href="#cb1-150"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>applyFixedSpreadToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-151"><a href="#cb1-151"></a>    <span class="co">//Leg(AssetSwap::*)()</span></span>
<span id="cb1-152"><a href="#cb1-152"></a></span>
<span id="cb1-153"><a href="#cb1-153"></a>    process09<span class="op">(</span>ptrmemfunc1<span class="op">);</span>     <span class="co">// T(C::*)()</span></span>
<span id="cb1-154"><a href="#cb1-154"></a>    process09<span class="op">(</span>ptrmemfunc2<span class="op">);</span>     <span class="co">// T(C::*)(U)</span></span>
<span id="cb1-155"><a href="#cb1-155"></a>    process09<span class="op">(</span>ptrmemfunc3<span class="op">);</span>     <span class="co">// T(U::*)()</span></span>
<span id="cb1-156"><a href="#cb1-156"></a>    process09<span class="op">(</span>getLegPv<span class="op">);</span>        <span class="co">// T(U::*)(V)</span></span>
<span id="cb1-157"><a href="#cb1-157"></a>    process09<span class="op">(</span>ptrmemfunc4<span class="op">);</span>     <span class="co">// C(T::*)()</span></span>
<span id="cb1-158"><a href="#cb1-158"></a>    process09<span class="op">(</span>applyScaleToAllCoupons<span class="op">);</span>          <span class="co">//C(T::*)(U)</span></span>
<span id="cb1-159"><a href="#cb1-159"></a>    process09<span class="op">(</span>applyFixedSpreadToAllCoupons<span class="op">);</span>    <span class="co">//D(C::*)(T)</span></span>
<span id="cb1-160"><a href="#cb1-160"></a></span>
<span id="cb1-161"><a href="#cb1-161"></a>    process10<span class="op">(&amp;</span>CustomBond<span class="op">::</span>cashflows<span class="op">);</span></span>
<span id="cb1-162"><a href="#cb1-162"></a>    process10<span class="op">(&amp;</span>AssetSwap<span class="op">::</span>bondLeg<span class="op">);</span></span>
<span id="cb1-163"><a href="#cb1-163"></a>    process10<span class="op">(&amp;</span>Leg<span class="op">::</span>flows<span class="op">);</span></span>
<span id="cb1-164"><a href="#cb1-164"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-165"><a href="#cb1-165"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/6zsxEchcv">Compiler Explorer</a></p>
</section>
<section id="ctad-class-template-argument-deduction." class="level2">
<h2 class="anchored" data-anchor-id="ctad-class-template-argument-deduction.">CTAD (Class Template Argument Deduction).</h2>
<section id="the-basic-mechanics." class="level3">
<h3 class="anchored" data-anchor-id="the-basic-mechanics.">The basic mechanics.</h3>
<p>CTAD(Class Template Argument Deduction) has <span class="math inline">\(2\)</span> phases:</p>
<ol type="1">
<li><p>Deduction (CTAD) - The first step is, the compiler is going to deduce the types that you didn’t write.</p></li>
<li><p>Initialization - The second step is, it’s going to initialize the object.</p></li>
</ol>
<p>Let’s take a templated class <code>pair</code>, this is just a fictional class, it is not actually how <code>std::pair&lt;&gt;</code> looks like:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb2" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">struct</span> pair<span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    T first<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    U second<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a>    pair<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> _first<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> _second<span class="op">)</span> </span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="op">:</span> first<span class="op">(</span>_first<span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="op">,</span> second<span class="op">(</span>_second<span class="op">)</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="op">{}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>    pair<span class="op">(</span>T<span class="op">&amp;&amp;</span> _first<span class="op">,</span> U<span class="op">&amp;&amp;</span> _second<span class="op">)</span> </span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="op">:</span> first<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>T<span class="op">&gt;(</span>_first<span class="op">))</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="op">,</span> second<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>U<span class="op">&gt;(</span>_second<span class="op">))</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    <span class="op">{}</span></span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="co">//other stuff</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is an oversimplification that is enough for our purposes. So, you have a templated class with two template parameters <code>T</code> and <code>U</code> and then you have a bunch of constructors. Now, we want to instantiate one of these things:</p>
<div class="sourceCode" id="cb3" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>pair p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You want to construct an object of type <code>pair</code>. The next thing the compiler sees is, <code>pair</code> is a template. And we didn’t specify any template arguments. Probably, you <em>wanna</em> do class template argument deduction.</p>
<p>The next thing happens. <code>pair</code> has a bunch of constructors. Probably, you <em>wanna</em> call one of those constructors. And this where step 1 kicks in, which is the actual <em>Class Template Argument Deduction</em>(CTAD).</p>
<p>So, how does the compiler figure out, what you actually want to instantiate? So, it’s going to look at those constructors. Let’s pretend for a minute, that those constructors are ordinary functions - just free-standing functions. Now, these functions use class template parameters. Let’s pretend for a moment, that those template parameters are template parameters for the function.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb4" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">struct</span> pair<span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    T first<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    U second<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">// Imagine this to be a function template</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span>  </span>
<span id="cb4-8"><a href="#cb4-8"></a>    pair<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> _first<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> _second<span class="op">)</span> </span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="op">:</span> first<span class="op">(</span>_first<span class="op">)</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="op">,</span> second<span class="op">(</span>_second<span class="op">)</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="op">{}</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="co">// Imagine this to be a function template</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    pair<span class="op">(</span>T<span class="op">&amp;&amp;</span> _first<span class="op">,</span> U<span class="op">&amp;&amp;</span> _second<span class="op">)</span> </span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="op">:</span> first<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>T<span class="op">&gt;(</span>_first<span class="op">))</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="op">,</span> second<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>U<span class="op">&gt;(</span>_second<span class="op">))</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="op">{}</span></span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="co">//other stuff</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, this code doesn’t exist. It’s just what the compiler temporarily does for you. And it generates these template functions from the constructors and they are called the <em>deduction candidates</em>.</p>
<p>And now, if we have a call like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb5" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>pair p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>we know, how to deal with functions right. So, it’s going to look at these functions and apply the usual template arguments deduction and the usual overload resolution.</p>
<p><code>"OptionVolQuote"s</code> is a <em>lvalue</em> that gets converted to an <em>xvalue</em> (by the <code>std::string()</code> constructor) and <code>0.50</code> is a <em>prvalue</em>. these arguments bind to universal references. So, the <code>pair(T&amp;&amp;, U&amp;&amp;)</code> version is chosen by the compiler from the overload set, during overload resolution. Further, <code>T</code> is deduced as <code>std::string</code> and <code>U</code> is deduced as <code>double</code>. The compiler literally inserts them as:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb6" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>pair<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span><span class="dt">double</span><span class="op">&gt;</span> p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, its going to do, what it would have done, if you would have written <code>pair&lt;std::string,double&gt;</code>. So, now we know, that this <code>pair</code> is actually <code>pair&lt;std::string,int&gt;</code>. So, the step 1 is done.</p>
<p>Now, what we can do is, we can actually instantiate the function template! That’s step 2. So, you have an actual constructor and it will be called by the run-time to create an object of <code>pair&lt;std::string,int&gt;</code>. And we are done.</p>
<p>If we write:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb7" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="at">const</span> <span class="kw">auto</span> s<span class="op">{</span><span class="st">"5YSwapRate"</span><span class="bu">s</span><span class="op">};</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="at">const</span> <span class="kw">auto</span> rate<span class="op">{</span><span class="fl">0.0125</span><span class="op">};</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>pair p2<span class="op">{</span>s<span class="op">,</span>rate<span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, <code>s</code> and <code>rate</code> are identifiers, so these are <em>glvalues</em> and can bind to <code>const T&amp;</code>. So, the compiler instantiates the first overload of the constructor as <code>pair(const std::string&amp;, const double&amp;)</code>.</p>
<p>There’s no need to use <code>std::make_pair</code> anymore. This <code>make_pair</code> thing is a basically a work-around for the fact that up until C++14, you could only do this with functions. So, you had to use a function to deduce the class template arguments. So, it was kind of hacky. And now we don’t need to use that anymore.</p>
<p>The same goes for <code>std::tuple</code>, you can instantiate a <code>std::tuple</code> with a bunch of arguments and it’s going to deduce the correct types for you, so you don’t need to use <code>std::make_tuple</code> anymore.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb8" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="bu">std::</span>tuple<span class="op"> </span>point<span class="op">{</span><span class="fl">1.00</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.00</span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s look at <code>std::vector</code>. So, for example, if you just give it an <code>std::initializer_list</code> of <code>int</code>s, its gonna correctly deduce back to <code>std::vector&lt;int&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb9" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">13</span><span class="op">};</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Of course, with <code>std::vector</code>, there’s a trap. <code>std::vector</code> has this other constructor which takes a <code>std::size_t</code>, and it initializes a vector with that many elements in it.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb10" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">// content is {3}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">// content is {0,0,0}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, in C++14, if you write <code>std::vector&lt;int&gt; v{3}</code> with curly braces, it’s going to be an initializer list, so its going to initialize the vector with one <code>int</code>, which is <code>3</code>. If you <code>std::vector&lt;int&gt; v(3)</code> with parenthesis, it’s going to call the <code>size_t</code> constructor, and you’re gonna have 3 <code>int</code>s, which are initialized to <code>0.0</code>.</p>
<p>Now, what happens if you omit the <code>int</code> and use class-template argument deduction? Then if you write the curlies, its going to do the deduction. But if you use round parenthesis, it says, well you’re calling the constructor that takes a <code>size_t</code>, so you are going to have 3 elements, but 3 elements of what type? You didn’t specify! So, you get a compiler error.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb11" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="bu">std::</span>vector<span class="op"> </span>v1<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">// Ok- deduces std::vector&lt;int&gt;, content is {3}</span></span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">// std::vector v2(3);</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">// Error : 3 elements of what?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>std::vector</code> has another constructor, which is really cool! Now, some real magic happens here! So, if you have a range of <code>int</code>s, any range, then there’s this constructor that takes a pair of iterators like <code>begin()</code> and <code>end()</code> and if you don’t specify the <code>int</code>, it is still going to figure out, that those iterators are iterators to <code>int</code> range and it is going correctly deduce <code>std::vector&lt;int&gt;</code> for you.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb12" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>How does that work? It has this constructor which looks like the below. It takes two iterators.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb13" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">struct</span> vector</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If you have a constructor that also has template arguments, the compiler is going to pretend that this is a function and it’s going to take the template argument of the class and concatenate it with the constructor’s template argument. It’s going to put them one after the other.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb14" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">// This is magic code, generated by the compiler</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">struct</span> vector</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="co">// range c'tor</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="co">// other stuff</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, if you call it like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb15" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>it’s going to say, well okay, you are giving me two iterators, so I can deduce the type of iterators as <code>std::vector&lt;&gt;::iterator</code>. But, you didn’t specify <code>T</code>, so I still don’t know what <code>T</code> is. So, how is it able to figure this out?</p>
</section>
</section>
<section id="deduction-guides." class="level1">
<h1>Deduction Guides.</h1>
<p>This is another feature called deduction guides. When the compiler can’t figure out, with this machinery, what the type is, but it is kind of obvious to you, what the type should be, you can write a deduction guide.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb16" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">struct</span> vector</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="op">};</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">// deduction guide:</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>vector<span class="op">(</span>Iter begin<span class="op">,</span> Iter end<span class="op">)</span> </span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="op">-&gt;</span> vector<span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">::</span>iterator_traits<span class="op">&lt;</span>Iter<span class="op">&gt;::</span><span class="dt">value_type</span><span class="op">&gt;;</span></span>
<span id="cb16-15"><a href="#cb16-15"></a></span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It starts with something that looks like a constructor signature, and then you have this arrow <code>-&gt;</code> and after the arrow, you put like a specialization of the same class. So, you are gonna say, well, if you have this constructor signature (which will be added to the deduction candidates), and if this is the one that is going to be selected by the compiler, then deduce the type after the arrow (<code>-&gt;</code>). So, this is like a new entity in C++17. It’s not a class, it’s not a function, it’s a <em>deduction guide</em>.</p>
<p>With that deduction guide, basically you’re saying, well, if I get two iterators, then take the iterator traits, figure out the value type which this iterator points to and initialize the vector with that type. And that works and compiles.</p>
<p>So, this compiles, but actually the order matters. Deductions guides are only considered for the code that is below the deduction guide.</p>
<p>So, if you flip around the order:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb17" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">struct</span> vector</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="op">};</span></span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="co">//std::vector v(range.begin(), range.end());</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co">// Error: deduction failed</span></span>
<span id="cb17-14"><a href="#cb17-14"></a></span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="co">// deduction guide:</span></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>vector<span class="op">(</span>Iter begin<span class="op">,</span> Iter end<span class="op">)</span> </span>
<span id="cb17-18"><a href="#cb17-18"></a>    <span class="op">-&gt;</span> vector<span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">::</span>iterator_traits<span class="op">&lt;</span>Iter<span class="op">&gt;::</span><span class="dt">value_type</span><span class="op">&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>then it’s not going to work anymore.</p>
<p>One thing that’s really a good recommendation, is that these deduction guides are really part of the class interface. Because they tell you, you can instantiate this class template like this, so <em>deduction guides should be defined immediately after the class definition</em>.</p>
<section id="list-initialization-has-priority" class="level2">
<h2 class="anchored" data-anchor-id="list-initialization-has-priority">List initialization has priority</h2>
<p>You really have to be careful with the parenthesis and the curlies.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb18" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">{</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">()};</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">// list initialization has a priority, so the compiler deduces it</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">// as std::vector&lt;std::vector&lt;int&gt;::iterator&gt;, which is </span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">// probably not what we want</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="sequence-containers" class="level1">
<h1>Sequence Containers</h1>
<p>CTAD works the same with all the other sequence containers.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb19" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;list&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#include </span><span class="im">&lt;deque&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="bu">std::</span>list<span class="op"> </span>l<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="co">//deduces std::list&lt;int&gt;</span></span>
<span id="cb19-12"><a href="#cb19-12"></a></span>
<span id="cb19-13"><a href="#cb19-13"></a>    <span class="bu">std::</span>forward_list<span class="op"> </span>fl<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-14"><a href="#cb19-14"></a>    <span class="co">//deduces std::forward_list&lt;int&gt;</span></span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a>    <span class="bu">std::</span>deque<span class="op"> </span>d<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>    <span class="co">//deduces std::deque&lt;int&gt;</span></span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a>    <span class="bu">std::</span>array<span class="op"> </span>a<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>    <span class="co">//deduces std::array&lt;int,5&gt;</span></span>
<span id="cb19-21"><a href="#cb19-21"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="https://godbolt.org/z/d74a8c4f5">Compiler Explorer</a></p>
<p>With <code>std::array&lt;T,N&gt;</code> it also deduces the size for you. We are going to see later, how that works. They also have these range constructors except for <code>std::array&lt;T,N&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb20" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="bu">std::</span>vector<span class="op"> </span>range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="bu">std::</span>list<span class="op"> </span>l<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">// deduces std::list&lt;int&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="bu">std::</span>forward_list<span class="op"> </span>fl<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">// deduces std::foward_list&lt;int&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="bu">std::</span>deque<span class="op"> </span>d<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">// deduces std::deque&lt;int&gt;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="co">// also, the same pitfall - don't use curly braces</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, there is <code>std::set</code>. <code>std::set</code> also has both of these constructors. But, <code>std::set</code> also has more stuff. You know, <code>std::set</code> has this external template parameter which is the comparison function, so you can specify your own comparator lambda. And that’s a template argument. But, the cool thing is, <code>std::set</code> also has a constructor, that takes this comparator as a template argument and it can deduce that as well. So, we can actually write something like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb21" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="bu">std::</span>set<span class="op"> </span>s<span class="op">({</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">},</span> <span class="op">[](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span><span class="cf">return</span> a <span class="op">&gt;</span> b<span class="op">;});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice that you don’t have to pass the type of the lambda <code>bool (int,int)</code>, the compiler will automatically deduce it for you.</p>
</section>
<section id="locks-and-mutexes." class="level1">
<h1>Locks and Mutexes.</h1>
<p>One of the most popular use-cases for CTAD is mutexes. When you have long type names like <code>std::shared_timed_mutex mtx</code> and then if you had to lock it, you had to specify this thing: <code>std::lock_guard&lt;std::shared_timed_mutex&gt; lock(mtx)</code>. With C++17, you don’t have to do that anymore:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb22" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">std::</span>shared_timed_mutex<span class="op"> </span>mtx<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="bu">std::</span>lock_guard<span class="op"> </span>lock<span class="op">(</span>mtx<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">// deduced as std::lock_guard&lt;std::shared_timed_mutex&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="smart-pointers." class="level1">
<h1>Smart Pointers.</h1>
<p>This is one of the prime examples, where class template argument deduction can be dangerous and damaging. Let’s say you have a <code>struct Citizen</code> with some constructor. And, then you want to create a <code>Citizen</code> instance dynamically on the heap. You would maybe expect to write:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb23" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">struct</span> Citizen<span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="co">//c'tor</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    Citizen<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>prefix<span class="op">,</span> <span class="dt">int</span> serial_number<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">};</span></span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="co">// std::shared_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co">// Error! No CTAD</span></span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">auto</span> sptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>Citizen<span class="op">&gt;(</span><span class="st">"THX"</span><span class="op">,</span><span class="dv">1138</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You give it a pointer to this dynamically allocated <code>Citizen</code> object, and then you think it’s going to work. But, that fails and for good reason! It’s specifically disabled. So, you’re back to using <code>make_shared&lt;T&gt;</code> again. The same with <code>std::unique_ptr&lt;T&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb24" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">// std::unique_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="co">// Error! No CTAD</span></span>
<span id="cb24-3"><a href="#cb24-3"></a></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">auto</span> uptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Citizen<span class="op">&gt;(</span><span class="st">"THX"</span><span class="op">,</span><span class="dv">1138</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It’s not going to the deduce the type <code>T</code>; you have to use <code>make_unique&lt;T&gt;</code>.</p>
<p>There’s good reasons for this. First of all, <code>make_shared&lt;T&gt;</code> has exception safety built in. If for some reason, the constructor fails and <code>throw</code>s, then you are not going to leak memory.</p>
<p>Secondly, if you have an array, and you pass it to a constructor, it decays into a pointer. If you had class-template argument deduction smart-pointers, you could write like that:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb25" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">// std::unique_ptr uptr(new int[10]);</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="co">// if that would compile, uh-oh!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A pointer to an array would decay to a pointer to an <code>int</code> for you. When the pointer goes out of scope, the destructor of <code>std::shared_ptr</code> calls <code>delete</code> on <code>sptr</code> and not <code>delete[]</code>.</p>
<p>This is definitely a bug! We don’t want people to be able to use CTAD here.</p>
<p>We would like to disable CTAD. Now, the question is how do we disable it? How do we make sure that it doesn’t work.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>