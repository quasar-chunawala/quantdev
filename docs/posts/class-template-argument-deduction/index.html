<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2024-11-25">

<title>Class Template Argument Deduction(CTAD) â€“ quantdev.blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-f2a1071e85750ec973bbb8a8f120da0f.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c7c5442de8a335b1f49be48b1aa284fe.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Class Template Argument Deduction(CTAD)</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 25, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#function-template-argument-deduction." id="toc-function-template-argument-deduction." class="nav-link active" data-scroll-target="#function-template-argument-deduction.">Function Template Argument Deduction.</a></li>
  <li><a href="#ctad-class-template-argument-deduction." id="toc-ctad-class-template-argument-deduction." class="nav-link" data-scroll-target="#ctad-class-template-argument-deduction.">CTAD (Class Template Argument Deduction).</a>
  <ul class="collapse">
  <li><a href="#the-basic-mechanics." id="toc-the-basic-mechanics." class="nav-link" data-scroll-target="#the-basic-mechanics.">The basic mechanics.</a></li>
  </ul></li>
  <li><a href="#deduction-guides." id="toc-deduction-guides." class="nav-link" data-scroll-target="#deduction-guides.">Deduction Guides.</a>
  <ul class="collapse">
  <li><a href="#list-initialization-has-priority" id="toc-list-initialization-has-priority" class="nav-link" data-scroll-target="#list-initialization-has-priority">List initialization has priority</a></li>
  </ul></li>
  <li><a href="#sequence-containers" id="toc-sequence-containers" class="nav-link" data-scroll-target="#sequence-containers">Sequence Containers</a></li>
  <li><a href="#locks-and-mutexes." id="toc-locks-and-mutexes." class="nav-link" data-scroll-target="#locks-and-mutexes.">Locks and Mutexes.</a></li>
  <li><a href="#smart-pointers." id="toc-smart-pointers." class="nav-link" data-scroll-target="#smart-pointers.">Smart Pointers.</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="function-template-argument-deduction." class="level2">
<h2 class="anchored" data-anchor-id="function-template-argument-deduction.">Function Template Argument Deduction.</h2>
<p>Its super-helpful to have a good low-level hang of the template argument deduction rules (more on deduction guides in another post). Essentially, since C++17, you can just declare, <code>std::vector{1.0, 2.0, 3.0, 4.0, 5.0}</code> - clean and nice instead of <code>std::vector&lt;double&gt;{1.0, 2.0, 3.0, 4.0, 5.0}</code>.</p>
<p>When the compiler tries to deduce the template arguments, it performs matching of the type template parameters with the types of arguments used to invoke the function.</p>
<p>Very succinctly, the compiler can match: - Types of the form <code>T</code>, <code>T const</code>, <code>T volatile</code> - Pointers <code>T*</code>, lvalue references <code>T&amp;</code> and universal references <code>T&amp;&amp;</code> - Arrays such as <code>T[5]</code> and <code>C[5][n]</code> - Pointers to functions - Pointers to member-functions and data-members.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> vec<span class="op">){</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span> i <span class="op">&lt;</span> vec<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span> i<span class="op">){</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        out <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">["</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">"] = "</span> <span class="op">&lt;&lt;</span> vec<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="kw">struct</span> BondDiscountingCurve<span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>year_month_day<span class="op">,</span><span class="dt">double</span><span class="op">&gt;&gt;</span> discountFactorCurve<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="op">};</span></span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="kw">struct</span> CustomBond<span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> cashflows<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>chrono::year_month_day<span class="op">&gt;</span> cashflow_dates<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="dt">double</span> pv<span class="op">(</span>BondDiscountingCurve disc<span class="op">){</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="dt">double</span> result<span class="op">{</span><span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span>i <span class="op">&lt;</span> cashflows<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>        <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            <span class="dt">double</span> df <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>disc<span class="op">.</span>discountFactorCurve<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>            result <span class="op">+=</span> cashflows<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> df<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>        <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="op">};</span></span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="kw">struct</span> Leg<span class="op">{</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="co">// A cashflow is a 4-tuple (Cashflow date, Cashflow amount, Cap, Floor)</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="kw">using</span> flow <span class="op">=</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>year_month_day<span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;;</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>flow<span class="op">&gt;</span> flows<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="op">};</span></span>
<span id="cb1-40"><a href="#cb1-40"></a></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="kw">struct</span> AssetSwap<span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    Leg bondLeg<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>    Leg fundingLeg<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a>    Leg getBondLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> bondLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>    Leg getFundingLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> fundingLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="op">};</span></span>
<span id="cb1-48"><a href="#cb1-48"></a></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="dt">void</span> process01<span class="op">(</span>T bond<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span class="dt">void</span> process02<span class="op">(</span>T <span class="at">const</span><span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T const</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-54"><a href="#cb1-54"></a></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-56"><a href="#cb1-56"></a><span class="dt">void</span> process03<span class="op">(</span>T <span class="at">volatile</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T volatile</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-57"><a href="#cb1-57"></a></span>
<span id="cb1-58"><a href="#cb1-58"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63"></a></span>
<span id="cb1-64"><a href="#cb1-64"></a><span class="co">// Universal reference</span></span>
<span id="cb1-65"><a href="#cb1-65"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="dt">void</span> process05<span class="op">(</span>T<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T&amp;&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-67"><a href="#cb1-67"></a></span>
<span id="cb1-68"><a href="#cb1-68"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-69"><a href="#cb1-69"></a><span class="dt">void</span> process06<span class="op">(</span>T<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T[5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70"></a></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-72"><a href="#cb1-72"></a><span class="dt">void</span> process07<span class="op">(</span>T<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T[3][5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-73"><a href="#cb1-73"></a></span>
<span id="cb1-74"><a href="#cb1-74"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-75"><a href="#cb1-75"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-76"><a href="#cb1-76"></a></span>
<span id="cb1-77"><a href="#cb1-77"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-78"><a href="#cb1-78"></a><span class="dt">void</span> process08<span class="op">(</span>CustomBond <span class="op">(*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79"></a></span>
<span id="cb1-80"><a href="#cb1-80"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-82"><a href="#cb1-82"></a></span>
<span id="cb1-83"><a href="#cb1-83"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-84"><a href="#cb1-84"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (C::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-85"><a href="#cb1-85"></a></span>
<span id="cb1-86"><a href="#cb1-86"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-87"><a href="#cb1-87"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (C::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-88"><a href="#cb1-88"></a></span>
<span id="cb1-89"><a href="#cb1-89"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-90"><a href="#cb1-90"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (U::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91"></a></span>
<span id="cb1-92"><a href="#cb1-92"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb1-93"><a href="#cb1-93"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)(</span>V<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (U::*)(V)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-94"><a href="#cb1-94"></a></span>
<span id="cb1-95"><a href="#cb1-95"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-96"><a href="#cb1-96"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (T::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-97"><a href="#cb1-97"></a></span>
<span id="cb1-98"><a href="#cb1-98"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-99"><a href="#cb1-99"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (T::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-100"><a href="#cb1-100"></a></span>
<span id="cb1-101"><a href="#cb1-101"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>AssetSwap<span class="op">::*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"D (C::*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-103"><a href="#cb1-103"></a></span>
<span id="cb1-104"><a href="#cb1-104"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-105"><a href="#cb1-105"></a><span class="dt">void</span> process10<span class="op">(</span>T CustomBond<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T C::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106"></a></span>
<span id="cb1-107"><a href="#cb1-107"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-108"><a href="#cb1-108"></a><span class="dt">void</span> process10<span class="op">(</span>Leg T<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C T::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-109"><a href="#cb1-109"></a></span>
<span id="cb1-110"><a href="#cb1-110"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-111"><a href="#cb1-111"></a><span class="dt">void</span> process10<span class="op">(</span>T U<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T U::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-112"><a href="#cb1-112"></a></span>
<span id="cb1-113"><a href="#cb1-113"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-114"><a href="#cb1-114"></a><span class="op">{</span></span>
<span id="cb1-115"><a href="#cb1-115"></a>    CustomBond bond<span class="op">(</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>        <span class="op">{</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">1.05</span><span class="op">},</span></span>
<span id="cb1-117"><a href="#cb1-117"></a>        <span class="op">{</span><span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">}</span></span>
<span id="cb1-118"><a href="#cb1-118"></a>    <span class="op">);</span></span>
<span id="cb1-119"><a href="#cb1-119"></a></span>
<span id="cb1-120"><a href="#cb1-120"></a>    AssetSwap assetSwap<span class="op">;</span></span>
<span id="cb1-121"><a href="#cb1-121"></a></span>
<span id="cb1-122"><a href="#cb1-122"></a>    process01<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>    process02<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T const</span></span>
<span id="cb1-124"><a href="#cb1-124"></a>    process03<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T volatile</span></span>
<span id="cb1-125"><a href="#cb1-125"></a>    process04<span class="op">(&amp;</span>bond<span class="op">);</span>   <span class="co">// T*</span></span>
<span id="cb1-126"><a href="#cb1-126"></a>    process04<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;</span></span>
<span id="cb1-127"><a href="#cb1-127"></a>    process05<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;&amp;; deduced as CustomBond&amp; </span></span>
<span id="cb1-128"><a href="#cb1-128"></a></span>
<span id="cb1-129"><a href="#cb1-129"></a>    CustomBond bondsArray<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span>  <span class="co">//Create an array of custom bonds</span></span>
<span id="cb1-130"><a href="#cb1-130"></a>    process06<span class="op">(</span>bondsArray<span class="op">);</span>  <span class="co">// T[5]</span></span>
<span id="cb1-131"><a href="#cb1-131"></a>    process06<span class="op">(&amp;</span>bond<span class="op">);</span>       <span class="co">// T[5]</span></span>
<span id="cb1-132"><a href="#cb1-132"></a></span>
<span id="cb1-133"><a href="#cb1-133"></a>    CustomBond bondsByMaturityAndRating<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span> </span>
<span id="cb1-134"><a href="#cb1-134"></a>    process07<span class="op">(</span>bondsByMaturityAndRating<span class="op">);</span>    <span class="co">//C[5][n]</span></span>
<span id="cb1-135"><a href="#cb1-135"></a></span>
<span id="cb1-136"><a href="#cb1-136"></a>    CustomBond <span class="op">(*</span>funcptr1<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-137"><a href="#cb1-137"></a>    CustomBond <span class="op">(*</span>funcptr2<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-138"><a href="#cb1-138"></a>    <span class="dt">double</span>     <span class="op">(*</span>funcptr3<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-139"><a href="#cb1-139"></a></span>
<span id="cb1-140"><a href="#cb1-140"></a>    process08<span class="op">(</span>funcptr1<span class="op">);</span>    <span class="co">//T(*)()</span></span>
<span id="cb1-141"><a href="#cb1-141"></a>    process08<span class="op">(</span>funcptr2<span class="op">);</span>    <span class="co">//C(*)(T)</span></span>
<span id="cb1-142"><a href="#cb1-142"></a>    process08<span class="op">(</span>funcptr3<span class="op">);</span>    <span class="co">//T(*)(U)</span></span>
<span id="cb1-143"><a href="#cb1-143"></a></span>
<span id="cb1-144"><a href="#cb1-144"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc1<span class="op">)</span> <span class="op">()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-145"><a href="#cb1-145"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc2<span class="op">)(</span>BondDiscountingCurve<span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>CustomBond<span class="op">::</span>pv<span class="op">;</span></span>
<span id="cb1-146"><a href="#cb1-146"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">(</span>Leg<span class="op">::*</span>ptrmemfunc3<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-147"><a href="#cb1-147"></a>    <span class="dt">double</span><span class="op">(</span>AssetSwap<span class="op">::*</span>getLegPv<span class="op">)(</span>Leg<span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-148"><a href="#cb1-148"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>ptrmemfunc4<span class="op">)()</span> <span class="op">=</span> <span class="op">&amp;</span>AssetSwap<span class="op">::</span>getFundingLeg<span class="op">;</span></span>
<span id="cb1-149"><a href="#cb1-149"></a>    Leg<span class="op">(</span>Leg<span class="op">::*</span>applyScaleToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-150"><a href="#cb1-150"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>applyFixedSpreadToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-151"><a href="#cb1-151"></a>    <span class="co">//Leg(AssetSwap::*)()</span></span>
<span id="cb1-152"><a href="#cb1-152"></a></span>
<span id="cb1-153"><a href="#cb1-153"></a>    process09<span class="op">(</span>ptrmemfunc1<span class="op">);</span>     <span class="co">// T(C::*)()</span></span>
<span id="cb1-154"><a href="#cb1-154"></a>    process09<span class="op">(</span>ptrmemfunc2<span class="op">);</span>     <span class="co">// T(C::*)(U)</span></span>
<span id="cb1-155"><a href="#cb1-155"></a>    process09<span class="op">(</span>ptrmemfunc3<span class="op">);</span>     <span class="co">// T(U::*)()</span></span>
<span id="cb1-156"><a href="#cb1-156"></a>    process09<span class="op">(</span>getLegPv<span class="op">);</span>        <span class="co">// T(U::*)(V)</span></span>
<span id="cb1-157"><a href="#cb1-157"></a>    process09<span class="op">(</span>ptrmemfunc4<span class="op">);</span>     <span class="co">// C(T::*)()</span></span>
<span id="cb1-158"><a href="#cb1-158"></a>    process09<span class="op">(</span>applyScaleToAllCoupons<span class="op">);</span>          <span class="co">//C(T::*)(U)</span></span>
<span id="cb1-159"><a href="#cb1-159"></a>    process09<span class="op">(</span>applyFixedSpreadToAllCoupons<span class="op">);</span>    <span class="co">//D(C::*)(T)</span></span>
<span id="cb1-160"><a href="#cb1-160"></a></span>
<span id="cb1-161"><a href="#cb1-161"></a>    process10<span class="op">(&amp;</span>CustomBond<span class="op">::</span>cashflows<span class="op">);</span></span>
<span id="cb1-162"><a href="#cb1-162"></a>    process10<span class="op">(&amp;</span>AssetSwap<span class="op">::</span>bondLeg<span class="op">);</span></span>
<span id="cb1-163"><a href="#cb1-163"></a>    process10<span class="op">(&amp;</span>Leg<span class="op">::</span>flows<span class="op">);</span></span>
<span id="cb1-164"><a href="#cb1-164"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-165"><a href="#cb1-165"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/6zsxEchcv">Compiler Explorer</a></p>
</section>
<section id="ctad-class-template-argument-deduction." class="level2">
<h2 class="anchored" data-anchor-id="ctad-class-template-argument-deduction.">CTAD (Class Template Argument Deduction).</h2>
<section id="the-basic-mechanics." class="level3">
<h3 class="anchored" data-anchor-id="the-basic-mechanics.">The basic mechanics.</h3>
<p>CTAD(Class Template Argument Deduction) has <span class="math inline">\(2\)</span> phases:</p>
<ol type="1">
<li><p>Deduction (CTAD) - The first step is, the compiler is going to deduce the types that you didnâ€™t write.</p></li>
<li><p>Initialization - The second step is, itâ€™s going to initialize the object.</p></li>
</ol>
<p>Letâ€™s take a templated class <code>pair</code>, this is just a fictional class, it is not actually how <code>std::pair&lt;&gt;</code> looks like:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb2" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">struct</span> pair<span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    T first<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    U second<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a>    pair<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> _first<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> _second<span class="op">)</span> </span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="op">:</span> first<span class="op">(</span>_first<span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="op">,</span> second<span class="op">(</span>_second<span class="op">)</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="op">{}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>    pair<span class="op">(</span>T<span class="op">&amp;&amp;</span> _first<span class="op">,</span> U<span class="op">&amp;&amp;</span> _second<span class="op">)</span> </span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="op">:</span> first<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>T<span class="op">&gt;(</span>_first<span class="op">))</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="op">,</span> second<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>U<span class="op">&gt;(</span>_second<span class="op">))</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    <span class="op">{}</span></span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="co">//other stuff</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is an oversimplification that is enough for our purposes. So, you have a templated class with two template parameters <code>T</code> and <code>U</code> and then you have a bunch of constructors. Now, we want to instantiate one of these things:</p>
<div class="sourceCode" id="cb3" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>pair p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You want to construct an object of type <code>pair</code>. The next thing the compiler sees is, <code>pair</code> is a template. And we didnâ€™t specify any template arguments. Probably, you <em>wanna</em> do class template argument deduction.</p>
<p>The next thing happens. <code>pair</code> has a bunch of constructors. Probably, you <em>wanna</em> call one of those constructors. And this where step 1 kicks in, which is the actual <em>Class Template Argument Deduction</em>(CTAD).</p>
<p>So, how does the compiler figure out, what you actually want to instantiate? So, itâ€™s going to look at those constructors. Letâ€™s pretend for a minute, that those constructors are ordinary functions - just free-standing functions. Now, these functions use class template parameters. Letâ€™s pretend for a moment, that those template parameters are template parameters for the function.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb4" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">struct</span> pair<span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    T first<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    U second<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">// Imagine this to be a function template</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span>  </span>
<span id="cb4-8"><a href="#cb4-8"></a>    pair<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> _first<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> _second<span class="op">)</span> </span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="op">:</span> first<span class="op">(</span>_first<span class="op">)</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="op">,</span> second<span class="op">(</span>_second<span class="op">)</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="op">{}</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="co">// Imagine this to be a function template</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    pair<span class="op">(</span>T<span class="op">&amp;&amp;</span> _first<span class="op">,</span> U<span class="op">&amp;&amp;</span> _second<span class="op">)</span> </span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="op">:</span> first<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>T<span class="op">&gt;(</span>_first<span class="op">))</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="op">,</span> second<span class="op">(</span><span class="bu">std::</span>move<span class="op">&lt;</span>U<span class="op">&gt;(</span>_second<span class="op">))</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="op">{}</span></span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="co">//other stuff</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, this code doesnâ€™t exist. Itâ€™s just what the compiler temporarily does for you. And it generates these template functions from the constructors and they are called the <em>deduction candidates</em>.</p>
<p>And now, if we have a call like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb5" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>pair p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>we know, how to deal with functions right. So, itâ€™s going to look at these functions and apply the usual template arguments deduction and the usual overload resolution.</p>
<p><code>"OptionVolQuote"s</code> is a <em>lvalue</em> that gets converted to an <em>xvalue</em> (by the <code>std::string()</code> constructor) and <code>0.50</code> is a <em>prvalue</em>. these arguments bind to universal references. So, the <code>pair(T&amp;&amp;, U&amp;&amp;)</code> version is chosen by the compiler from the overload set, during overload resolution. Further, <code>T</code> is deduced as <code>std::string</code> and <code>U</code> is deduced as <code>double</code>. The compiler literally inserts them as:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb6" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>pair<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span><span class="dt">double</span><span class="op">&gt;</span> p1<span class="op">{</span><span class="st">"OptionVolQuote"</span><span class="bu">s</span><span class="op">,</span> <span class="fl">0.50</span><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, its going to do, what it would have done, if you would have written <code>pair&lt;std::string,double&gt;</code>. So, now we know, that this <code>pair</code> is actually <code>pair&lt;std::string,int&gt;</code>. So, the step 1 is done.</p>
<p>Now, what we can do is, we can actually instantiate the function template! Thatâ€™s step 2. So, you have an actual constructor and it will be called by the run-time to create an object of <code>pair&lt;std::string,int&gt;</code>. And we are done.</p>
<p>If we write:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb7" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="at">const</span> <span class="kw">auto</span> s<span class="op">{</span><span class="st">"5YSwapRate"</span><span class="bu">s</span><span class="op">};</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="at">const</span> <span class="kw">auto</span> rate<span class="op">{</span><span class="fl">0.0125</span><span class="op">};</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>pair p2<span class="op">{</span>s<span class="op">,</span>rate<span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, <code>s</code> and <code>rate</code> are identifiers, so these are <em>glvalues</em> and can bind to <code>const T&amp;</code>. So, the compiler instantiates the first overload of the constructor as <code>pair(const std::string&amp;, const double&amp;)</code>.</p>
<p>Thereâ€™s no need to use <code>std::make_pair</code> anymore. This <code>make_pair</code> thing is a basically a work-around for the fact that up until C++14, you could only do this with functions. So, you had to use a function to deduce the class template arguments. So, it was kind of hacky. And now we donâ€™t need to use that anymore.</p>
<p>The same goes for <code>std::tuple</code>, you can instantiate a <code>std::tuple</code> with a bunch of arguments and itâ€™s going to deduce the correct types for you, so you donâ€™t need to use <code>std::make_tuple</code> anymore.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb8" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="bu">std::</span>tuple point<span class="op">{</span><span class="fl">1.00</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.00</span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Letâ€™s look at <code>std::vector</code>. So, for example, if you just give it an <code>std::initializer_list</code> of <code>int</code>s, its gonna correctly deduce back to <code>std::vector&lt;int&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb9" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="bu">std::</span>vector v<span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">13</span><span class="op">};</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Of course, with <code>std::vector</code>, thereâ€™s a trap. <code>std::vector</code> has this other constructor which takes a <code>std::size_t</code>, and it initializes a vector with that many elements in it.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb10" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v1<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">// content is {3}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">// content is {0,0,0}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So, in C++14, if you write <code>std::vector&lt;int&gt; v{3}</code> with curly braces, itâ€™s going to be an initializer list, so its going to initialize the vector with one <code>int</code>, which is <code>3</code>. If you <code>std::vector&lt;int&gt; v(3)</code> with parenthesis, itâ€™s going to call the <code>size_t</code> constructor, and youâ€™re gonna have 3 <code>int</code>s, which are initialized to <code>0.0</code>.</p>
<p>Now, what happens if you omit the <code>int</code> and use class-template argument deduction? Then if you write the curlies, its going to do the deduction. But if you use round parenthesis, it says, well youâ€™re calling the constructor that takes a <code>size_t</code>, so you are going to have 3 elements, but 3 elements of what type? You didnâ€™t specify! So, you get a compiler error.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb11" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="bu">std::</span>vector v1<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">// Ok- deduces std::vector&lt;int&gt;, content is {3}</span></span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">// std::vector v2(3);</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">// Error : 3 elements of what?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>std::vector</code> has another constructor, which is really cool! Now, some real magic happens here! So, if you have a range of <code>int</code>s, any range, then thereâ€™s this constructor that takes a pair of iterators like <code>begin()</code> and <code>end()</code> and if you donâ€™t specify the <code>int</code>, it is still going to figure out, that those iterators are iterators to <code>int</code> range and it is going correctly deduce <code>std::vector&lt;int&gt;</code> for you.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb12" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="bu">std::</span>vector v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>How does that work? It has this constructor which looks like the below. It takes two iterators.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb13" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">struct</span> vector</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If you have a constructor that also has template arguments, the compiler is going to pretend that this is a function and itâ€™s going to take the template argument of the class and concatenate it with the constructorâ€™s template argument. Itâ€™s going to put them one after the other.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb14" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">// This is magic code, generated by the compiler</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">struct</span> vector</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="co">// range c'tor</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="co">// other stuff</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, if you call it like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb15" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="bu">std::</span>vector v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>itâ€™s going to say, well okay, you are giving me two iterators, so I can deduce the type of iterators as <code>std::vector&lt;&gt;::iterator</code>. But, you didnâ€™t specify <code>T</code>, so I still donâ€™t know what <code>T</code> is. So, how is it able to figure this out?</p>
</section>
</section>
<section id="deduction-guides." class="level1">
<h1>Deduction Guides.</h1>
<p>This is another feature called deduction guides. When the compiler canâ€™t figure out, with this machinery, what the type is, but it is kind of obvious to you, what the type should be, you can write a deduction guide.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb16" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">struct</span> vector</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="op">};</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">// deduction guide:</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>vector<span class="op">(</span>Iter begin<span class="op">,</span> Iter end<span class="op">)</span> </span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="op">-&gt;</span> vector<span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">::</span>iterator_traits<span class="op">&lt;</span>Iter<span class="op">&gt;::</span><span class="dt">value_type</span><span class="op">&gt;;</span></span>
<span id="cb16-15"><a href="#cb16-15"></a></span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="bu">std::</span>vector v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It starts with something that looks like a constructor signature, and then you have this arrow <code>-&gt;</code> and after the arrow, you put like a specialization of the same class. So, you are gonna say, well, if you have this constructor signature (which will be added to the deduction candidates), and if this is the one that is going to be selected by the compiler, then deduce the type after the arrow (<code>-&gt;</code>). So, this is like a new entity in C++17. Itâ€™s not a class, itâ€™s not a function, itâ€™s a <em>deduction guide</em>.</p>
<p>With that deduction guide, basically youâ€™re saying, well, if I get two iterators, then take the iterator traits, figure out the value type which this iterator points to and initialize the vector with that type. And that works and compiles.</p>
<p>So, this compiles, but actually the order matters. Deductions guides are only considered for the code that is below the deduction guide.</p>
<p>So, if you flip around the order:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb17" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">struct</span> vector</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="co">// range c'tor</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    vector<span class="op">&lt;</span>Iter begin<span class="op">,</span> Iter end<span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="co">// other stuff</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="op">};</span></span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="co">//std::vector v(range.begin(), range.end());</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co">// Error: deduction failed</span></span>
<span id="cb17-14"><a href="#cb17-14"></a></span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="co">// deduction guide:</span></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">&gt;</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>vector<span class="op">(</span>Iter begin<span class="op">,</span> Iter end<span class="op">)</span> </span>
<span id="cb17-18"><a href="#cb17-18"></a>    <span class="op">-&gt;</span> vector<span class="op">&lt;</span><span class="kw">typename</span> Iter<span class="op">::</span>iterator_traits<span class="op">&lt;</span>Iter<span class="op">&gt;::</span><span class="dt">value_type</span><span class="op">&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>then itâ€™s not going to work anymore.</p>
<p>One thing thatâ€™s really a good recommendation, is that these deduction guides are really part of the class interface. Because they tell you, you can instantiate this class template like this, so <em>deduction guides should be defined immediately after the class definition</em>.</p>
<section id="list-initialization-has-priority" class="level2">
<h2 class="anchored" data-anchor-id="list-initialization-has-priority">List initialization has priority</h2>
<p>You really have to be careful with the parenthesis and the curlies.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb18" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="bu">std::</span>vector v<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co">// deduces std::vector&lt;int&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="bu">std::</span>vector v<span class="op">{</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">()};</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">// list initialization has a priority, so the compiler deduces it</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">// as std::vector&lt;std::vector&lt;int&gt;::iterator&gt;, which is </span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">// probably not what we want</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="sequence-containers" class="level1">
<h1>Sequence Containers</h1>
<p>CTAD works the same with all the other sequence containers.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb19" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;list&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#include </span><span class="im">&lt;deque&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="bu">std::</span>list l<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="co">//deduces std::list&lt;int&gt;</span></span>
<span id="cb19-12"><a href="#cb19-12"></a></span>
<span id="cb19-13"><a href="#cb19-13"></a>    <span class="bu">std::</span>forward_list fl<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-14"><a href="#cb19-14"></a>    <span class="co">//deduces std::forward_list&lt;int&gt;</span></span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a>    <span class="bu">std::</span>deque d<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>    <span class="co">//deduces std::deque&lt;int&gt;</span></span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a>    <span class="bu">std::</span>array a<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>    <span class="co">//deduces std::array&lt;int,5&gt;</span></span>
<span id="cb19-21"><a href="#cb19-21"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="https://godbolt.org/z/d74a8c4f5">Compiler Explorer</a></p>
<p>With <code>std::array&lt;T,N&gt;</code> it also deduces the size for you. We are going to see later, how that works. They also have these range constructors except for <code>std::array&lt;T,N&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb20" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="bu">std::</span>vector range<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="bu">std::</span>list l<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">// deduces std::list&lt;int&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="bu">std::</span>forward_list fl<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">// deduces std::foward_list&lt;int&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="bu">std::</span>deque d<span class="op">(</span>range<span class="op">.</span>begin<span class="op">(),</span> range<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">// deduces std::deque&lt;int&gt;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="co">// also, the same pitfall - don't use curly braces</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, there is <code>std::set</code>. <code>std::set</code> also has both of these constructors. But, <code>std::set</code> also has more stuff. You know, <code>std::set</code> has this external template parameter which is the comparison function, so you can specify your own comparator lambda. And thatâ€™s a template argument. But, the cool thing is, <code>std::set</code> also has a constructor, that takes this comparator as a template argument and it can deduce that as well. So, we can actually write something like this:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb21" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="bu">std::</span>set s<span class="op">({</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">11</span><span class="op">},</span> <span class="op">[](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span><span class="cf">return</span> a <span class="op">&gt;</span> b<span class="op">;});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notice that you donâ€™t have to pass the type of the lambda <code>bool (int,int)</code>, the compiler will automatically deduce it for you.</p>
</section>
<section id="locks-and-mutexes." class="level1">
<h1>Locks and Mutexes.</h1>
<p>One of the most popular use-cases for CTAD is mutexes. When you have long type names like <code>std::shared_timed_mutex mtx</code> and then if you had to lock it, you had to specify this thing: <code>std::lock_guard&lt;std::shared_timed_mutex&gt; lock(mtx)</code>. With C++17, you donâ€™t have to do that anymore:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb22" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">std::</span>shared_timed_mutex mtx<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="bu">std::</span>lock_guard lock<span class="op">(</span>mtx<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">// deduced as std::lock_guard&lt;std::shared_timed_mutex&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="smart-pointers." class="level1">
<h1>Smart Pointers.</h1>
<p>This is one of the prime examples, where class template argument deduction can be dangerous and damaging. Letâ€™s say you have a <code>struct Citizen</code> with some constructor. And, then you want to create a <code>Citizen</code> instance dynamically on the heap. You would maybe expect to write:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb23" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">struct</span> Citizen<span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="co">//c'tor</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    Citizen<span class="op">(</span><span class="bu">std::</span>string prefix<span class="op">,</span> <span class="dt">int</span> serial_number<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">};</span></span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="co">// std::shared_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co">// Error! No CTAD</span></span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">auto</span> sptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>Citizen<span class="op">&gt;(</span><span class="st">"THX"</span><span class="op">,</span><span class="dv">1138</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You give it a pointer to this dynamically allocated <code>Citizen</code> object, and then you think itâ€™s going to work. But, that fails and for good reason! Itâ€™s specifically disabled. So, youâ€™re back to using <code>make_shared&lt;T&gt;</code> again. The same with <code>std::unique_ptr&lt;T&gt;</code>.</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb24" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">// std::unique_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="co">// Error! No CTAD</span></span>
<span id="cb24-3"><a href="#cb24-3"></a></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">auto</span> uptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Citizen<span class="op">&gt;(</span><span class="st">"THX"</span><span class="op">,</span><span class="dv">1138</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Itâ€™s not going to the deduce the type <code>T</code>; you have to use <code>make_unique&lt;T&gt;</code>.</p>
<p>Thereâ€™s good reasons for this. First of all, <code>make_shared&lt;T&gt;</code> has exception safety built in. If for some reason, the constructor fails and <code>throw</code>s, then you are not going to leak memory.</p>
<p>Secondly, if you have an array, and you pass it to a constructor, it decays into a pointer. If you had class-template argument deduction smart-pointers, you could write like that:</p>
<div class="tcolorbox">
<div class="sourceCode" id="cb25" data-breaklines=""><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">// std::unique_ptr uptr(new int[10]);</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="co">// if that would compile, uh-oh!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A pointer to an array would decay to a pointer to an <code>int</code> for you. When the pointer goes out of scope, the destructor of <code>std::shared_ptr</code> calls <code>delete</code> on <code>sptr</code> and not <code>delete[]</code>.</p>
<p>This is definitely a bug! We donâ€™t want people to be able to use CTAD here.</p>
<p>We would like to disable CTAD. Now, the question is how do we disable it? How do we make sure that it doesnâ€™t work.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark"><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb26" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb26-1"><a href="#cb26-1"></a><span class="co">---</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="an">title:</span><span class="co"> "Class Template Argument Deduction(CTAD)"</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="an">author:</span><span class="co"> "Quasar"</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="an">date:</span><span class="co"> "2024-11-25"</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="an">categories:</span><span class="co"> [C++]      </span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="an">image:</span><span class="co"> "cpp.jpg"</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="an">toc-depth:</span><span class="co"> 3</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="an">format:</span></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="co">    html:</span></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="co">        code-tools: true</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="co">        code-block-border-left: true</span></span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="co">        code-annotations: below</span></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">        highlight-style: pygments</span></span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="co">---</span></span>
<span id="cb26-16"><a href="#cb26-16"></a></span>
<span id="cb26-17"><a href="#cb26-17"></a><span class="fu">## Function Template Argument Deduction.</span></span>
<span id="cb26-18"><a href="#cb26-18"></a></span>
<span id="cb26-19"><a href="#cb26-19"></a>Its super-helpful to have a good low-level hang of the template argument deduction rules (more on deduction guides in another post). Essentially, since C++17, you can just declare, <span class="in">`std::vector{1.0, 2.0, 3.0, 4.0, 5.0}`</span> - clean and nice instead of <span class="in">`std::vector&lt;double&gt;{1.0, 2.0, 3.0, 4.0, 5.0}`</span>.</span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a>When the compiler tries to deduce the template arguments, it performs matching of the type template parameters with the types of arguments used to invoke the function. </span>
<span id="cb26-22"><a href="#cb26-22"></a></span>
<span id="cb26-23"><a href="#cb26-23"></a>Very succinctly, the compiler can match:</span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="ss">- </span>Types of the form <span class="in">`T`</span>, <span class="in">`T const`</span>, <span class="in">`T volatile`</span></span>
<span id="cb26-25"><a href="#cb26-25"></a><span class="ss">- </span>Pointers <span class="in">`T*`</span>, lvalue references <span class="in">`T&amp;`</span> and universal references <span class="in">`T&amp;&amp;`</span></span>
<span id="cb26-26"><a href="#cb26-26"></a><span class="ss">- </span>Arrays such as <span class="in">`T[5]`</span> and <span class="in">`C[5][n]`</span></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="ss">- </span>Pointers to functions </span>
<span id="cb26-28"><a href="#cb26-28"></a><span class="ss">- </span>Pointers to member-functions and data-members.</span>
<span id="cb26-29"><a href="#cb26-29"></a></span>
<span id="cb26-30"><a href="#cb26-30"></a><span class="in">```cpp</span></span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb26-32"><a href="#cb26-32"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb26-33"><a href="#cb26-33"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb26-34"><a href="#cb26-34"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb26-35"><a href="#cb26-35"></a></span>
<span id="cb26-36"><a href="#cb26-36"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono<span class="op">;</span></span>
<span id="cb26-37"><a href="#cb26-37"></a></span>
<span id="cb26-38"><a href="#cb26-38"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-39"><a href="#cb26-39"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> out<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> vec<span class="op">){</span></span>
<span id="cb26-40"><a href="#cb26-40"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span> i <span class="op">&lt;</span> vec<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span> i<span class="op">){</span></span>
<span id="cb26-41"><a href="#cb26-41"></a>        out <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">["</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">"] = "</span> <span class="op">&lt;&lt;</span> vec<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb26-42"><a href="#cb26-42"></a>    <span class="op">}</span></span>
<span id="cb26-43"><a href="#cb26-43"></a>    <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb26-44"><a href="#cb26-44"></a><span class="op">}</span></span>
<span id="cb26-45"><a href="#cb26-45"></a></span>
<span id="cb26-46"><a href="#cb26-46"></a><span class="kw">struct</span> BondDiscountingCurve<span class="op">{</span></span>
<span id="cb26-47"><a href="#cb26-47"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>year_month_day<span class="op">,</span><span class="dt">double</span><span class="op">&gt;&gt;</span> discountFactorCurve<span class="op">;</span></span>
<span id="cb26-48"><a href="#cb26-48"></a><span class="op">};</span></span>
<span id="cb26-49"><a href="#cb26-49"></a></span>
<span id="cb26-50"><a href="#cb26-50"></a><span class="kw">struct</span> CustomBond<span class="op">{</span></span>
<span id="cb26-51"><a href="#cb26-51"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> cashflows<span class="op">;</span></span>
<span id="cb26-52"><a href="#cb26-52"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>chrono::year_month_day<span class="op">&gt;</span> cashflow_dates<span class="op">;</span></span>
<span id="cb26-53"><a href="#cb26-53"></a></span>
<span id="cb26-54"><a href="#cb26-54"></a>    <span class="dt">double</span> pv<span class="op">(</span>BondDiscountingCurve disc<span class="op">){</span></span>
<span id="cb26-55"><a href="#cb26-55"></a>        <span class="dt">double</span> result<span class="op">{</span><span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb26-56"><a href="#cb26-56"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span>i <span class="op">&lt;</span> cashflows<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb26-57"><a href="#cb26-57"></a>        <span class="op">{</span></span>
<span id="cb26-58"><a href="#cb26-58"></a>            <span class="dt">double</span> df <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>disc<span class="op">.</span>discountFactorCurve<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb26-59"><a href="#cb26-59"></a>            result <span class="op">+=</span> cashflows<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> df<span class="op">;</span></span>
<span id="cb26-60"><a href="#cb26-60"></a>        <span class="op">}</span></span>
<span id="cb26-61"><a href="#cb26-61"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb26-62"><a href="#cb26-62"></a>    <span class="op">}</span></span>
<span id="cb26-63"><a href="#cb26-63"></a><span class="op">};</span></span>
<span id="cb26-64"><a href="#cb26-64"></a></span>
<span id="cb26-65"><a href="#cb26-65"></a><span class="kw">struct</span> Leg<span class="op">{</span></span>
<span id="cb26-66"><a href="#cb26-66"></a>    <span class="co">// A cashflow is a 4-tuple (Cashflow date, Cashflow amount, Cap, Floor)</span></span>
<span id="cb26-67"><a href="#cb26-67"></a>    <span class="kw">using</span> flow <span class="op">=</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>year_month_day<span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;;</span></span>
<span id="cb26-68"><a href="#cb26-68"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>flow<span class="op">&gt;</span> flows<span class="op">;</span></span>
<span id="cb26-69"><a href="#cb26-69"></a><span class="op">};</span></span>
<span id="cb26-70"><a href="#cb26-70"></a></span>
<span id="cb26-71"><a href="#cb26-71"></a><span class="kw">struct</span> AssetSwap<span class="op">{</span></span>
<span id="cb26-72"><a href="#cb26-72"></a>    Leg bondLeg<span class="op">;</span></span>
<span id="cb26-73"><a href="#cb26-73"></a>    Leg fundingLeg<span class="op">;</span></span>
<span id="cb26-74"><a href="#cb26-74"></a></span>
<span id="cb26-75"><a href="#cb26-75"></a>    Leg getBondLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> bondLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-76"><a href="#cb26-76"></a>    Leg getFundingLeg<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> fundingLeg<span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-77"><a href="#cb26-77"></a><span class="op">};</span></span>
<span id="cb26-78"><a href="#cb26-78"></a></span>
<span id="cb26-79"><a href="#cb26-79"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-80"><a href="#cb26-80"></a><span class="dt">void</span> process01<span class="op">(</span>T bond<span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-81"><a href="#cb26-81"></a></span>
<span id="cb26-82"><a href="#cb26-82"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-83"><a href="#cb26-83"></a><span class="dt">void</span> process02<span class="op">(</span>T <span class="at">const</span><span class="op">){</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T const</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-84"><a href="#cb26-84"></a></span>
<span id="cb26-85"><a href="#cb26-85"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-86"><a href="#cb26-86"></a><span class="dt">void</span> process03<span class="op">(</span>T <span class="at">volatile</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T volatile</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-87"><a href="#cb26-87"></a></span>
<span id="cb26-88"><a href="#cb26-88"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-89"><a href="#cb26-89"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-90"><a href="#cb26-90"></a></span>
<span id="cb26-91"><a href="#cb26-91"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-92"><a href="#cb26-92"></a><span class="dt">void</span> process04<span class="op">(</span>T<span class="op">&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-93"><a href="#cb26-93"></a></span>
<span id="cb26-94"><a href="#cb26-94"></a><span class="co">// Universal reference</span></span>
<span id="cb26-95"><a href="#cb26-95"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-96"><a href="#cb26-96"></a><span class="dt">void</span> process05<span class="op">(</span>T<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T&amp;&amp;</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-97"><a href="#cb26-97"></a></span>
<span id="cb26-98"><a href="#cb26-98"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-99"><a href="#cb26-99"></a><span class="dt">void</span> process06<span class="op">(</span>T<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T[5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-100"><a href="#cb26-100"></a></span>
<span id="cb26-101"><a href="#cb26-101"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-102"><a href="#cb26-102"></a><span class="dt">void</span> process07<span class="op">(</span>T<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">])</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T[3][5]</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-103"><a href="#cb26-103"></a></span>
<span id="cb26-104"><a href="#cb26-104"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-105"><a href="#cb26-105"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-106"><a href="#cb26-106"></a></span>
<span id="cb26-107"><a href="#cb26-107"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-108"><a href="#cb26-108"></a><span class="dt">void</span> process08<span class="op">(</span>CustomBond <span class="op">(*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-109"><a href="#cb26-109"></a></span>
<span id="cb26-110"><a href="#cb26-110"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb26-111"><a href="#cb26-111"></a><span class="dt">void</span> process08<span class="op">(</span>T<span class="op">(*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-112"><a href="#cb26-112"></a></span>
<span id="cb26-113"><a href="#cb26-113"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-114"><a href="#cb26-114"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (C::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-115"><a href="#cb26-115"></a></span>
<span id="cb26-116"><a href="#cb26-116"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb26-117"><a href="#cb26-117"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>CustomBond<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (C::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-118"><a href="#cb26-118"></a></span>
<span id="cb26-119"><a href="#cb26-119"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb26-120"><a href="#cb26-120"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (U::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-121"><a href="#cb26-121"></a></span>
<span id="cb26-122"><a href="#cb26-122"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb26-123"><a href="#cb26-123"></a><span class="dt">void</span> process09<span class="op">(</span>T<span class="op">(</span>U<span class="op">::*)(</span>V<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T (U::*)(V)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-124"><a href="#cb26-124"></a></span>
<span id="cb26-125"><a href="#cb26-125"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-126"><a href="#cb26-126"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)())</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (T::*)()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-127"><a href="#cb26-127"></a></span>
<span id="cb26-128"><a href="#cb26-128"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb26-129"><a href="#cb26-129"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>T<span class="op">::*)(</span>U<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C (T::*)(U)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-130"><a href="#cb26-130"></a></span>
<span id="cb26-131"><a href="#cb26-131"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-132"><a href="#cb26-132"></a><span class="dt">void</span> process09<span class="op">(</span>Leg<span class="op">(</span>AssetSwap<span class="op">::*)(</span>T<span class="op">))</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"D (C::*)(T)</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-133"><a href="#cb26-133"></a></span>
<span id="cb26-134"><a href="#cb26-134"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-135"><a href="#cb26-135"></a><span class="dt">void</span> process10<span class="op">(</span>T CustomBond<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T C::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-136"><a href="#cb26-136"></a></span>
<span id="cb26-137"><a href="#cb26-137"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-138"><a href="#cb26-138"></a><span class="dt">void</span> process10<span class="op">(</span>Leg T<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"C T::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-139"><a href="#cb26-139"></a></span>
<span id="cb26-140"><a href="#cb26-140"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb26-141"><a href="#cb26-141"></a><span class="dt">void</span> process10<span class="op">(</span>T U<span class="op">::*)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"T U::*</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-142"><a href="#cb26-142"></a></span>
<span id="cb26-143"><a href="#cb26-143"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb26-144"><a href="#cb26-144"></a><span class="op">{</span></span>
<span id="cb26-145"><a href="#cb26-145"></a>    CustomBond bond<span class="op">(</span></span>
<span id="cb26-146"><a href="#cb26-146"></a>        <span class="op">{</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">1.05</span><span class="op">},</span></span>
<span id="cb26-147"><a href="#cb26-147"></a>        <span class="op">{</span><span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2024</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>June<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">,</span> <span class="dv">2025</span><span class="bu">y</span><span class="op">/</span>December<span class="op">/</span><span class="dv">20</span><span class="bu">d</span><span class="op">}</span></span>
<span id="cb26-148"><a href="#cb26-148"></a>    <span class="op">);</span></span>
<span id="cb26-149"><a href="#cb26-149"></a></span>
<span id="cb26-150"><a href="#cb26-150"></a>    AssetSwap assetSwap<span class="op">;</span></span>
<span id="cb26-151"><a href="#cb26-151"></a></span>
<span id="cb26-152"><a href="#cb26-152"></a>    process01<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T</span></span>
<span id="cb26-153"><a href="#cb26-153"></a>    process02<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T const</span></span>
<span id="cb26-154"><a href="#cb26-154"></a>    process03<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T volatile</span></span>
<span id="cb26-155"><a href="#cb26-155"></a>    process04<span class="op">(&amp;</span>bond<span class="op">);</span>   <span class="co">// T*</span></span>
<span id="cb26-156"><a href="#cb26-156"></a>    process04<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;</span></span>
<span id="cb26-157"><a href="#cb26-157"></a>    process05<span class="op">(</span>bond<span class="op">);</span>    <span class="co">// T&amp;&amp;; deduced as CustomBond&amp; </span></span>
<span id="cb26-158"><a href="#cb26-158"></a></span>
<span id="cb26-159"><a href="#cb26-159"></a>    CustomBond bondsArray<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span>  <span class="co">//Create an array of custom bonds</span></span>
<span id="cb26-160"><a href="#cb26-160"></a>    process06<span class="op">(</span>bondsArray<span class="op">);</span>  <span class="co">// T[5]</span></span>
<span id="cb26-161"><a href="#cb26-161"></a>    process06<span class="op">(&amp;</span>bond<span class="op">);</span>       <span class="co">// T[5]</span></span>
<span id="cb26-162"><a href="#cb26-162"></a></span>
<span id="cb26-163"><a href="#cb26-163"></a>    CustomBond bondsByMaturityAndRating<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">5</span><span class="op">]</span> <span class="op">{};</span> </span>
<span id="cb26-164"><a href="#cb26-164"></a>    process07<span class="op">(</span>bondsByMaturityAndRating<span class="op">);</span>    <span class="co">//C[5][n]</span></span>
<span id="cb26-165"><a href="#cb26-165"></a></span>
<span id="cb26-166"><a href="#cb26-166"></a>    CustomBond <span class="op">(*</span>funcptr1<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-167"><a href="#cb26-167"></a>    CustomBond <span class="op">(*</span>funcptr2<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-168"><a href="#cb26-168"></a>    <span class="dt">double</span>     <span class="op">(*</span>funcptr3<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-169"><a href="#cb26-169"></a></span>
<span id="cb26-170"><a href="#cb26-170"></a>    process08<span class="op">(</span>funcptr1<span class="op">);</span>    <span class="co">//T(*)()</span></span>
<span id="cb26-171"><a href="#cb26-171"></a>    process08<span class="op">(</span>funcptr2<span class="op">);</span>    <span class="co">//C(*)(T)</span></span>
<span id="cb26-172"><a href="#cb26-172"></a>    process08<span class="op">(</span>funcptr3<span class="op">);</span>    <span class="co">//T(*)(U)</span></span>
<span id="cb26-173"><a href="#cb26-173"></a></span>
<span id="cb26-174"><a href="#cb26-174"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc1<span class="op">)</span> <span class="op">()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-175"><a href="#cb26-175"></a>    <span class="dt">double</span> <span class="op">(</span>CustomBond<span class="op">::*</span>ptrmemfunc2<span class="op">)(</span>BondDiscountingCurve<span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>CustomBond<span class="op">::</span>pv<span class="op">;</span></span>
<span id="cb26-176"><a href="#cb26-176"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">(</span>Leg<span class="op">::*</span>ptrmemfunc3<span class="op">)()</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-177"><a href="#cb26-177"></a>    <span class="dt">double</span><span class="op">(</span>AssetSwap<span class="op">::*</span>getLegPv<span class="op">)(</span>Leg<span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-178"><a href="#cb26-178"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>ptrmemfunc4<span class="op">)()</span> <span class="op">=</span> <span class="op">&amp;</span>AssetSwap<span class="op">::</span>getFundingLeg<span class="op">;</span></span>
<span id="cb26-179"><a href="#cb26-179"></a>    Leg<span class="op">(</span>Leg<span class="op">::*</span>applyScaleToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-180"><a href="#cb26-180"></a>    Leg<span class="op">(</span>AssetSwap<span class="op">::*</span>applyFixedSpreadToAllCoupons<span class="op">)(</span><span class="dt">double</span><span class="op">)</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-181"><a href="#cb26-181"></a>    <span class="co">//Leg(AssetSwap::*)()</span></span>
<span id="cb26-182"><a href="#cb26-182"></a></span>
<span id="cb26-183"><a href="#cb26-183"></a>    process09<span class="op">(</span>ptrmemfunc1<span class="op">);</span>     <span class="co">// T(C::*)()</span></span>
<span id="cb26-184"><a href="#cb26-184"></a>    process09<span class="op">(</span>ptrmemfunc2<span class="op">);</span>     <span class="co">// T(C::*)(U)</span></span>
<span id="cb26-185"><a href="#cb26-185"></a>    process09<span class="op">(</span>ptrmemfunc3<span class="op">);</span>     <span class="co">// T(U::*)()</span></span>
<span id="cb26-186"><a href="#cb26-186"></a>    process09<span class="op">(</span>getLegPv<span class="op">);</span>        <span class="co">// T(U::*)(V)</span></span>
<span id="cb26-187"><a href="#cb26-187"></a>    process09<span class="op">(</span>ptrmemfunc4<span class="op">);</span>     <span class="co">// C(T::*)()</span></span>
<span id="cb26-188"><a href="#cb26-188"></a>    process09<span class="op">(</span>applyScaleToAllCoupons<span class="op">);</span>          <span class="co">//C(T::*)(U)</span></span>
<span id="cb26-189"><a href="#cb26-189"></a>    process09<span class="op">(</span>applyFixedSpreadToAllCoupons<span class="op">);</span>    <span class="co">//D(C::*)(T)</span></span>
<span id="cb26-190"><a href="#cb26-190"></a></span>
<span id="cb26-191"><a href="#cb26-191"></a>    process10<span class="op">(&amp;</span>CustomBond<span class="op">::</span>cashflows<span class="op">);</span></span>
<span id="cb26-192"><a href="#cb26-192"></a>    process10<span class="op">(&amp;</span>AssetSwap<span class="op">::</span>bondLeg<span class="op">);</span></span>
<span id="cb26-193"><a href="#cb26-193"></a>    process10<span class="op">(&amp;</span>Leg<span class="op">::</span>flows<span class="op">);</span></span>
<span id="cb26-194"><a href="#cb26-194"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-195"><a href="#cb26-195"></a><span class="op">}</span></span>
<span id="cb26-196"><a href="#cb26-196"></a><span class="in">```</span></span>
<span id="cb26-197"><a href="#cb26-197"></a></span>
<span id="cb26-198"><a href="#cb26-198"></a><span class="co">[</span><span class="ot">Compiler Explorer</span><span class="co">](https://godbolt.org/z/6zsxEchcv)</span></span>
<span id="cb26-199"><a href="#cb26-199"></a></span>
<span id="cb26-200"><a href="#cb26-200"></a></span>
<span id="cb26-201"><a href="#cb26-201"></a><span class="fu">## CTAD (Class Template Argument Deduction).</span></span>
<span id="cb26-202"><a href="#cb26-202"></a></span>
<span id="cb26-203"><a href="#cb26-203"></a><span class="fu">### The basic mechanics.</span></span>
<span id="cb26-204"><a href="#cb26-204"></a></span>
<span id="cb26-205"><a href="#cb26-205"></a>CTAD(Class Template Argument Deduction) has $2$ phases:</span>
<span id="cb26-206"><a href="#cb26-206"></a></span>
<span id="cb26-207"><a href="#cb26-207"></a><span class="ss">1.  </span>Deduction (CTAD) - The first step is, the compiler is going to</span>
<span id="cb26-208"><a href="#cb26-208"></a>    deduce the types that you didn't write.</span>
<span id="cb26-209"><a href="#cb26-209"></a></span>
<span id="cb26-210"><a href="#cb26-210"></a><span class="ss">2.  </span>Initialization - The second step is, it's going to initialize the</span>
<span id="cb26-211"><a href="#cb26-211"></a>    object.</span>
<span id="cb26-212"><a href="#cb26-212"></a></span>
<span id="cb26-213"><a href="#cb26-213"></a>Let's take a templated class <span class="in">`pair`</span>, this is just a fictional class, it</span>
<span id="cb26-214"><a href="#cb26-214"></a>is not actually how <span class="in">`std::pair&lt;&gt;`</span> looks like:</span>
<span id="cb26-215"><a href="#cb26-215"></a></span>
<span id="cb26-216"><a href="#cb26-216"></a>::: tcolorbox</span>
<span id="cb26-217"><a href="#cb26-217"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-218"><a href="#cb26-218"></a><span class="in">template&lt;typename T, typename U&gt;</span></span>
<span id="cb26-219"><a href="#cb26-219"></a><span class="in">struct pair{</span></span>
<span id="cb26-220"><a href="#cb26-220"></a><span class="in">    T first;</span></span>
<span id="cb26-221"><a href="#cb26-221"></a><span class="in">    U second;</span></span>
<span id="cb26-222"><a href="#cb26-222"></a></span>
<span id="cb26-223"><a href="#cb26-223"></a><span class="in">    pair(const T&amp; _first, const U&amp; _second) </span></span>
<span id="cb26-224"><a href="#cb26-224"></a><span class="in">    : first(_first)</span></span>
<span id="cb26-225"><a href="#cb26-225"></a><span class="in">    , second(_second)</span></span>
<span id="cb26-226"><a href="#cb26-226"></a><span class="in">    {}</span></span>
<span id="cb26-227"><a href="#cb26-227"></a></span>
<span id="cb26-228"><a href="#cb26-228"></a><span class="in">    pair(T&amp;&amp; _first, U&amp;&amp; _second) </span></span>
<span id="cb26-229"><a href="#cb26-229"></a><span class="in">    : first(std::move&lt;T&gt;(_first))</span></span>
<span id="cb26-230"><a href="#cb26-230"></a><span class="in">    , second(std::move&lt;U&gt;(_second))</span></span>
<span id="cb26-231"><a href="#cb26-231"></a><span class="in">    {}</span></span>
<span id="cb26-232"><a href="#cb26-232"></a></span>
<span id="cb26-233"><a href="#cb26-233"></a><span class="in">    //other stuff</span></span>
<span id="cb26-234"><a href="#cb26-234"></a><span class="in">};</span></span>
<span id="cb26-235"><a href="#cb26-235"></a><span class="in">```</span></span>
<span id="cb26-236"><a href="#cb26-236"></a>:::</span>
<span id="cb26-237"><a href="#cb26-237"></a></span>
<span id="cb26-238"><a href="#cb26-238"></a>This is an oversimplification that is enough for our purposes. So, you</span>
<span id="cb26-239"><a href="#cb26-239"></a>have a templated class with two template parameters <span class="in">`T`</span> and <span class="in">`U`</span> and then</span>
<span id="cb26-240"><a href="#cb26-240"></a>you have a bunch of constructors. Now, we want to instantiate one of</span>
<span id="cb26-241"><a href="#cb26-241"></a>these things:</span>
<span id="cb26-242"><a href="#cb26-242"></a></span>
<span id="cb26-243"><a href="#cb26-243"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-244"><a href="#cb26-244"></a><span class="in">pair p1{"OptionVolQuote"s, 0.50};</span></span>
<span id="cb26-245"><a href="#cb26-245"></a><span class="in">```</span></span>
<span id="cb26-246"><a href="#cb26-246"></a></span>
<span id="cb26-247"><a href="#cb26-247"></a>You want to construct an object of type <span class="in">`pair`</span>. The next thing the</span>
<span id="cb26-248"><a href="#cb26-248"></a>compiler sees is, <span class="in">`pair`</span> is a template. And we didn't specify any</span>
<span id="cb26-249"><a href="#cb26-249"></a>template arguments. Probably, you *wanna* do class template argument</span>
<span id="cb26-250"><a href="#cb26-250"></a>deduction.</span>
<span id="cb26-251"><a href="#cb26-251"></a></span>
<span id="cb26-252"><a href="#cb26-252"></a>The next thing happens. <span class="in">`pair`</span> has a bunch of constructors. Probably,</span>
<span id="cb26-253"><a href="#cb26-253"></a>you *wanna* call one of those constructors. And this where step 1 kicks</span>
<span id="cb26-254"><a href="#cb26-254"></a>in, which is the actual *Class Template Argument Deduction*(CTAD).</span>
<span id="cb26-255"><a href="#cb26-255"></a></span>
<span id="cb26-256"><a href="#cb26-256"></a>So, how does the compiler figure out, what you actually want to</span>
<span id="cb26-257"><a href="#cb26-257"></a>instantiate? So, it's going to look at those constructors. Let's pretend</span>
<span id="cb26-258"><a href="#cb26-258"></a>for a minute, that those constructors are ordinary functions - just</span>
<span id="cb26-259"><a href="#cb26-259"></a>free-standing functions. Now, these functions use class template</span>
<span id="cb26-260"><a href="#cb26-260"></a>parameters. Let's pretend for a moment, that those template parameters</span>
<span id="cb26-261"><a href="#cb26-261"></a>are template parameters for the function.</span>
<span id="cb26-262"><a href="#cb26-262"></a></span>
<span id="cb26-263"><a href="#cb26-263"></a>::: tcolorbox</span>
<span id="cb26-264"><a href="#cb26-264"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-265"><a href="#cb26-265"></a><span class="in">template&lt;typename T, typename U&gt;</span></span>
<span id="cb26-266"><a href="#cb26-266"></a><span class="in">struct pair{</span></span>
<span id="cb26-267"><a href="#cb26-267"></a><span class="in">    T first;</span></span>
<span id="cb26-268"><a href="#cb26-268"></a><span class="in">    U second;</span></span>
<span id="cb26-269"><a href="#cb26-269"></a></span>
<span id="cb26-270"><a href="#cb26-270"></a><span class="in">    // Imagine this to be a function template</span></span>
<span id="cb26-271"><a href="#cb26-271"></a><span class="in">    template&lt;typename T, typename U&gt;  </span></span>
<span id="cb26-272"><a href="#cb26-272"></a><span class="in">    pair(const T&amp; _first, const T&amp; _second) </span></span>
<span id="cb26-273"><a href="#cb26-273"></a><span class="in">    : first(_first)</span></span>
<span id="cb26-274"><a href="#cb26-274"></a><span class="in">    , second(_second)</span></span>
<span id="cb26-275"><a href="#cb26-275"></a><span class="in">    {}</span></span>
<span id="cb26-276"><a href="#cb26-276"></a></span>
<span id="cb26-277"><a href="#cb26-277"></a><span class="in">    // Imagine this to be a function template</span></span>
<span id="cb26-278"><a href="#cb26-278"></a><span class="in">    template&lt;typename T, typename U&gt;</span></span>
<span id="cb26-279"><a href="#cb26-279"></a><span class="in">    pair(T&amp;&amp; _first, U&amp;&amp; _second) </span></span>
<span id="cb26-280"><a href="#cb26-280"></a><span class="in">    : first(std::move&lt;T&gt;(_first))</span></span>
<span id="cb26-281"><a href="#cb26-281"></a><span class="in">    , second(std::move&lt;U&gt;(_second))</span></span>
<span id="cb26-282"><a href="#cb26-282"></a><span class="in">    {}</span></span>
<span id="cb26-283"><a href="#cb26-283"></a></span>
<span id="cb26-284"><a href="#cb26-284"></a><span class="in">    //other stuff</span></span>
<span id="cb26-285"><a href="#cb26-285"></a><span class="in">};</span></span>
<span id="cb26-286"><a href="#cb26-286"></a><span class="in">```</span></span>
<span id="cb26-287"><a href="#cb26-287"></a>:::</span>
<span id="cb26-288"><a href="#cb26-288"></a></span>
<span id="cb26-289"><a href="#cb26-289"></a>So, this code doesn't exist. It's just what the compiler temporarily</span>
<span id="cb26-290"><a href="#cb26-290"></a>does for you. And it generates these template functions from the</span>
<span id="cb26-291"><a href="#cb26-291"></a>constructors and they are called the *deduction candidates*.</span>
<span id="cb26-292"><a href="#cb26-292"></a></span>
<span id="cb26-293"><a href="#cb26-293"></a>And now, if we have a call like this:</span>
<span id="cb26-294"><a href="#cb26-294"></a></span>
<span id="cb26-295"><a href="#cb26-295"></a>::: tcolorbox</span>
<span id="cb26-296"><a href="#cb26-296"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-297"><a href="#cb26-297"></a><span class="in">pair p1{"OptionVolQuote"s, 0.50};</span></span>
<span id="cb26-298"><a href="#cb26-298"></a><span class="in">```</span></span>
<span id="cb26-299"><a href="#cb26-299"></a>:::</span>
<span id="cb26-300"><a href="#cb26-300"></a></span>
<span id="cb26-301"><a href="#cb26-301"></a>we know, how to deal with functions right. So, it's going to look at</span>
<span id="cb26-302"><a href="#cb26-302"></a>these functions and apply the usual template arguments deduction and the</span>
<span id="cb26-303"><a href="#cb26-303"></a>usual overload resolution.</span>
<span id="cb26-304"><a href="#cb26-304"></a></span>
<span id="cb26-305"><a href="#cb26-305"></a><span class="in">`"OptionVolQuote"s`</span> is a *lvalue* that gets converted to an *xvalue* (by</span>
<span id="cb26-306"><a href="#cb26-306"></a>the <span class="in">`std::string()`</span> constructor) and <span class="in">`0.50`</span> is a *prvalue*. these</span>
<span id="cb26-307"><a href="#cb26-307"></a>arguments bind to universal references. So, the <span class="in">`pair(T&amp;&amp;, U&amp;&amp;)`</span> version</span>
<span id="cb26-308"><a href="#cb26-308"></a>is chosen by the compiler from the overload set, during overload</span>
<span id="cb26-309"><a href="#cb26-309"></a>resolution. Further, <span class="in">`T`</span> is deduced as <span class="in">`std::string`</span> and <span class="in">`U`</span> is deduced</span>
<span id="cb26-310"><a href="#cb26-310"></a>as <span class="in">`double`</span>. The compiler literally inserts them as:</span>
<span id="cb26-311"><a href="#cb26-311"></a></span>
<span id="cb26-312"><a href="#cb26-312"></a>::: tcolorbox</span>
<span id="cb26-313"><a href="#cb26-313"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-314"><a href="#cb26-314"></a><span class="in">pair&lt;std::string,double&gt; p1{"OptionVolQuote"s, 0.50};</span></span>
<span id="cb26-315"><a href="#cb26-315"></a><span class="in">```</span></span>
<span id="cb26-316"><a href="#cb26-316"></a>:::</span>
<span id="cb26-317"><a href="#cb26-317"></a></span>
<span id="cb26-318"><a href="#cb26-318"></a>Then, its going to do, what it would have done, if you would have</span>
<span id="cb26-319"><a href="#cb26-319"></a>written <span class="in">`pair&lt;std::string,double&gt;`</span>. So, now we know, that this <span class="in">`pair`</span> is</span>
<span id="cb26-320"><a href="#cb26-320"></a>actually <span class="in">`pair&lt;std::string,int&gt;`</span>. So, the step 1 is done.</span>
<span id="cb26-321"><a href="#cb26-321"></a></span>
<span id="cb26-322"><a href="#cb26-322"></a>Now, what we can do is, we can actually instantiate the function</span>
<span id="cb26-323"><a href="#cb26-323"></a>template! That's step 2. So, you have an actual constructor and it will</span>
<span id="cb26-324"><a href="#cb26-324"></a>be called by the run-time to create an object of</span>
<span id="cb26-325"><a href="#cb26-325"></a><span class="in">`pair&lt;std::string,int&gt;`</span>. And we are done.</span>
<span id="cb26-326"><a href="#cb26-326"></a></span>
<span id="cb26-327"><a href="#cb26-327"></a>If we write:</span>
<span id="cb26-328"><a href="#cb26-328"></a></span>
<span id="cb26-329"><a href="#cb26-329"></a>::: tcolorbox</span>
<span id="cb26-330"><a href="#cb26-330"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-331"><a href="#cb26-331"></a><span class="in">const auto s{"5YSwapRate"s};</span></span>
<span id="cb26-332"><a href="#cb26-332"></a><span class="in">const auto rate{0.0125};</span></span>
<span id="cb26-333"><a href="#cb26-333"></a><span class="in">pair p2{s,rate};</span></span>
<span id="cb26-334"><a href="#cb26-334"></a><span class="in">```</span></span>
<span id="cb26-335"><a href="#cb26-335"></a>:::</span>
<span id="cb26-336"><a href="#cb26-336"></a></span>
<span id="cb26-337"><a href="#cb26-337"></a>Here, <span class="in">`s`</span> and <span class="in">`rate`</span> are identifiers, so these are *glvalues* and can</span>
<span id="cb26-338"><a href="#cb26-338"></a>bind to <span class="in">`const T&amp;`</span>. So, the compiler instantiates the first overload of</span>
<span id="cb26-339"><a href="#cb26-339"></a>the constructor as <span class="in">`pair(const std::string&amp;, const double&amp;)`</span>.</span>
<span id="cb26-340"><a href="#cb26-340"></a></span>
<span id="cb26-341"><a href="#cb26-341"></a>There's no need to use <span class="in">`std::make_pair`</span> anymore. This <span class="in">`make_pair`</span> thing</span>
<span id="cb26-342"><a href="#cb26-342"></a>is a basically a work-around for the fact that up until C++14, you could</span>
<span id="cb26-343"><a href="#cb26-343"></a>only do this with functions. So, you had to use a function to deduce the</span>
<span id="cb26-344"><a href="#cb26-344"></a>class template arguments. So, it was kind of hacky. And now we don't</span>
<span id="cb26-345"><a href="#cb26-345"></a>need to use that anymore.</span>
<span id="cb26-346"><a href="#cb26-346"></a></span>
<span id="cb26-347"><a href="#cb26-347"></a>The same goes for <span class="in">`std::tuple`</span>, you can instantiate a <span class="in">`std::tuple`</span> with</span>
<span id="cb26-348"><a href="#cb26-348"></a>a bunch of arguments and it's going to deduce the correct types for you,</span>
<span id="cb26-349"><a href="#cb26-349"></a>so you don't need to use <span class="in">`std::make_tuple`</span> anymore.</span>
<span id="cb26-350"><a href="#cb26-350"></a></span>
<span id="cb26-351"><a href="#cb26-351"></a>::: tcolorbox</span>
<span id="cb26-352"><a href="#cb26-352"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-353"><a href="#cb26-353"></a><span class="in">std::tuple point{1.00, -1.00}</span></span>
<span id="cb26-354"><a href="#cb26-354"></a><span class="in">```</span></span>
<span id="cb26-355"><a href="#cb26-355"></a>:::</span>
<span id="cb26-356"><a href="#cb26-356"></a></span>
<span id="cb26-357"><a href="#cb26-357"></a>Let's look at <span class="in">`std::vector`</span>. So, for example, if you just give it an</span>
<span id="cb26-358"><a href="#cb26-358"></a><span class="in">`std::initializer_list`</span> of <span class="in">`int`</span>s, its gonna correctly deduce back to</span>
<span id="cb26-359"><a href="#cb26-359"></a><span class="in">`std::vector&lt;int&gt;`</span>.</span>
<span id="cb26-360"><a href="#cb26-360"></a></span>
<span id="cb26-361"><a href="#cb26-361"></a>::: tcolorbox</span>
<span id="cb26-362"><a href="#cb26-362"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-363"><a href="#cb26-363"></a><span class="in">std::vector v{3, 5, 7, 11, 13};</span></span>
<span id="cb26-364"><a href="#cb26-364"></a><span class="in">// deduces std::vector&lt;int&gt;</span></span>
<span id="cb26-365"><a href="#cb26-365"></a><span class="in">```</span></span>
<span id="cb26-366"><a href="#cb26-366"></a>:::</span>
<span id="cb26-367"><a href="#cb26-367"></a></span>
<span id="cb26-368"><a href="#cb26-368"></a>Of course, with <span class="in">`std::vector`</span>, there's a trap. <span class="in">`std::vector`</span> has this</span>
<span id="cb26-369"><a href="#cb26-369"></a>other constructor which takes a <span class="in">`std::size_t`</span>, and it initializes a</span>
<span id="cb26-370"><a href="#cb26-370"></a>vector with that many elements in it.</span>
<span id="cb26-371"><a href="#cb26-371"></a></span>
<span id="cb26-372"><a href="#cb26-372"></a>::: tcolorbox</span>
<span id="cb26-373"><a href="#cb26-373"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-374"><a href="#cb26-374"></a><span class="in">std::vector&lt;int&gt; v1{3};</span></span>
<span id="cb26-375"><a href="#cb26-375"></a><span class="in">// content is {3}</span></span>
<span id="cb26-376"><a href="#cb26-376"></a></span>
<span id="cb26-377"><a href="#cb26-377"></a><span class="in">std::vector&lt;int&gt; v2(3);</span></span>
<span id="cb26-378"><a href="#cb26-378"></a><span class="in">// content is {0,0,0}</span></span>
<span id="cb26-379"><a href="#cb26-379"></a><span class="in">```</span></span>
<span id="cb26-380"><a href="#cb26-380"></a>:::</span>
<span id="cb26-381"><a href="#cb26-381"></a></span>
<span id="cb26-382"><a href="#cb26-382"></a>So, in C++14, if you write <span class="in">`std::vector&lt;int&gt; v{3}`</span> with curly braces,</span>
<span id="cb26-383"><a href="#cb26-383"></a>it's going to be an initializer list, so its going to initialize the</span>
<span id="cb26-384"><a href="#cb26-384"></a>vector with one <span class="in">`int`</span>, which is <span class="in">`3`</span>. If you <span class="in">`std::vector&lt;int&gt; v(3)`</span> with</span>
<span id="cb26-385"><a href="#cb26-385"></a>parenthesis, it's going to call the <span class="in">`size_t`</span> constructor, and you're</span>
<span id="cb26-386"><a href="#cb26-386"></a>gonna have 3 <span class="in">`int`</span>s, which are initialized to <span class="in">`0.0`</span>.</span>
<span id="cb26-387"><a href="#cb26-387"></a></span>
<span id="cb26-388"><a href="#cb26-388"></a>Now, what happens if you omit the <span class="in">`int`</span> and use class-template argument</span>
<span id="cb26-389"><a href="#cb26-389"></a>deduction? Then if you write the curlies, its going to do the deduction.</span>
<span id="cb26-390"><a href="#cb26-390"></a>But if you use round parenthesis, it says, well you're calling the</span>
<span id="cb26-391"><a href="#cb26-391"></a>constructor that takes a <span class="in">`size_t`</span>, so you are going to have 3 elements,</span>
<span id="cb26-392"><a href="#cb26-392"></a>but 3 elements of what type? You didn't specify! So, you get a compiler</span>
<span id="cb26-393"><a href="#cb26-393"></a>error.</span>
<span id="cb26-394"><a href="#cb26-394"></a></span>
<span id="cb26-395"><a href="#cb26-395"></a>::: tcolorbox</span>
<span id="cb26-396"><a href="#cb26-396"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-397"><a href="#cb26-397"></a><span class="in">std::vector v1{3};</span></span>
<span id="cb26-398"><a href="#cb26-398"></a><span class="in">// Ok- deduces std::vector&lt;int&gt;, content is {3}</span></span>
<span id="cb26-399"><a href="#cb26-399"></a></span>
<span id="cb26-400"><a href="#cb26-400"></a><span class="in">// std::vector v2(3);</span></span>
<span id="cb26-401"><a href="#cb26-401"></a><span class="in">// Error : 3 elements of what?</span></span>
<span id="cb26-402"><a href="#cb26-402"></a><span class="in">```</span></span>
<span id="cb26-403"><a href="#cb26-403"></a>:::</span>
<span id="cb26-404"><a href="#cb26-404"></a></span>
<span id="cb26-405"><a href="#cb26-405"></a><span class="in">`std::vector`</span> has another constructor, which is really cool! Now, some</span>
<span id="cb26-406"><a href="#cb26-406"></a>real magic happens here! So, if you have a range of <span class="in">`int`</span>s, any range,</span>
<span id="cb26-407"><a href="#cb26-407"></a>then there's this constructor that takes a pair of iterators like</span>
<span id="cb26-408"><a href="#cb26-408"></a><span class="in">`begin()`</span> and <span class="in">`end()`</span> and if you don't specify the <span class="in">`int`</span>, it is still</span>
<span id="cb26-409"><a href="#cb26-409"></a>going to figure out, that those iterators are iterators to <span class="in">`int`</span> range</span>
<span id="cb26-410"><a href="#cb26-410"></a>and it is going correctly deduce <span class="in">`std::vector&lt;int&gt;`</span> for you.</span>
<span id="cb26-411"><a href="#cb26-411"></a></span>
<span id="cb26-412"><a href="#cb26-412"></a>::: tcolorbox</span>
<span id="cb26-413"><a href="#cb26-413"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-414"><a href="#cb26-414"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-415"><a href="#cb26-415"></a><span class="in">std::vector v(range.begin(), range.end());</span></span>
<span id="cb26-416"><a href="#cb26-416"></a><span class="in">// deduces std::vector&lt;int&gt;</span></span>
<span id="cb26-417"><a href="#cb26-417"></a><span class="in">```</span></span>
<span id="cb26-418"><a href="#cb26-418"></a>:::</span>
<span id="cb26-419"><a href="#cb26-419"></a></span>
<span id="cb26-420"><a href="#cb26-420"></a>How does that work? It has this constructor which looks like the below.</span>
<span id="cb26-421"><a href="#cb26-421"></a>It takes two iterators.</span>
<span id="cb26-422"><a href="#cb26-422"></a></span>
<span id="cb26-423"><a href="#cb26-423"></a>::: tcolorbox</span>
<span id="cb26-424"><a href="#cb26-424"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-425"><a href="#cb26-425"></a><span class="in">template&lt;typename T&gt;</span></span>
<span id="cb26-426"><a href="#cb26-426"></a><span class="in">struct vector</span></span>
<span id="cb26-427"><a href="#cb26-427"></a><span class="in">{</span></span>
<span id="cb26-428"><a href="#cb26-428"></a><span class="in">    // range c'tor</span></span>
<span id="cb26-429"><a href="#cb26-429"></a><span class="in">    template&lt;typename Iter&gt;</span></span>
<span id="cb26-430"><a href="#cb26-430"></a><span class="in">    vector&lt;Iter begin, Iter end&gt; { /* ... */ }</span></span>
<span id="cb26-431"><a href="#cb26-431"></a></span>
<span id="cb26-432"><a href="#cb26-432"></a><span class="in">    // other stuff</span></span>
<span id="cb26-433"><a href="#cb26-433"></a><span class="in">};</span></span>
<span id="cb26-434"><a href="#cb26-434"></a><span class="in">```</span></span>
<span id="cb26-435"><a href="#cb26-435"></a>:::</span>
<span id="cb26-436"><a href="#cb26-436"></a></span>
<span id="cb26-437"><a href="#cb26-437"></a>If you have a constructor that also has template arguments, the compiler</span>
<span id="cb26-438"><a href="#cb26-438"></a>is going to pretend that this is a function and it's going to take the</span>
<span id="cb26-439"><a href="#cb26-439"></a>template argument of the class and concatenate it with the constructor's</span>
<span id="cb26-440"><a href="#cb26-440"></a>template argument. It's going to put them one after the other.</span>
<span id="cb26-441"><a href="#cb26-441"></a></span>
<span id="cb26-442"><a href="#cb26-442"></a>::: tcolorbox</span>
<span id="cb26-443"><a href="#cb26-443"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-444"><a href="#cb26-444"></a><span class="in">// This is magic code, generated by the compiler</span></span>
<span id="cb26-445"><a href="#cb26-445"></a><span class="in">template&lt;typename T&gt;</span></span>
<span id="cb26-446"><a href="#cb26-446"></a><span class="in">struct vector</span></span>
<span id="cb26-447"><a href="#cb26-447"></a><span class="in">{</span></span>
<span id="cb26-448"><a href="#cb26-448"></a><span class="in">    // range c'tor</span></span>
<span id="cb26-449"><a href="#cb26-449"></a><span class="in">    template&lt;typename T, typename Iter&gt;</span></span>
<span id="cb26-450"><a href="#cb26-450"></a><span class="in">    vector&lt;Iter begin, Iter end&gt; { /* ... */ }</span></span>
<span id="cb26-451"><a href="#cb26-451"></a></span>
<span id="cb26-452"><a href="#cb26-452"></a><span class="in">    // other stuff</span></span>
<span id="cb26-453"><a href="#cb26-453"></a><span class="in">};</span></span>
<span id="cb26-454"><a href="#cb26-454"></a><span class="in">```</span></span>
<span id="cb26-455"><a href="#cb26-455"></a>:::</span>
<span id="cb26-456"><a href="#cb26-456"></a></span>
<span id="cb26-457"><a href="#cb26-457"></a>Now, if you call it like this:</span>
<span id="cb26-458"><a href="#cb26-458"></a></span>
<span id="cb26-459"><a href="#cb26-459"></a>::: tcolorbox</span>
<span id="cb26-460"><a href="#cb26-460"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-461"><a href="#cb26-461"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-462"><a href="#cb26-462"></a><span class="in">std::vector v(range.begin(), range.end());</span></span>
<span id="cb26-463"><a href="#cb26-463"></a><span class="in">```</span></span>
<span id="cb26-464"><a href="#cb26-464"></a>:::</span>
<span id="cb26-465"><a href="#cb26-465"></a></span>
<span id="cb26-466"><a href="#cb26-466"></a>it's going to say, well okay, you are giving me two iterators, so I can</span>
<span id="cb26-467"><a href="#cb26-467"></a>deduce the type of iterators as <span class="in">`std::vector&lt;&gt;::iterator`</span>. But, you</span>
<span id="cb26-468"><a href="#cb26-468"></a>didn't specify <span class="in">`T`</span>, so I still don't know what <span class="in">`T`</span> is. So, how is it</span>
<span id="cb26-469"><a href="#cb26-469"></a>able to figure this out?</span>
<span id="cb26-470"><a href="#cb26-470"></a></span>
<span id="cb26-471"><a href="#cb26-471"></a><span class="fu"># Deduction Guides.</span></span>
<span id="cb26-472"><a href="#cb26-472"></a></span>
<span id="cb26-473"><a href="#cb26-473"></a>This is another feature called deduction guides. When the compiler can't</span>
<span id="cb26-474"><a href="#cb26-474"></a>figure out, with this machinery, what the type is, but it is kind of</span>
<span id="cb26-475"><a href="#cb26-475"></a>obvious to you, what the type should be, you can write a deduction</span>
<span id="cb26-476"><a href="#cb26-476"></a>guide.</span>
<span id="cb26-477"><a href="#cb26-477"></a></span>
<span id="cb26-478"><a href="#cb26-478"></a>::: tcolorbox</span>
<span id="cb26-479"><a href="#cb26-479"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-480"><a href="#cb26-480"></a><span class="in">template&lt;typename T&gt;</span></span>
<span id="cb26-481"><a href="#cb26-481"></a><span class="in">struct vector</span></span>
<span id="cb26-482"><a href="#cb26-482"></a><span class="in">{</span></span>
<span id="cb26-483"><a href="#cb26-483"></a><span class="in">    // range c'tor</span></span>
<span id="cb26-484"><a href="#cb26-484"></a><span class="in">    template&lt;typename Iter&gt;</span></span>
<span id="cb26-485"><a href="#cb26-485"></a><span class="in">    vector&lt;Iter begin, Iter end&gt; { /* ... */ }</span></span>
<span id="cb26-486"><a href="#cb26-486"></a></span>
<span id="cb26-487"><a href="#cb26-487"></a><span class="in">    // other stuff</span></span>
<span id="cb26-488"><a href="#cb26-488"></a><span class="in">};</span></span>
<span id="cb26-489"><a href="#cb26-489"></a></span>
<span id="cb26-490"><a href="#cb26-490"></a><span class="in">// deduction guide:</span></span>
<span id="cb26-491"><a href="#cb26-491"></a><span class="in">template &lt;typename Iter&gt;</span></span>
<span id="cb26-492"><a href="#cb26-492"></a><span class="in">vector(Iter begin, Iter end) </span></span>
<span id="cb26-493"><a href="#cb26-493"></a><span class="in">    -&gt; vector&lt;typename Iter::iterator_traits&lt;Iter&gt;::value_type&gt;;</span></span>
<span id="cb26-494"><a href="#cb26-494"></a></span>
<span id="cb26-495"><a href="#cb26-495"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-496"><a href="#cb26-496"></a><span class="in">std::vector v(range.begin(), range.end());</span></span>
<span id="cb26-497"><a href="#cb26-497"></a><span class="in">```</span></span>
<span id="cb26-498"><a href="#cb26-498"></a>:::</span>
<span id="cb26-499"><a href="#cb26-499"></a></span>
<span id="cb26-500"><a href="#cb26-500"></a>It starts with something that looks like a constructor signature, and</span>
<span id="cb26-501"><a href="#cb26-501"></a>then you have this arrow <span class="in">`-&gt;`</span> and after the arrow, you put like a</span>
<span id="cb26-502"><a href="#cb26-502"></a>specialization of the same class. So, you are gonna say, well, if you</span>
<span id="cb26-503"><a href="#cb26-503"></a>have this constructor signature (which will be added to the deduction</span>
<span id="cb26-504"><a href="#cb26-504"></a>candidates), and if this is the one that is going to be selected by the</span>
<span id="cb26-505"><a href="#cb26-505"></a>compiler, then deduce the type after the arrow (<span class="in">`-&gt;`</span>). So, this is like</span>
<span id="cb26-506"><a href="#cb26-506"></a>a new entity in C++17. It's not a class, it's not a function, it's a</span>
<span id="cb26-507"><a href="#cb26-507"></a>*deduction guide*.</span>
<span id="cb26-508"><a href="#cb26-508"></a></span>
<span id="cb26-509"><a href="#cb26-509"></a>With that deduction guide, basically you're saying, well, if I get two</span>
<span id="cb26-510"><a href="#cb26-510"></a>iterators, then take the iterator traits, figure out the value type</span>
<span id="cb26-511"><a href="#cb26-511"></a>which this iterator points to and initialize the vector with that type.</span>
<span id="cb26-512"><a href="#cb26-512"></a>And that works and compiles.</span>
<span id="cb26-513"><a href="#cb26-513"></a></span>
<span id="cb26-514"><a href="#cb26-514"></a>So, this compiles, but actually the order matters. Deductions guides are</span>
<span id="cb26-515"><a href="#cb26-515"></a>only considered for the code that is below the deduction guide.</span>
<span id="cb26-516"><a href="#cb26-516"></a></span>
<span id="cb26-517"><a href="#cb26-517"></a>So, if you flip around the order:</span>
<span id="cb26-518"><a href="#cb26-518"></a></span>
<span id="cb26-519"><a href="#cb26-519"></a>::: tcolorbox</span>
<span id="cb26-520"><a href="#cb26-520"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-521"><a href="#cb26-521"></a><span class="in">template&lt;typename T&gt;</span></span>
<span id="cb26-522"><a href="#cb26-522"></a><span class="in">struct vector</span></span>
<span id="cb26-523"><a href="#cb26-523"></a><span class="in">{</span></span>
<span id="cb26-524"><a href="#cb26-524"></a><span class="in">    // range c'tor</span></span>
<span id="cb26-525"><a href="#cb26-525"></a><span class="in">    template&lt;typename Iter&gt;</span></span>
<span id="cb26-526"><a href="#cb26-526"></a><span class="in">    vector&lt;Iter begin, Iter end&gt; { /* ... */ }</span></span>
<span id="cb26-527"><a href="#cb26-527"></a></span>
<span id="cb26-528"><a href="#cb26-528"></a><span class="in">    // other stuff</span></span>
<span id="cb26-529"><a href="#cb26-529"></a><span class="in">};</span></span>
<span id="cb26-530"><a href="#cb26-530"></a></span>
<span id="cb26-531"><a href="#cb26-531"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-532"><a href="#cb26-532"></a><span class="in">//std::vector v(range.begin(), range.end());</span></span>
<span id="cb26-533"><a href="#cb26-533"></a><span class="in">// Error: deduction failed</span></span>
<span id="cb26-534"><a href="#cb26-534"></a></span>
<span id="cb26-535"><a href="#cb26-535"></a><span class="in">// deduction guide:</span></span>
<span id="cb26-536"><a href="#cb26-536"></a><span class="in">template &lt;typename Iter&gt;</span></span>
<span id="cb26-537"><a href="#cb26-537"></a><span class="in">vector(Iter begin, Iter end) </span></span>
<span id="cb26-538"><a href="#cb26-538"></a><span class="in">    -&gt; vector&lt;typename Iter::iterator_traits&lt;Iter&gt;::value_type&gt;;</span></span>
<span id="cb26-539"><a href="#cb26-539"></a><span class="in">```</span></span>
<span id="cb26-540"><a href="#cb26-540"></a>:::</span>
<span id="cb26-541"><a href="#cb26-541"></a></span>
<span id="cb26-542"><a href="#cb26-542"></a>then it's not going to work anymore.</span>
<span id="cb26-543"><a href="#cb26-543"></a></span>
<span id="cb26-544"><a href="#cb26-544"></a>One thing that's really a good recommendation, is that these deduction</span>
<span id="cb26-545"><a href="#cb26-545"></a>guides are really part of the class interface. Because they tell you,</span>
<span id="cb26-546"><a href="#cb26-546"></a>you can instantiate this class template like this, so *deduction guides</span>
<span id="cb26-547"><a href="#cb26-547"></a>should be defined immediately after the class definition*.</span>
<span id="cb26-548"><a href="#cb26-548"></a></span>
<span id="cb26-549"><a href="#cb26-549"></a><span class="fu">## List initialization has priority</span></span>
<span id="cb26-550"><a href="#cb26-550"></a></span>
<span id="cb26-551"><a href="#cb26-551"></a>You really have to be careful with the parenthesis and the curlies.</span>
<span id="cb26-552"><a href="#cb26-552"></a></span>
<span id="cb26-553"><a href="#cb26-553"></a>::: tcolorbox</span>
<span id="cb26-554"><a href="#cb26-554"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-555"><a href="#cb26-555"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-556"><a href="#cb26-556"></a><span class="in">std::vector v(range.begin(), range.end());</span></span>
<span id="cb26-557"><a href="#cb26-557"></a><span class="in">// deduces std::vector&lt;int&gt;</span></span>
<span id="cb26-558"><a href="#cb26-558"></a></span>
<span id="cb26-559"><a href="#cb26-559"></a><span class="in">std::vector v{range.begin(), range.end()};</span></span>
<span id="cb26-560"><a href="#cb26-560"></a><span class="in">// list initialization has a priority, so the compiler deduces it</span></span>
<span id="cb26-561"><a href="#cb26-561"></a><span class="in">// as std::vector&lt;std::vector&lt;int&gt;::iterator&gt;, which is </span></span>
<span id="cb26-562"><a href="#cb26-562"></a><span class="in">// probably not what we want</span></span>
<span id="cb26-563"><a href="#cb26-563"></a><span class="in">```</span></span>
<span id="cb26-564"><a href="#cb26-564"></a>:::</span>
<span id="cb26-565"><a href="#cb26-565"></a></span>
<span id="cb26-566"><a href="#cb26-566"></a><span class="fu"># Sequence Containers</span></span>
<span id="cb26-567"><a href="#cb26-567"></a></span>
<span id="cb26-568"><a href="#cb26-568"></a>CTAD works the same with all the other sequence containers.</span>
<span id="cb26-569"><a href="#cb26-569"></a></span>
<span id="cb26-570"><a href="#cb26-570"></a>::: tcolorbox</span>
<span id="cb26-571"><a href="#cb26-571"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-572"><a href="#cb26-572"></a><span class="in">#include &lt;iostream&gt;</span></span>
<span id="cb26-573"><a href="#cb26-573"></a><span class="in">#include &lt;vector&gt;</span></span>
<span id="cb26-574"><a href="#cb26-574"></a><span class="in">#include &lt;list&gt;</span></span>
<span id="cb26-575"><a href="#cb26-575"></a><span class="in">#include &lt;deque&gt;</span></span>
<span id="cb26-576"><a href="#cb26-576"></a><span class="in">#include &lt;array&gt;</span></span>
<span id="cb26-577"><a href="#cb26-577"></a><span class="in">#include &lt;forward_list&gt;</span></span>
<span id="cb26-578"><a href="#cb26-578"></a></span>
<span id="cb26-579"><a href="#cb26-579"></a><span class="in">int main()</span></span>
<span id="cb26-580"><a href="#cb26-580"></a><span class="in">{</span></span>
<span id="cb26-581"><a href="#cb26-581"></a><span class="in">    std::list l{2, 3, 5, 7, 11};</span></span>
<span id="cb26-582"><a href="#cb26-582"></a><span class="in">    //deduces std::list&lt;int&gt;</span></span>
<span id="cb26-583"><a href="#cb26-583"></a></span>
<span id="cb26-584"><a href="#cb26-584"></a><span class="in">    std::forward_list fl{2, 3, 5, 7, 11};</span></span>
<span id="cb26-585"><a href="#cb26-585"></a><span class="in">    //deduces std::forward_list&lt;int&gt;</span></span>
<span id="cb26-586"><a href="#cb26-586"></a></span>
<span id="cb26-587"><a href="#cb26-587"></a><span class="in">    std::deque d{2, 3, 5, 7, 11};</span></span>
<span id="cb26-588"><a href="#cb26-588"></a><span class="in">    //deduces std::deque&lt;int&gt;</span></span>
<span id="cb26-589"><a href="#cb26-589"></a></span>
<span id="cb26-590"><a href="#cb26-590"></a><span class="in">    std::array a{2, 3, 5, 7, 11};</span></span>
<span id="cb26-591"><a href="#cb26-591"></a><span class="in">    //deduces std::array&lt;int,5&gt;</span></span>
<span id="cb26-592"><a href="#cb26-592"></a><span class="in">    return 0;</span></span>
<span id="cb26-593"><a href="#cb26-593"></a><span class="in">}</span></span>
<span id="cb26-594"><a href="#cb26-594"></a><span class="in">```</span></span>
<span id="cb26-595"><a href="#cb26-595"></a>:::</span>
<span id="cb26-596"><a href="#cb26-596"></a></span>
<span id="cb26-597"><a href="#cb26-597"></a><span class="co">[</span><span class="ot">Compiler Explorer</span><span class="co">](https://godbolt.org/z/d74a8c4f5)</span></span>
<span id="cb26-598"><a href="#cb26-598"></a></span>
<span id="cb26-599"><a href="#cb26-599"></a>With <span class="in">`std::array&lt;T,N&gt;`</span> it also deduces the size for you. We are going to</span>
<span id="cb26-600"><a href="#cb26-600"></a>see later, how that works. They also have these range constructors</span>
<span id="cb26-601"><a href="#cb26-601"></a>except for <span class="in">`std::array&lt;T,N&gt;`</span>.</span>
<span id="cb26-602"><a href="#cb26-602"></a></span>
<span id="cb26-603"><a href="#cb26-603"></a>::: tcolorbox</span>
<span id="cb26-604"><a href="#cb26-604"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-605"><a href="#cb26-605"></a><span class="in">std::vector range{2, 3, 5, 7, 11};</span></span>
<span id="cb26-606"><a href="#cb26-606"></a></span>
<span id="cb26-607"><a href="#cb26-607"></a><span class="in">std::list l(range.begin(), range.end());</span></span>
<span id="cb26-608"><a href="#cb26-608"></a><span class="in">// deduces std::list&lt;int&gt;</span></span>
<span id="cb26-609"><a href="#cb26-609"></a></span>
<span id="cb26-610"><a href="#cb26-610"></a><span class="in">std::forward_list fl(range.begin(), range.end());</span></span>
<span id="cb26-611"><a href="#cb26-611"></a><span class="in">// deduces std::foward_list&lt;int&gt;</span></span>
<span id="cb26-612"><a href="#cb26-612"></a></span>
<span id="cb26-613"><a href="#cb26-613"></a><span class="in">std::deque d(range.begin(), range.end());</span></span>
<span id="cb26-614"><a href="#cb26-614"></a><span class="in">// deduces std::deque&lt;int&gt;</span></span>
<span id="cb26-615"><a href="#cb26-615"></a></span>
<span id="cb26-616"><a href="#cb26-616"></a><span class="in">// also, the same pitfall - don't use curly braces</span></span>
<span id="cb26-617"><a href="#cb26-617"></a><span class="in">```</span></span>
<span id="cb26-618"><a href="#cb26-618"></a>:::</span>
<span id="cb26-619"><a href="#cb26-619"></a></span>
<span id="cb26-620"><a href="#cb26-620"></a>Then, there is <span class="in">`std::set`</span>. <span class="in">`std::set`</span> also has both of these</span>
<span id="cb26-621"><a href="#cb26-621"></a>constructors. But, <span class="in">`std::set`</span> also has more stuff. You know, <span class="in">`std::set`</span></span>
<span id="cb26-622"><a href="#cb26-622"></a>has this external template parameter which is the comparison function,</span>
<span id="cb26-623"><a href="#cb26-623"></a>so you can specify your own comparator lambda. And that's a template</span>
<span id="cb26-624"><a href="#cb26-624"></a>argument. But, the cool thing is, <span class="in">`std::set`</span> also has a constructor,</span>
<span id="cb26-625"><a href="#cb26-625"></a>that takes this comparator as a template argument and it can deduce that</span>
<span id="cb26-626"><a href="#cb26-626"></a>as well. So, we can actually write something like this:</span>
<span id="cb26-627"><a href="#cb26-627"></a></span>
<span id="cb26-628"><a href="#cb26-628"></a>::: tcolorbox</span>
<span id="cb26-629"><a href="#cb26-629"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-630"><a href="#cb26-630"></a><span class="in">std::set s({2, 3, 5, 7, 11}, [](int a, int b){return a &gt; b;});</span></span>
<span id="cb26-631"><a href="#cb26-631"></a><span class="in">```</span></span>
<span id="cb26-632"><a href="#cb26-632"></a>:::</span>
<span id="cb26-633"><a href="#cb26-633"></a></span>
<span id="cb26-634"><a href="#cb26-634"></a>Notice that you don't have to pass the type of the lambda</span>
<span id="cb26-635"><a href="#cb26-635"></a><span class="in">`bool (int,int)`</span>, the compiler will automatically deduce it for you.</span>
<span id="cb26-636"><a href="#cb26-636"></a></span>
<span id="cb26-637"><a href="#cb26-637"></a><span class="fu"># Locks and Mutexes.</span></span>
<span id="cb26-638"><a href="#cb26-638"></a></span>
<span id="cb26-639"><a href="#cb26-639"></a>One of the most popular use-cases for CTAD is mutexes. When you have</span>
<span id="cb26-640"><a href="#cb26-640"></a>long type names like <span class="in">`std::shared_timed_mutex mtx`</span> and then if you had</span>
<span id="cb26-641"><a href="#cb26-641"></a>to lock it, you had to specify this thing:</span>
<span id="cb26-642"><a href="#cb26-642"></a><span class="in">`std::lock_guard&lt;std::shared_timed_mutex&gt; lock(mtx)`</span>. With C++17, you</span>
<span id="cb26-643"><a href="#cb26-643"></a>don't have to do that anymore:</span>
<span id="cb26-644"><a href="#cb26-644"></a></span>
<span id="cb26-645"><a href="#cb26-645"></a>::: tcolorbox</span>
<span id="cb26-646"><a href="#cb26-646"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-647"><a href="#cb26-647"></a><span class="in">std::shared_timed_mutex mtx;</span></span>
<span id="cb26-648"><a href="#cb26-648"></a><span class="in">std::lock_guard lock(mtx);</span></span>
<span id="cb26-649"><a href="#cb26-649"></a><span class="in">// deduced as std::lock_guard&lt;std::shared_timed_mutex&gt;</span></span>
<span id="cb26-650"><a href="#cb26-650"></a><span class="in">```</span></span>
<span id="cb26-651"><a href="#cb26-651"></a>:::</span>
<span id="cb26-652"><a href="#cb26-652"></a></span>
<span id="cb26-653"><a href="#cb26-653"></a><span class="fu"># Smart Pointers.</span></span>
<span id="cb26-654"><a href="#cb26-654"></a></span>
<span id="cb26-655"><a href="#cb26-655"></a>This is one of the prime examples, where class template argument</span>
<span id="cb26-656"><a href="#cb26-656"></a>deduction can be dangerous and damaging. Let's say you have a</span>
<span id="cb26-657"><a href="#cb26-657"></a><span class="in">`struct Citizen`</span> with some constructor. And, then you want to create a</span>
<span id="cb26-658"><a href="#cb26-658"></a><span class="in">`Citizen`</span> instance dynamically on the heap. You would maybe expect to</span>
<span id="cb26-659"><a href="#cb26-659"></a>write:</span>
<span id="cb26-660"><a href="#cb26-660"></a></span>
<span id="cb26-661"><a href="#cb26-661"></a>::: tcolorbox</span>
<span id="cb26-662"><a href="#cb26-662"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-663"><a href="#cb26-663"></a><span class="in">struct Citizen{</span></span>
<span id="cb26-664"><a href="#cb26-664"></a><span class="in">    //c'tor</span></span>
<span id="cb26-665"><a href="#cb26-665"></a><span class="in">    Citizen(std::string prefix, int serial_number);</span></span>
<span id="cb26-666"><a href="#cb26-666"></a><span class="in">};</span></span>
<span id="cb26-667"><a href="#cb26-667"></a></span>
<span id="cb26-668"><a href="#cb26-668"></a><span class="in">// std::shared_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb26-669"><a href="#cb26-669"></a><span class="in">// Error! No CTAD</span></span>
<span id="cb26-670"><a href="#cb26-670"></a></span>
<span id="cb26-671"><a href="#cb26-671"></a><span class="in">auto sptr = std::make_shared&lt;Citizen&gt;("THX",1138);</span></span>
<span id="cb26-672"><a href="#cb26-672"></a><span class="in">```</span></span>
<span id="cb26-673"><a href="#cb26-673"></a>:::</span>
<span id="cb26-674"><a href="#cb26-674"></a></span>
<span id="cb26-675"><a href="#cb26-675"></a>You give it a pointer to this dynamically allocated <span class="in">`Citizen`</span> object,</span>
<span id="cb26-676"><a href="#cb26-676"></a>and then you think it's going to work. But, that fails and for good</span>
<span id="cb26-677"><a href="#cb26-677"></a>reason! It's specifically disabled. So, you're back to using</span>
<span id="cb26-678"><a href="#cb26-678"></a><span class="in">`make_shared&lt;T&gt;`</span> again. The same with <span class="in">`std::unique_ptr&lt;T&gt;`</span>.</span>
<span id="cb26-679"><a href="#cb26-679"></a></span>
<span id="cb26-680"><a href="#cb26-680"></a>::: tcolorbox</span>
<span id="cb26-681"><a href="#cb26-681"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-682"><a href="#cb26-682"></a><span class="in">// std::unique_ptr sptr(new Citizen("THX",1138);</span></span>
<span id="cb26-683"><a href="#cb26-683"></a><span class="in">// Error! No CTAD</span></span>
<span id="cb26-684"><a href="#cb26-684"></a></span>
<span id="cb26-685"><a href="#cb26-685"></a><span class="in">auto uptr = std::make_unique&lt;Citizen&gt;("THX",1138);</span></span>
<span id="cb26-686"><a href="#cb26-686"></a><span class="in">```</span></span>
<span id="cb26-687"><a href="#cb26-687"></a>:::</span>
<span id="cb26-688"><a href="#cb26-688"></a></span>
<span id="cb26-689"><a href="#cb26-689"></a>It's not going to the deduce the type <span class="in">`T`</span>; you have to use</span>
<span id="cb26-690"><a href="#cb26-690"></a><span class="in">`make_unique&lt;T&gt;`</span>.</span>
<span id="cb26-691"><a href="#cb26-691"></a></span>
<span id="cb26-692"><a href="#cb26-692"></a>There's good reasons for this. First of all, <span class="in">`make_shared&lt;T&gt;`</span> has</span>
<span id="cb26-693"><a href="#cb26-693"></a>exception safety built in. If for some reason, the constructor fails and</span>
<span id="cb26-694"><a href="#cb26-694"></a><span class="in">`throw`</span>s, then you are not going to leak memory.</span>
<span id="cb26-695"><a href="#cb26-695"></a></span>
<span id="cb26-696"><a href="#cb26-696"></a>Secondly, if you have an array, and you pass it to a constructor, it</span>
<span id="cb26-697"><a href="#cb26-697"></a>decays into a pointer. If you had class-template argument deduction</span>
<span id="cb26-698"><a href="#cb26-698"></a>smart-pointers, you could write like that:</span>
<span id="cb26-699"><a href="#cb26-699"></a></span>
<span id="cb26-700"><a href="#cb26-700"></a>::: tcolorbox</span>
<span id="cb26-701"><a href="#cb26-701"></a><span class="in">``` {.cpp breaklines=""}</span></span>
<span id="cb26-702"><a href="#cb26-702"></a><span class="in">// std::unique_ptr uptr(new int[10]);</span></span>
<span id="cb26-703"><a href="#cb26-703"></a><span class="in">// if that would compile, uh-oh!</span></span>
<span id="cb26-704"><a href="#cb26-704"></a><span class="in">```</span></span>
<span id="cb26-705"><a href="#cb26-705"></a>:::</span>
<span id="cb26-706"><a href="#cb26-706"></a></span>
<span id="cb26-707"><a href="#cb26-707"></a>A pointer to an array would decay to a pointer to an <span class="in">`int`</span> for you. When</span>
<span id="cb26-708"><a href="#cb26-708"></a>the pointer goes out of scope, the destructor of <span class="in">`std::shared_ptr`</span> calls</span>
<span id="cb26-709"><a href="#cb26-709"></a><span class="in">`delete`</span> on <span class="in">`sptr`</span> and not <span class="in">`delete[]`</span>.</span>
<span id="cb26-710"><a href="#cb26-710"></a></span>
<span id="cb26-711"><a href="#cb26-711"></a>This is definitely a bug! We don't want people to be able to use CTAD</span>
<span id="cb26-712"><a href="#cb26-712"></a>here.</span>
<span id="cb26-713"><a href="#cb26-713"></a></span>
<span id="cb26-714"><a href="#cb26-714"></a>We would like to disable CTAD. Now, the question is how do we disable</span>
<span id="cb26-715"><a href="#cb26-715"></a>it? How do we make sure that it doesn't work.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>