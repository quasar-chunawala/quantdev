<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2024-11-10">

<title>quantdev.blog - Template programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">Roadmaps</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Template programming</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 10, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#an-overview-of-variadic-templates" id="toc-an-overview-of-variadic-templates" class="nav-link active" data-scroll-target="#an-overview-of-variadic-templates">An overview of variadic templates</a></li>
  <li><a href="#expanding-parameter-packs" id="toc-expanding-parameter-packs" class="nav-link" data-scroll-target="#expanding-parameter-packs">Expanding parameter packs</a>
  <ul class="collapse">
  <li><a href="#sizeof...pack" id="toc-sizeof...pack" class="nav-link" data-scroll-target="#sizeof...pack"><code>sizeof...(pack)</code></a></li>
  </ul></li>
  <li><a href="#implementing-getn-for-the-tuple" id="toc-implementing-getn-for-the-tuple" class="nav-link" data-scroll-target="#implementing-getn-for-the-tuple">Implementing <code>get&lt;N&gt;</code> for the tuple</a></li>
  <li><a href="#fold-expressions" id="toc-fold-expressions" class="nav-link" data-scroll-target="#fold-expressions">Fold Expressions</a></li>
  <li><a href="#idioms" id="toc-idioms" class="nav-link" data-scroll-target="#idioms">Idioms</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>C++11 introduced <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic">variadic templates</a> which permit functions to accept a variable number of arguments. They also permit template types such as <code>std::tuple</code> that can hold a variable number of elements. The main language mechanism enabling variadic templates is <em>parameter packs</em>, which hold an arbitrary number of values or types. Some things are easier to do with parameter packs - for instance passing the values they comprise to a function. Other tasks are a bit trickier to accomplish, such as iterating over a parameter pack or extracting specific elements. However, these things can generally be accomplished through various idioms, some more unwieldy then others.</p>
<p>Between C++11 and C++20, the language gained several improvements to variadic templates. Improvements to other features, such as concepts and lambdas, have also created new options for manipulating parameter packs in C++20. Ideally, cataloging these tricks make it easier for people to do what they need with variadic templates.</p>
<section id="an-overview-of-variadic-templates" class="level2">
<h2 class="anchored" data-anchor-id="an-overview-of-variadic-templates">An overview of variadic templates</h2>
<p>A <em>template parameter pack</em> is a template parameter that accepts zero or more template arguments. A <em>function parameter pack</em> is a function parameter that accepts zero or more function arguments. A variadic template is template that captures a <em>parameter pack</em> in its template arguments or function arguments. A parameter pack is captured by introducing an identifier prefixed by an ellipsis, as in <code>...X</code>. Once captured, a parameter pack can later be used in a <em>pattern</em> expanded by an ellipsis (<code>...</code>), generally to the right of the pattern, as in <code>X...</code>. Pack expansion is conceptually equivalent to having one copy of the pattern for each element of the parameter pack.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>T sum<span class="op">(</span>T x<span class="op">){</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>T sum<span class="op">(</span>T x<span class="op">,</span> Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">return</span> x <span class="op">+</span> sum<span class="op">&lt;</span>Args<span class="op">...&gt;(</span>args<span class="op">...);</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">{</span>   </span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="dt">double</span> result <span class="op">=</span> sum<span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"result = "</span> <span class="op">&lt;&lt;</span>  result<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/v1cM4anWY">Compiler Explorer</a></p>
<p>The <code>sum()</code> function takes one or more arguments. The first argument is always captured by the parameter <code>x</code> and the rest of the arguments are captured by the pack <code>...args</code> on line 9.</p>
</section>
<section id="expanding-parameter-packs" class="level2">
<h2 class="anchored" data-anchor-id="expanding-parameter-packs">Expanding parameter packs</h2>
<p>When using a variadic template, we often use a recursive logic with two overloads : one for the general case and one for ending the recursion. For instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>T min<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>T min<span class="op">(</span>T first<span class="op">,</span> Args<span class="op">...</span> rest<span class="op">){</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="cf">return</span> min<span class="op">(</span>first<span class="op">,</span> min<span class="op">(</span>rest<span class="op">...));</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> c <span class="op">=</span> <span class="dv">4</span><span class="op">,</span> d <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="dt">int</span> minValue <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    minValue <span class="op">=</span> min<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    minValue <span class="op">=</span> min<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    minValue <span class="op">=</span> min<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/qv8KfY7jr">Compiler Explorer</a></p>
<p>The below code snip is a minimalistic example of tuple. The first class is the primary template. The primary template tuple has two member variables : <code>first</code> of type <code>Type</code> and <code>rest</code> of type <code>Types...</code> . This means that a template of <code>N</code> elements will contain the first element, and another tuple; this second tuple in turn contains the second element and yet another tuple; so on and so forth.</p>
<p>A captured parameter pack must be used in a <em>pattern</em> that is expanded with an ellipsis (<code>...</code>). A <em>pattern</em> is a set of tokens containing the identifiers of one or more parameter packs. On line 11, we capture a parameter pack <code>rest</code> consisting of a sequence of values <code>rest[i]</code> each of type <code>Types[i]</code> for the i-th position in parameter pack <code>Types</code>. On line 13, we expand the pattern <code>rest</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// Variadic class templates and parameter pack expansion</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Type<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">struct</span> tuple<span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    Type <span class="va">first_</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    tuple<span class="op">&lt;</span>Types<span class="op">...&gt;</span> <span class="va">rest_</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>    tuple<span class="op">(</span>Type first<span class="op">,</span> Types<span class="op">...</span> rest<span class="op">)</span> </span>
<span id="cb3-12"><a href="#cb3-12"></a>        <span class="op">:</span> <span class="va">first_</span><span class="op">(</span>first<span class="op">)</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        <span class="op">,</span> <span class="va">rest_</span><span class="op">(</span>rest<span class="op">...)</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span class="op">{}</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="op">};</span></span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="kw">struct</span> tuple<span class="op">&lt;</span>T<span class="op">&gt;{</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    T <span class="va">first_</span><span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a>    tuple<span class="op">(</span>T first<span class="op">)</span> <span class="op">:</span> <span class="va">first_</span><span class="op">(</span>first<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="op">};</span></span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="op">{</span>   </span>
<span id="cb3-26"><a href="#cb3-26"></a>    tuple<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> x1<span class="op">(</span><span class="fl">3.0</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="fl">5.0</span><span class="op">);</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/cqsYjrYT8">Compiler Explorer</a></p>
<p>When a pattern contains more than one parameter pack, all packs must have the same length. This length determines the number of times the pattern is conceptually replicated in the expansion, once for each position in the expanded pack(s). Consider the following code snippet:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// An example with two parameter packs</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;...</span> C<span class="op">&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="dt">void</span> expand<span class="op">(</span>C<span class="op">...</span> c<span class="op">)</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="bu">std::</span>tuple<span class="op">&lt;</span>C<span class="op">...&gt;</span> tpl<span class="op">(</span>c<span class="op">...);</span></span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="at">const</span> <span class="dt">char</span> msg<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> C<span class="op">(</span><span class="bu">std::</span>toupper<span class="op">(</span>c<span class="op">))...,</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span> <span class="op">};</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="co">//Do something</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="op">{</span>   </span>
<span id="cb4-16"><a href="#cb4-16"></a>    expand<span class="op">(</span><span class="ch">'t'</span><span class="op">,</span><span class="ch">'e'</span><span class="op">,</span><span class="ch">'m'</span><span class="op">,</span><span class="ch">'p'</span><span class="op">,</span><span class="ch">'l'</span><span class="op">,</span><span class="ch">'a'</span><span class="op">,</span><span class="ch">'t'</span><span class="op">,</span><span class="ch">'e'</span><span class="op">,</span><span class="ch">'s'</span><span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On line 7, <code>tuple&lt;C...&gt;</code> expands the pack <code>C</code> in the <em>template-argument list</em>, while <code>tpl(c...)</code> expands <code>c</code> in an <em>initializer list</em> (which, not to be confused with <code>std::initializer_list</code> is the C++ grammar for comma-separated lists of expressions passed as arguments to function calls and constructors).</p>
<p>On line 9, we expand the pattern <code>C(std::toupper(c))</code> in another initializer list. This is an example of a pattern with two packs, <code>C</code> and <code>c</code>, both of which have the same length and are expanded in lockstep. (<code>std::toupper()</code> returns an <code>int</code> rather than a <code>char</code> so requires a cast).</p>
<section id="sizeof...pack" class="level3">
<h3 class="anchored" data-anchor-id="sizeof...pack"><code>sizeof...(pack)</code></h3>
<p>The number of arguments in a parameter pack can be retrieved at compile-time with the <a href="https://timsong-cpp.github.io/cppwp/n4868/expr.sizeof#4"><code>sizeof...</code></a> operator. This operator returns a <code>constexpr</code> value of the <code>std::size_t</code> type. Let’s see this in action:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">constexpr</span> <span class="kw">auto</span> get_type_sizes<span class="op">(</span>Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="cf">return</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>size_t<span class="op">,</span> <span class="kw">sizeof</span><span class="op">...(</span>Args<span class="op">)&gt;{</span><span class="kw">sizeof</span><span class="op">(</span>args<span class="op">)...};</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="kw">auto</span> sizes <span class="op">=</span> get_type_sizes<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">long</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;(</span><span class="ch">'a'</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="bu">L</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/h44x8KbMr">Compiler Explorer</a></p>
<p>In this snippet, <code>sizeof...(Args)</code> evaluates to <span class="math inline">\(4\)</span> at compile-time, while <code>sizeof(args)...</code> is expanded to the following comma-separated pack of arguments: <code>sizeof(char)</code>, <code>sizeof(int)</code>, <code>sizeof(long)</code> and <code>sizeof(double)</code>.</p>
<p>In most cases, an expanded pattern is conceptually equivalent to the number of copies of the pattern equal to the size of the parameter pack. Unless otherwise noted, a pattern is expanded by appending an ellipsis (<code>...</code>). Here is a list of <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5">contexts</a> in which a pattern can be expanded:</p>
<ul>
<li>Inside <em>template parameters</em> and <em>function parameters</em>, a pack expansion behaves like a comma separated list of patterns. An example in template parameters is the expansion of <code>T</code> in <code>inner</code> here:</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">struct</span> outer<span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">template</span> <span class="op">&lt;</span>T<span class="op">...</span> args<span class="op">&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">struct</span> inner<span class="op">{};</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="op">};</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a>outer<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span><span class="op">[</span><span class="dv">5</span><span class="op">]&gt;</span> a<span class="op">{};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>An example in function parameters is the expansion of <code>Args...</code>, when you call <code>foo</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dt">void</span> foo<span class="op">(</span>Args<span class="op">...</span> args<span class="op">){}</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>foo<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>foo<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="ch">'a'</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p>In <em>template argument lists</em> as in <code>std::tuple&lt;C...&gt;</code>, the pack expands to the equivalent of a comma separated list of template arguments.</p></li>
<li><p>In <em>function argument lists</em> when a captured parameter pack appears inside the parenthesis of a function call. The largest expression to the left of the ellipsis (<code>...</code>) is the pattern that is expanded.</p></li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>T step_it<span class="op">(</span>T value<span class="op">){</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="cf">return</span> value <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="op">}</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>T sum<span class="op">(</span>T x<span class="op">){</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>T sum<span class="op">(</span>T first<span class="op">,</span> T<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="cf">return</span> <span class="op">(</span>first <span class="op">+</span> sum<span class="op">(</span>args<span class="op">...));</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="dt">void</span> do_sums<span class="op">(</span>T<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="kw">auto</span> s1 <span class="op">=</span> sum<span class="op">(</span>args<span class="op">...);</span> </span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="co">// sum(1, 2, 3, 4)</span></span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="kw">auto</span> s2 <span class="op">=</span> sum<span class="op">(</span><span class="dv">42</span><span class="op">,</span> args<span class="op">...);</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="co">// sum(42, 1, 2, 3, 4)</span></span>
<span id="cb8-21"><a href="#cb8-21"></a></span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="kw">auto</span> s3 <span class="op">=</span> sum<span class="op">(</span>step_it<span class="op">(</span>args<span class="op">)...);</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="co">// sum(2, 3, 4, 5)</span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25"></a></span>
<span id="cb8-26"><a href="#cb8-26"></a>do_sums<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>In <em>base specifier lists</em>, to specify one base class for each member of a type parameter pack e.g.:</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Base<span class="op">...&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">struct</span> MyStruct <span class="op">:</span> Base<span class="op">...{</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    MyStruct<span class="op">();</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>When initializing base classes in a <strong>mem-initializer list</strong> in a class constructor, the pack expansion initializes a list of base classes based on a type parameter pack:</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Base<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">struct</span> MyStruct<span class="op">:</span> Base<span class="op">...{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="co">/* Default c'ctor */</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    MyStruct<span class="op">()</span> <span class="op">:</span> Base<span class="op">...()</span> <span class="op">{}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>    MyStruct<span class="op">(</span><span class="at">const</span> Base<span class="op">&amp;...</span> args<span class="op">)</span> <span class="op">:</span> Base<span class="op">{</span>args<span class="op">}...</span> <span class="op">{}</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>In initializer lists, the pack exmpansion is conceptually equivlent to a comma-separated list of instances of the pattern.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">struct</span> sum_wrapper<span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>    sum_wrapper<span class="op">(</span>Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>        result <span class="op">=</span> <span class="op">(...</span> <span class="op">+</span> args<span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="bu">std::</span>common_type_t<span class="op">&lt;</span>Args<span class="op">...&gt;</span> result<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">};</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="dt">void</span> parenthesized<span class="op">(</span>T<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>common_type_t<span class="op">&lt;</span>T<span class="op">...&gt;,</span><span class="kw">sizeof</span><span class="op">...(</span>T<span class="op">)&gt;</span> arr <span class="op">{</span>args<span class="op">...};</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="co">//std::array&lt;int, 4&gt; {1, 2, 3, 4}</span></span>
<span id="cb11-16"><a href="#cb11-16"></a></span>
<span id="cb11-17"><a href="#cb11-17"></a>    sum_wrapper sw1<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="co">//value = 1 + 2 + 3 + 4</span></span>
<span id="cb11-19"><a href="#cb11-19"></a></span>
<span id="cb11-20"><a href="#cb11-20"></a>    sum_wrapper sw2<span class="op">(++</span>args<span class="op">...);</span></span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="co">//value = 2 + 3 + 4 + 5</span></span>
<span id="cb11-22"><a href="#cb11-22"></a><span class="op">}</span></span>
<span id="cb11-23"><a href="#cb11-23"></a></span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb11-25"><a href="#cb11-25"></a><span class="op">{</span></span>
<span id="cb11-26"><a href="#cb11-26"></a>    parenthesized<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-28"><a href="#cb11-28"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/h157xf8Tq">Compiler Explorer</a></p>
<ul>
<li>In the context of deriving from a pack of base classes, it is useful to introduce names from the base classes into the definition of the derived class. Therefore, a pack expansion may also appear in a <code>using</code> declaration.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">struct</span> A<span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">void</span> execute<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"A::execute()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">};</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="kw">struct</span> B<span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="dt">void</span> execute<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"B::execute()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="op">};</span></span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="kw">struct</span> C<span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="dt">void</span> execute<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"C::execute()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="op">};</span></span>
<span id="cb12-15"><a href="#cb12-15"></a></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Bases<span class="op">&gt;</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="kw">struct</span> X <span class="op">:</span> <span class="kw">public</span> Bases<span class="op">...</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="op">{</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>    X<span class="op">(</span>Bases <span class="at">const</span><span class="op">&amp;</span> <span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> Bases<span class="op">(</span>args<span class="op">)...</span> <span class="op">{}</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>    <span class="kw">using</span> Bases<span class="op">::</span>execute<span class="op">...;</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>    <span class="co">// Conceptually equivalent to</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="co">// using A::f;</span></span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="co">// using B::f;</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>    <span class="co">// using C::f;</span></span>
<span id="cb12-25"><a href="#cb12-25"></a><span class="op">};</span></span>
<span id="cb12-26"><a href="#cb12-26"></a></span>
<span id="cb12-27"><a href="#cb12-27"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb12-28"><a href="#cb12-28"></a><span class="op">{</span></span>
<span id="cb12-29"><a href="#cb12-29"></a>    A a<span class="op">;</span> B b<span class="op">;</span> C c<span class="op">;</span> X x<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb12-30"><a href="#cb12-30"></a>    x<span class="op">.</span>A<span class="op">::</span>execute<span class="op">();</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>    x<span class="op">.</span>B<span class="op">::</span>execute<span class="op">();</span></span>
<span id="cb12-32"><a href="#cb12-32"></a>    x<span class="op">.</span>C<span class="op">::</span>execute<span class="op">();</span></span>
<span id="cb12-33"><a href="#cb12-33"></a></span>
<span id="cb12-34"><a href="#cb12-34"></a>    </span>
<span id="cb12-35"><a href="#cb12-35"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-36"><a href="#cb12-36"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/KMTjxonG5">Compiler Explorer</a></p>
<ul>
<li><em>Lambda Captures</em> - The capture clause of a lambda expression may contain a pack expansion.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="bu">std::</span>common_type_t<span class="op">&lt;</span>Args<span class="op">...&gt;</span> add<span class="op">(</span>Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="cf">return</span> <span class="op">(...</span> <span class="op">+</span> args<span class="op">);</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="dt">void</span> captures<span class="op">(</span>T<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="kw">auto</span> l <span class="op">=</span> <span class="op">[</span>args<span class="op">...]{</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>        <span class="cf">return</span> add<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>    <span class="op">};</span></span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a>    l<span class="op">();</span></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="op">}</span></span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="op">{</span></span>
<span id="cb13-19"><a href="#cb13-19"></a>    captures<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-21"><a href="#cb13-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><em>Fold expressions</em> - These are similar to left fold and right fold in functional programming.</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> T<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="dt">int</span> sum<span class="op">(</span>T<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="cf">return</span> <span class="op">(</span>args <span class="op">+</span> <span class="op">...);</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A pattern may itself contain an expanded parameter pack, in which case there is no need for the inner and outer packs to contain the same number of elements. The expanded inner pack simply becomes a part of the pattern around the outer pack. For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="bu">std::</span>common_type_t<span class="op">&lt;</span>Args<span class="op">...&gt;</span> sum<span class="op">(</span>Args<span class="op">...</span> il<span class="op">){</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="cf">return</span> <span class="op">(...</span> <span class="op">+</span> il<span class="op">);</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">...</span> N<span class="op">&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="kw">struct</span> Nested_sum<span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="dt">int</span> nested_sum<span class="op">(</span>Args<span class="op">...</span> args<span class="op">){</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>        <span class="cf">return</span> sum<span class="op">(</span>sum<span class="op">(</span>N<span class="op">...,</span>args<span class="op">)...);</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="op">}</span></span>
<span id="cb15-15"><a href="#cb15-15"></a><span class="op">};</span></span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="op">{</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>    Nested_sum<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">&gt;</span> ns<span class="op">{};</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>    <span class="dt">int</span> result <span class="op">=</span> ns<span class="op">.</span>nested_sum<span class="op">(</span><span class="dv">100</span><span class="op">,</span> <span class="dv">200</span><span class="op">);</span></span>
<span id="cb15-20"><a href="#cb15-20"></a>    <span class="co">// Equivalent to : sum(sum(1, 2, 100), sum(1, 2, 200))</span></span>
<span id="cb15-21"><a href="#cb15-21"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-22"><a href="#cb15-22"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/eT6xdq667">Compiler Explorer</a></p>
</section>
</section>
<section id="implementing-getn-for-the-tuple" class="level2">
<h2 class="anchored" data-anchor-id="implementing-getn-for-the-tuple">Implementing <code>get&lt;N&gt;</code> for the tuple</h2>
<p>We can implement <code>get&lt;N&gt;</code> that takes a tuple as an argument and returns a reference to the element at the index <code>n</code>. Its prototype could look like the following:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> n<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span>n<span class="op">,</span> Ts<span class="op">...&gt;::</span><span class="dt">value_type</span><span class="op">&amp;</span> get<span class="op">(</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span> t<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The template arguments are the index and a parameter pack of the tuple types. Its implementation, however, requires some helper types. First, we need to know what the type of the element is at the <code>n</code>-th index. This can be done with the help of the following <code>nth_type</code> variadic class template:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> n<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">struct</span> <span class="dt">nth_type</span> <span class="op">:</span> <span class="dt">nth_type</span><span class="op">&lt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">,</span>Ts<span class="op">...&gt;{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="op">};</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">struct</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span>T<span class="op">,</span>Ts<span class="op">...&gt;{</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Again, we have a primary template that uses recursive inheritance, and the specialization for the index <code>0</code> (which is the head of the list of templates). This type is only used as a mechanism for determining the type of a tuple element. We need another variadic class template for retrieving the value.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> n<span class="op">&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> getter<span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="at">static</span> <span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span>n<span class="op">,</span> Ts<span class="op">...&gt;::</span><span class="dt">value_type</span><span class="op">&amp;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    get<span class="op">(</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span> t<span class="op">){</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>        <span class="cf">return</span> getter<span class="op">&lt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">&gt;::</span>get<span class="op">(</span>t<span class="op">.</span><span class="va">rest_</span><span class="op">);</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="op">}</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="op">};</span></span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="kw">struct</span> getter<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;{</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="at">static</span> T<span class="op">&amp;</span> get<span class="op">(</span>tuple<span class="op">&lt;</span>T<span class="op">,</span> Ts<span class="op">...&gt;&amp;</span> t<span class="op">){</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>        <span class="cf">return</span> t<span class="op">.</span><span class="va">first_</span><span class="op">;</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>    <span class="op">}</span></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With all these defined, we can now provide an implementation for the helper variadic function template <code>get</code>. This implementation relies on the <code>getter</code> class template and calls the <code>get</code> variadic function template.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> n<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span>n<span class="op">,</span> Ts<span class="op">...&gt;::</span><span class="dt">value_type</span> <span class="op">&amp;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>get<span class="op">(</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span> t<span class="op">){</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="cf">return</span> getter<span class="op">&lt;</span>n<span class="op">&gt;::</span>get<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://godbolt.org/z/bGq8E85Kv">Compiler Explorer</a></p>
<p>Analysing the example above in <a href="https://cppinsights.io/s/36b02d29">cppinsights.io</a> will be very illuminating. Here’s the listing:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">/*************************************************************************************</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="co"> * </span><span class="al">NOTE</span><span class="co">: This an educational hand-rolled transformation. Things can be incorrect or  *</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="co"> * buggy.                                                                            *</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co"> *************************************************************************************/</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">struct</span> tuple</span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>  T <span class="va">first_</span><span class="op">;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>  tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="va">rest_</span><span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>  <span class="kw">inline</span> tuple<span class="op">(</span>T first<span class="op">,</span> Ts<span class="op">...</span> rest<span class="op">)</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>  <span class="op">:</span> <span class="va">first_</span><span class="op">{</span>first<span class="op">}</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>  <span class="op">,</span> <span class="va">rest_</span><span class="op">{</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;(</span>rest<span class="op">...</span> <span class="op">)}</span></span>
<span id="cb20-15"><a href="#cb20-15"></a>  <span class="op">{</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>  <span class="op">}</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>  </span>
<span id="cb20-18"><a href="#cb20-18"></a><span class="op">};</span></span>
<span id="cb20-19"><a href="#cb20-19"></a></span>
<span id="cb20-20"><a href="#cb20-20"></a><span class="co">/* First instantiated from: insights.cpp:6 */</span></span>
<span id="cb20-21"><a href="#cb20-21"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb20-22"><a href="#cb20-22"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb20-23"><a href="#cb20-23"></a><span class="kw">struct</span> tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="op">{</span></span>
<span id="cb20-25"><a href="#cb20-25"></a>  <span class="dt">int</span> <span class="va">first_</span><span class="op">;</span></span>
<span id="cb20-26"><a href="#cb20-26"></a>  tuple<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">rest_</span><span class="op">;</span></span>
<span id="cb20-27"><a href="#cb20-27"></a>  <span class="kw">inline</span> tuple<span class="op">(</span><span class="dt">int</span> first<span class="op">,</span> <span class="dt">double</span> __rest1<span class="op">)</span></span>
<span id="cb20-28"><a href="#cb20-28"></a>  <span class="op">:</span> <span class="va">first_</span><span class="op">{</span>first<span class="op">}</span></span>
<span id="cb20-29"><a href="#cb20-29"></a>  <span class="op">,</span> <span class="va">rest_</span><span class="op">{</span>tuple<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>__rest1<span class="op">)}</span></span>
<span id="cb20-30"><a href="#cb20-30"></a>  <span class="op">{</span></span>
<span id="cb20-31"><a href="#cb20-31"></a>  <span class="op">}</span></span>
<span id="cb20-32"><a href="#cb20-32"></a>  </span>
<span id="cb20-33"><a href="#cb20-33"></a><span class="op">};</span></span>
<span id="cb20-34"><a href="#cb20-34"></a></span>
<span id="cb20-35"><a href="#cb20-35"></a><span class="pp">#endif</span></span>
<span id="cb20-36"><a href="#cb20-36"></a><span class="co">/* First instantiated from: insights.cpp:6 */</span></span>
<span id="cb20-37"><a href="#cb20-37"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb20-38"><a href="#cb20-38"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb20-39"><a href="#cb20-39"></a><span class="kw">struct</span> tuple<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb20-40"><a href="#cb20-40"></a><span class="op">{</span></span>
<span id="cb20-41"><a href="#cb20-41"></a>  <span class="dt">double</span> <span class="va">first_</span><span class="op">;</span></span>
<span id="cb20-42"><a href="#cb20-42"></a>  <span class="kw">inline</span> tuple<span class="op">(</span><span class="dt">double</span> first<span class="op">)</span></span>
<span id="cb20-43"><a href="#cb20-43"></a>  <span class="op">:</span> <span class="va">first_</span><span class="op">{</span>first<span class="op">}</span></span>
<span id="cb20-44"><a href="#cb20-44"></a>  <span class="op">{</span></span>
<span id="cb20-45"><a href="#cb20-45"></a>  <span class="op">}</span></span>
<span id="cb20-46"><a href="#cb20-46"></a>  </span>
<span id="cb20-47"><a href="#cb20-47"></a><span class="op">};</span></span>
<span id="cb20-48"><a href="#cb20-48"></a></span>
<span id="cb20-49"><a href="#cb20-49"></a><span class="pp">#endif</span></span>
<span id="cb20-50"><a href="#cb20-50"></a><span class="co">/* First instantiated from: insights.cpp:53 */</span></span>
<span id="cb20-51"><a href="#cb20-51"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb20-52"><a href="#cb20-52"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb20-53"><a href="#cb20-53"></a><span class="kw">struct</span> tuple<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb20-54"><a href="#cb20-54"></a><span class="op">{</span></span>
<span id="cb20-55"><a href="#cb20-55"></a>  <span class="dt">char</span> <span class="va">first_</span><span class="op">;</span></span>
<span id="cb20-56"><a href="#cb20-56"></a>  tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> <span class="va">rest_</span><span class="op">;</span></span>
<span id="cb20-57"><a href="#cb20-57"></a>  <span class="kw">inline</span> tuple<span class="op">(</span><span class="dt">char</span> first<span class="op">,</span> <span class="dt">int</span> __rest1<span class="op">,</span> <span class="dt">double</span> __rest2<span class="op">)</span></span>
<span id="cb20-58"><a href="#cb20-58"></a>  <span class="op">:</span> <span class="va">first_</span><span class="op">{</span>first<span class="op">}</span></span>
<span id="cb20-59"><a href="#cb20-59"></a>  <span class="op">,</span> <span class="va">rest_</span><span class="op">{</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;(</span>__rest1<span class="op">,</span> __rest2<span class="op">)}</span></span>
<span id="cb20-60"><a href="#cb20-60"></a>  <span class="op">{</span></span>
<span id="cb20-61"><a href="#cb20-61"></a>  <span class="op">}</span></span>
<span id="cb20-62"><a href="#cb20-62"></a>  </span>
<span id="cb20-63"><a href="#cb20-63"></a><span class="op">};</span></span>
<span id="cb20-64"><a href="#cb20-64"></a></span>
<span id="cb20-65"><a href="#cb20-65"></a><span class="pp">#endif</span></span>
<span id="cb20-66"><a href="#cb20-66"></a></span>
<span id="cb20-67"><a href="#cb20-67"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb20-68"><a href="#cb20-68"></a><span class="kw">struct</span> tuple<span class="op">&lt;</span>T<span class="op">&gt;</span></span>
<span id="cb20-69"><a href="#cb20-69"></a><span class="op">{</span></span>
<span id="cb20-70"><a href="#cb20-70"></a>  T <span class="va">first_</span><span class="op">;</span></span>
<span id="cb20-71"><a href="#cb20-71"></a>  <span class="kw">inline</span> tuple<span class="op">(</span>T first<span class="op">)</span></span>
<span id="cb20-72"><a href="#cb20-72"></a>  <span class="op">:</span> <span class="va">first_</span><span class="op">(</span>first<span class="op">)</span></span>
<span id="cb20-73"><a href="#cb20-73"></a>  <span class="op">{</span></span>
<span id="cb20-74"><a href="#cb20-74"></a>  <span class="op">}</span></span>
<span id="cb20-75"><a href="#cb20-75"></a>  </span>
<span id="cb20-76"><a href="#cb20-76"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>tuple&lt;char, int, double&gt;</code> contains an <code>int</code> and a <code>tuple&lt;int, double&gt;</code>, which contains a <code>int</code> and <code>tuple&lt;double&gt;</code>, which in turn contains a <code>double</code> value.</p>
<p>Next, we have the <code>nth_type</code> class template, for which, again, we have a primary template and several specializations, as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> n<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">struct</span> <span class="dt">nth_type</span> <span class="op">:</span> <span class="kw">public</span> <span class="dt">nth_type</span><span class="op">&lt;</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> Ts<span class="op">...&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="op">};</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="co">/* First instantiated from: insights.cpp:19 */</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="kw">struct</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> <span class="op">:</span> <span class="kw">public</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="op">};</span></span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="pp">#endif</span></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="co">/* First instantiated from: insights.cpp:19 */</span></span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="kw">struct</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb21-19"><a href="#cb21-19"></a><span class="op">{</span></span>
<span id="cb21-20"><a href="#cb21-20"></a>  <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> <span class="dt">double</span><span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21"></a><span class="op">};</span></span>
<span id="cb21-22"><a href="#cb21-22"></a></span>
<span id="cb21-23"><a href="#cb21-23"></a><span class="pp">#endif</span></span>
<span id="cb21-24"><a href="#cb21-24"></a><span class="co">/* First instantiated from: insights.cpp:45 */</span></span>
<span id="cb21-25"><a href="#cb21-25"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb21-26"><a href="#cb21-26"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb21-27"><a href="#cb21-27"></a><span class="kw">struct</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">2</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> <span class="op">:</span> <span class="kw">public</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb21-28"><a href="#cb21-28"></a><span class="op">{</span></span>
<span id="cb21-29"><a href="#cb21-29"></a><span class="op">};</span></span>
<span id="cb21-30"><a href="#cb21-30"></a></span>
<span id="cb21-31"><a href="#cb21-31"></a><span class="pp">#endif</span></span>
<span id="cb21-32"><a href="#cb21-32"></a></span>
<span id="cb21-33"><a href="#cb21-33"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb21-34"><a href="#cb21-34"></a><span class="kw">struct</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> Ts<span class="op">...&gt;</span></span>
<span id="cb21-35"><a href="#cb21-35"></a><span class="op">{</span></span>
<span id="cb21-36"><a href="#cb21-36"></a>  <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb21-37"><a href="#cb21-37"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>nth_type&lt;2, char, int, double&gt;</code> specialization is derived from <code>nth_type&lt;1, int, double&gt;</code> which in turn is derived from <code>nth_type&lt;0, double&gt;</code>, which is the last class in the base hierarchy.</p>
<p>The <code>nth_type</code> structure is used as the return type in the <code>getter</code> helper class template, which is instantiated as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">/* First instantiated from: insights.cpp:32 */</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="kw">struct</span> getter<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>  <span class="at">static</span> <span class="kw">inline</span> <span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> Ts<span class="op">...&gt;::</span><span class="dt">value_type</span> <span class="op">&amp;</span> get<span class="op">(</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="op">&amp;</span> t<span class="op">);</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>  </span>
<span id="cb22-9"><a href="#cb22-9"></a>  <span class="co">/* First instantiated from: insights.cpp:32 */</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>  <span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>  <span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>  <span class="at">static</span> <span class="kw">inline</span> <span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;::</span><span class="dt">value_type</span> <span class="op">&amp;</span> get<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;(</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>  <span class="op">{</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>    <span class="cf">return</span> getter<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;::</span>get<span class="op">(</span>t<span class="op">.</span><span class="va">rest_</span><span class="op">);</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>  <span class="op">}</span></span>
<span id="cb22-16"><a href="#cb22-16"></a>  <span class="pp">#endif</span></span>
<span id="cb22-17"><a href="#cb22-17"></a>  </span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="op">};</span></span>
<span id="cb22-19"><a href="#cb22-19"></a></span>
<span id="cb22-20"><a href="#cb22-20"></a><span class="pp">#endif</span></span>
<span id="cb22-21"><a href="#cb22-21"></a><span class="co">/* First instantiated from: insights.cpp:47 */</span></span>
<span id="cb22-22"><a href="#cb22-22"></a><span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb22-23"><a href="#cb22-23"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-24"><a href="#cb22-24"></a><span class="kw">struct</span> getter<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span></span>
<span id="cb22-25"><a href="#cb22-25"></a><span class="op">{</span></span>
<span id="cb22-26"><a href="#cb22-26"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb22-27"><a href="#cb22-27"></a>  <span class="at">static</span> <span class="kw">inline</span> <span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">2</span><span class="op">,</span> Ts<span class="op">...&gt;::</span><span class="dt">value_type</span> <span class="op">&amp;</span> get<span class="op">(</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="op">&amp;</span> t<span class="op">);</span></span>
<span id="cb22-28"><a href="#cb22-28"></a>  </span>
<span id="cb22-29"><a href="#cb22-29"></a>  <span class="co">/* First instantiated from: insights.cpp:47 */</span></span>
<span id="cb22-30"><a href="#cb22-30"></a>  <span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb22-31"><a href="#cb22-31"></a>  <span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-32"><a href="#cb22-32"></a>  <span class="at">static</span> <span class="kw">inline</span> <span class="kw">typename</span> <span class="dt">nth_type</span><span class="op">&lt;</span><span class="dv">2</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;::</span><span class="dt">value_type</span> <span class="op">&amp;</span> get<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;(</span>tuple<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb22-33"><a href="#cb22-33"></a>  <span class="op">{</span></span>
<span id="cb22-34"><a href="#cb22-34"></a>    <span class="cf">return</span> getter<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;::</span>get<span class="op">(</span>t<span class="op">.</span><span class="va">rest_</span><span class="op">);</span></span>
<span id="cb22-35"><a href="#cb22-35"></a>  <span class="op">}</span></span>
<span id="cb22-36"><a href="#cb22-36"></a>  <span class="pp">#endif</span></span>
<span id="cb22-37"><a href="#cb22-37"></a>  </span>
<span id="cb22-38"><a href="#cb22-38"></a><span class="op">};</span></span>
<span id="cb22-39"><a href="#cb22-39"></a></span>
<span id="cb22-40"><a href="#cb22-40"></a><span class="pp">#endif</span></span>
<span id="cb22-41"><a href="#cb22-41"></a></span>
<span id="cb22-42"><a href="#cb22-42"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-43"><a href="#cb22-43"></a><span class="kw">struct</span> getter<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span></span>
<span id="cb22-44"><a href="#cb22-44"></a><span class="op">{</span></span>
<span id="cb22-45"><a href="#cb22-45"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb22-46"><a href="#cb22-46"></a>  <span class="at">static</span> <span class="kw">inline</span> T <span class="op">&amp;</span> get<span class="op">(</span>tuple<span class="op">&lt;</span>T<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb22-47"><a href="#cb22-47"></a>  <span class="op">{</span></span>
<span id="cb22-48"><a href="#cb22-48"></a>    <span class="cf">return</span> t<span class="op">.</span><span class="va">first_</span><span class="op">;</span></span>
<span id="cb22-49"><a href="#cb22-49"></a>  <span class="op">}</span></span>
<span id="cb22-50"><a href="#cb22-50"></a>  </span>
<span id="cb22-51"><a href="#cb22-51"></a>  <span class="co">/* First instantiated from: insights.cpp:32 */</span></span>
<span id="cb22-52"><a href="#cb22-52"></a>  <span class="pp">#ifdef INSIGHTS_USE_TEMPLATE</span></span>
<span id="cb22-53"><a href="#cb22-53"></a>  <span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb22-54"><a href="#cb22-54"></a>  <span class="at">static</span> <span class="kw">inline</span> <span class="dt">double</span> <span class="op">&amp;</span> get<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>tuple<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb22-55"><a href="#cb22-55"></a>  <span class="op">{</span></span>
<span id="cb22-56"><a href="#cb22-56"></a>    <span class="cf">return</span> t<span class="op">.</span><span class="va">first_</span><span class="op">;</span></span>
<span id="cb22-57"><a href="#cb22-57"></a>  <span class="op">}</span></span>
<span id="cb22-58"><a href="#cb22-58"></a>  <span class="pp">#endif</span></span>
<span id="cb22-59"><a href="#cb22-59"></a>  </span>
<span id="cb22-60"><a href="#cb22-60"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We see the use of the keyword <code>typename</code> to prefix the <code>nth_type&lt;N, Ts...&gt;::value_type</code> which is a <strong>dependent type</strong>. In C++ 20, this is however no longer necessary.</p>
<p>Because implementing variadic templates is often verbose and can be cumbersome, the C++17 added <em>fold expressions</em>.</p>
</section>
<section id="fold-expressions" class="level2">
<h2 class="anchored" data-anchor-id="fold-expressions">Fold Expressions</h2>
<p>A special form of pack expansions is <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#10">folds</a> introduced in C++17. Above, we showed a function <code>sum</code> that summed a set of integers. This function can be implemented far more concisely with a fold:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="kw">auto</span><span class="op">...</span> i<span class="op">){</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="cf">return</span> <span class="op">(...</span> <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let <span class="math inline">\(p_1,\ldots,p_n\)</span> be the instances of the parameter pack <span class="math inline">\(p\)</span>. Let <span class="math inline">\(\bigoplus\)</span> stand for any binary operator in the C++ grammar.</p>
<p>A <strong>binary left fold</strong> has the form <span class="math inline">\((e \bigoplus \ldots \bigoplus p)\)</span> and is equivalent to <span class="math inline">\((((e \bigoplus p_1) \bigoplus p_2)\ldots ) \bigoplus p_n\)</span>.</p>
<p>A <strong>unary left fold</strong> has the form <span class="math inline">\((\ldots \bigoplus p)\)</span> and is equivalent to <span class="math inline">\((((p_1 \bigoplus p_2)\bigoplus p_3) \ldots )\bigoplus p_n\)</span>.</p>
<p>A <strong>binary right fold</strong> has the form <span class="math inline">\((p \bigoplus \ldots \bigoplus e)\)</span> and is equivalent to <span class="math inline">\(p_1 \bigoplus (\ldots (p_{n-1} \bigoplus (p_n \bigoplus e)))\)</span>.</p>
<p>A <strong>binary right fold</strong> has the form <span class="math inline">\((p \bigoplus \ldots \bigoplus p_n)\)</span> and is equivalent to <span class="math inline">\(p_1 \bigoplus (p_2 \bigoplus (\ldots \bigoplus p_n))\)</span>.</p>
<p>In the above expressions, <span class="math inline">\(e\)</span> stands for the initial value.</p>
</section>
<section id="idioms" class="level2">
<h2 class="anchored" data-anchor-id="idioms">Idioms</h2>
<p>Below is a collection of idioms for working with parameter packs.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>