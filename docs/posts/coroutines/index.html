<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Quasar">
<meta name="dcterms.date" content="2025-11-12">

<title>quantdev.blog - Coroutines</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap')
</style>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9993009899870547" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../.././noBgColor.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">quantdev.blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sell_side_quant_critical_path.html" rel="" target="">
 <span class="menu-text">Sell-side Quant</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../roadmap.html" rel="" target="">
 <span class="menu-text">C++ Roadmap</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://patreon.com/u59411143?utm_medium=unknown&amp;utm_source=join_link&amp;utm_campaign=creatorshare_creator&amp;utm_content=copyLink" rel="" target=""><i class="bi bi-patreon" role="img">
</i> 
 <span class="menu-text">Become a patreon</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/quasar-chunawala" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://linkedin.com/in/quasar-chunawala" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Coroutines</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">C++</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Quasar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 12, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#coroutines" id="toc-coroutines" class="nav-link active" data-scroll-target="#coroutines">Coroutines</a>
  <ul class="collapse">
  <li><a href="#a-simple-example" id="toc-a-simple-example" class="nav-link" data-scroll-target="#a-simple-example">A simple example</a></li>
  <li><a href="#the-coroutine-return-type" id="toc-the-coroutine-return-type" class="nav-link" data-scroll-target="#the-coroutine-return-type">The coroutine return type</a></li>
  <li><a href="#how-to-turn-a-function-into-a-coroutine" id="toc-how-to-turn-a-function-into-a-coroutine" class="nav-link" data-scroll-target="#how-to-turn-a-function-into-a-coroutine">How to turn a function into a coroutine?</a></li>
  <li><a href="#use-cases-for-coroutines" id="toc-use-cases-for-coroutines" class="nav-link" data-scroll-target="#use-cases-for-coroutines">Use-cases for coroutines</a></li>
  </ul></li>
  <li><a href="#the-simplest-coroutine" id="toc-the-simplest-coroutine" class="nav-link" data-scroll-target="#the-simplest-coroutine">The simplest coroutine</a>
  <ul class="collapse">
  <li><a href="#the-promise_type" id="toc-the-promise_type" class="nav-link" data-scroll-target="#the-promise_type">The <code>promise_type</code></a></li>
  <li><a href="#implementing-the-promise_type" id="toc-implementing-the-promise_type" class="nav-link" data-scroll-target="#implementing-the-promise_type">Implementing the <code>promise_type</code></a></li>
  </ul></li>
  <li><a href="#a-yielding-coroutine" id="toc-a-yielding-coroutine" class="nav-link" data-scroll-target="#a-yielding-coroutine">A yielding coroutine</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="coroutines" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="coroutines">Coroutines</h2>
<p>You’ve likely heard about this new C++20 feature, <strong>coroutines</strong>. I think that this is a really important subject and there are several cool use-cases for coroutines. A <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a> in the simplest terms is just a function that you can pause in the middle. Imagine that you are executing a function top-down and then just at some point in between, you’d like to say, I am going to hit the pause button here; going to return the control back to the caller. At a later point the caller will decide to resume the execution of the function right where you left off. Unlike a function therefore, coroutines are always stateful - you atleast need to remember where you left off in the function body. Usually, you also need to remember more than this; you need to remember the values of all of the local variables were at the point where you paused. As a consequence, <em>you can think of the coroutine you are calling not as a function in the classical sense of the term, but more like a factory function that actually returns the coroutine object back to you. And this coroutine object is the one that holds all the state, and which you can resume to continue the computation at a future time</em>.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">%</span>load_ext itikz</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Coroutines can simplify our code! Coroutines are a great tool, when it comes to implementing parsers.</p>
<p>Compared to functions, the control flow of coroutines looks as follows:</p>
<div class="text-center">
<div class="cell" data-execution_count="2">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows.meta <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb2-2"><a href="#cb2-2"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb2-3"><a href="#cb2-3"></a>\draw[blue, rounded corners] (<span class="dv">0</span>,<span class="dv">0</span>) rectangle (<span class="dv">3</span>,<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>\node(A) at (<span class="fl">1.5</span>,<span class="fl">4.75</span>) {Caller}<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>\node(B) at (<span class="fl">1.5</span>,<span class="fl">3.50</span>) {}<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>\node(C) at (<span class="fl">1.5</span>,<span class="fl">3.20</span>) {}<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>\node(call) at (<span class="fl">2.20</span>,<span class="fl">4.20</span>) {call}<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>\node(D) at (<span class="fl">1.5</span>,<span class="fl">0.20</span>) {}<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>\node(F) at (<span class="fl">5.5</span>,<span class="fl">4.75</span>) {Function}<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>\node(Func) at (<span class="fl">5.55</span>,<span class="fl">4.50</span>) {}<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>\node(Return) at (<span class="fl">5.55</span>,<span class="fl">0.25</span>) {}<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>\node(return_back) at (<span class="fl">6.2</span>,<span class="fl">0.50</span>) {\texttt{<span class="cf">return</span>}}<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (A) <span class="op">--</span> (B)<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (B) <span class="op">--</span> (Func)<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (Func) <span class="op">--</span> (Return)<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (Return) <span class="op">--</span> (C)<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (C) <span class="op">--</span> (D)<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>\draw[blue, rounded corners] (<span class="dv">4</span>,<span class="dv">0</span>) rectangle (<span class="dv">7</span>,<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>\end{tikzpicture}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="2">
<p><img src="index_files/figure-html/cell-3-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Fig. Functions - control flow</p>
</div>
<div class="text-center">
<div class="cell" data-execution_count="3">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">%%</span>itikz <span class="op">--</span>temp<span class="op">-</span><span class="bu">dir</span> <span class="op">--</span>tex<span class="op">-</span>packages<span class="op">=</span>tikz <span class="op">--</span>tikz<span class="op">-</span>libraries<span class="op">=</span>arrows.meta <span class="op">--</span>implicit<span class="op">-</span>standalone</span>
<span id="cb3-2"><a href="#cb3-2"></a>\begin{tikzpicture}[scale<span class="op">=</span><span class="fl">1.5</span>]</span>
<span id="cb3-3"><a href="#cb3-3"></a>\draw[blue, rounded corners] (<span class="dv">0</span>,<span class="dv">0</span>) rectangle (<span class="dv">3</span>,<span class="dv">7</span>)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>\node(F) at (<span class="fl">5.5</span>,<span class="fl">6.75</span>) {Coroutine}<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>\node(A) at (<span class="fl">1.5</span>,<span class="fl">6.75</span>) {Caller}<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>\node(B) at (<span class="fl">1.5</span>,<span class="fl">5.50</span>) {}<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>\node(coro_A) at (<span class="fl">5.55</span>,<span class="fl">6.50</span>) {}<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>\node(coro_B) at (<span class="fl">5.55</span>,<span class="fl">5.20</span>) {}<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>\node(suspend_1) at (<span class="fl">4.75</span>,<span class="fl">5.70</span>) {suspend}<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>\node(coyield_1) at (<span class="fl">6.50</span>,<span class="fl">5.25</span>) {\texttt{co\_yield}}<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>\node(call_1) at (<span class="fl">2.20</span>,<span class="fl">6.20</span>) {call}<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>\node(C) at (<span class="fl">1.5</span>,<span class="fl">5.20</span>) {}<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>\node(D) at (<span class="fl">1.5</span>,<span class="fl">3.70</span>) {}<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>\node(coro_C) at (<span class="fl">5.55</span>,<span class="fl">3.70</span>) {}<span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>\node(resume_1) at (<span class="fl">4.75</span>,<span class="fl">4.10</span>) {resume}<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>\node(coro_D) at (<span class="fl">5.55</span>,<span class="fl">2.20</span>) {}<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>\node(suspend_2) at (<span class="fl">4.75</span>,<span class="fl">2.70</span>) {suspend}<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>\node(coyield_2) at (<span class="fl">6.50</span>,<span class="fl">2.25</span>) {\texttt{co\_yield}}<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>\node(E) at (<span class="fl">1.5</span>, <span class="fl">2.20</span>) {}<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>\node(F) at (<span class="fl">1.5</span>, <span class="fl">1.25</span>) {}<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>\node(resume_2) at (<span class="fl">4.75</span>,<span class="fl">1.55</span>) {resume}<span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>\node(coro_F) at (<span class="fl">5.55</span>, <span class="fl">1.25</span>) {}<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>\node(coro_G) at (<span class="fl">5.55</span>, <span class="fl">0.25</span>) {}<span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>\node(return_back) at (<span class="fl">6.2</span>,<span class="fl">0.25</span>) {\texttt{co\_return}}<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>\node(H) at (<span class="fl">1.5</span>, <span class="fl">0.25</span>) {}<span class="op">;</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (A) <span class="op">--</span> (B)<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (B) <span class="op">--</span> (coro_A)<span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_A) <span class="op">--</span> (coro_B)<span class="op">;</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_B) <span class="op">--</span> (C)<span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (C) <span class="op">--</span> (D)<span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (D) <span class="op">--</span> (coro_C)<span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_C) <span class="op">--</span> (coro_D)<span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_D) <span class="op">--</span> (E)<span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (E) <span class="op">--</span> (F)<span class="op">;</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (F) <span class="op">--</span> (coro_F)<span class="op">;</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_F) <span class="op">--</span> (coro_G)<span class="op">;</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>\draw[dashed, <span class="op">-</span>{Stealth[length<span class="op">=</span><span class="dv">3</span><span class="er">mm</span>]}] (coro_G) <span class="op">--</span> (H)<span class="op">;</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>\draw[blue, rounded corners] (<span class="dv">4</span>,<span class="dv">0</span>) rectangle (<span class="dv">7</span>,<span class="dv">7</span>)<span class="op">;</span></span>
<span id="cb3-39"><a href="#cb3-39"></a>\end{tikzpicture}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="3">
<p><img src="index_files/figure-html/cell-4-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Fig. Coroutines - control flow</p>
</div>
<p>Coroutine frames (state of all the local variables at the point where you paused) may be stored on the stack or on the dynamic heap. C++ implements the latter approach - stackless coroutines.</p>
<p>When using coroutines, we are talking about cooperative multi-tasking. As a quick 101, in preemptive multitasking, a special hardware timer interrupt is sent to the CPU periodically, the register state of the currently running process is saved to the main memory (in a data-structure called the process context) and the OS kernel acquires control of the CPU. The OS scheduler uses a scheduling policy such as round-robin to schedule another process from the process queue, copies its context from main memory to the CPU registers and transfers control to it. This is called a context switch. In cooperative multitasking, each process/thread, once running decides for how long to keep the CPU, and (crucially) when it is time to give it up so that another thread can use it.</p>
<section id="a-simple-example" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="a-simple-example">A simple example</h3>
<p>Let’s start with a simple example. Let’s say, you want to compute the Fibonacci sequence. First thing, that you’d do, is code up a function <code>fibo(int)</code> that returns a sequence in a vector.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// Returns a vector containing the </span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">// first n elements of the Fibonacci </span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">// series: </span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">// 1, 1, 2, 3, 5, 8, 13, 21, ...</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> fibo<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> results<span class="op">{};</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="dt">int</span> a_prev<span class="op">{</span><span class="dv">1</span><span class="op">},</span> a_curr<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="dt">int</span> a_next<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    results<span class="op">.</span>push_back<span class="op">(</span>a_prev<span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    results<span class="op">.</span>push_back<span class="op">(</span>a_curr<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;++</span>i<span class="op">)</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>        a_next <span class="op">=</span> a_prev <span class="op">+</span> a_curr<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>        results<span class="op">.</span>push_back<span class="op">(</span>a_next<span class="op">);</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>        a_prev <span class="op">=</span> a_curr<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>        a_curr <span class="op">=</span> a_next<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="cf">return</span> results<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This naive implementation has a number of disadvantages. For example, this function will always require <span class="math inline">\(O(n)\)</span> storage. Fibonacci has a simple recursive equation, but if I have a complex computation, and I am only ever processing the numbers sequentially one at a time, then it makes no sense to pay for the entire <span class="math inline">\(O(n)\)</span> storage. Another problem is that, if you are dealing with an infinite range, then it becomes a lot harder to handle.</p>
<p>A different way of implementing this would be as follows. Instead of our function returning a range in a <code>vector</code>, we are just going to return a <code>generator</code> object; this <code>generator</code> object has then a <code>next()</code> member function and then every call to the <code>next()</code> member function gives us back the next number in the sequence.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">struct</span> FiboGenerator</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co">// Successive calls to next()  </span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="co">// return the numbers from the </span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="co">// Fibonacci series</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="dt">int</span> next<span class="op">();</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">// Returns a new FiboGenerator object</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">// that will start from the first </span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">// Fibonacci number</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>FiboGenerator makeFiboGenerator<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The interesting question is: Is <code>makeFiboGenerator()</code> a coroutine? And we really can’t tell - it’s an implementation detail. All we see is an interface. This is actually the most important thing about coroutines. From the outside, they just look and behave like functions. From the outside, there is no way to tell, whether they’ve been implemented using a coroutine or not. The only thing that we need to know as the user of this function is the interface of the object <code>FiboGenerator</code>.</p>
</section>
<section id="the-coroutine-return-type" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-coroutine-return-type">The coroutine return type</h3>
<p>The initial call to the coroutine function will produce this return object of a certain <code>ReturnType</code> and hand it back to the caller. The interface of this type is what is going to determine what the coroutine is capable of. Since coroutines are super-flexible, we can do a whole lot with this return object. If you have some coroutine, and you want to understand what it’s doing, the first thing you should look at is the <code>ReturnType</code>, and what it’s interface is. The important thing here is, we design this <code>ReturnType</code>. If you are writing a coroutine, you can decide, what goes into this interface.</p>
</section>
<section id="how-to-turn-a-function-into-a-coroutine" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="how-to-turn-a-function-into-a-coroutine">How to turn a function into a coroutine?</h3>
<p>The compiler looks for one of the three keywords in the implementation: <code>co_yield</code>, <code>co_await</code> and <code>co_return</code>.</p>
<table class="table">
<caption>Coroutine keywords and their effects</caption>
<thead>
<tr class="header">
<th>Keyword</th>
<th>Action</th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>co_yield</code></td>
<td>Output</td>
<td>Suspended</td>
</tr>
<tr class="even">
<td><code>co_return</code></td>
<td>Output</td>
<td>Ended</td>
</tr>
<tr class="odd">
<td><code>co_await</code></td>
<td>Input</td>
<td>Suspended</td>
</tr>
</tbody>
</table>
<p>In the preceding table, we see that after <code>co_yield</code> and <code>co_await</code>, the coroutine suspends itself and after <code>co_return</code>, it is terminated (<code>co_return</code> is the equivalent of the <code>return</code> statement in the C++ function).</p>
<p>A classical function starts executing when it’s called and normally terminates with a <code>return</code> statement or just when the function’s end is reached. A function runs from the beginning to end. It may call another function (or even itself if it is recursive) and it may throw exceptions or have different return points. But it always runs from the beginning to the end.</p>
<p>A coroutine is different. A coroutine is a function that can suspend itself. The flow for a coroutine may be like the following pseudo-code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>ReturnType coroutine<span class="op">(){</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    do_something<span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="cf">co_yield</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    do_something_else<span class="op">();</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="cf">co_yield</span><span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    do_more_work<span class="op">();</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should think of the coroutine function not as a function in the classical sense, but rather as a factory function that returns a coroutine object and this coroutine object is the one that holds all the state, and one which you can resume to continue the computation later on.</p>
</section>
<section id="use-cases-for-coroutines" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="use-cases-for-coroutines">Use-cases for coroutines</h3>
<p><strong>Asynchronous computation.</strong> Suppose we are tasked with designing a simple echo server. We listen for incoming data from a client socket and we simply send it back to the client. At some point in our code for the echo server, we will have a piece of logic like below:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="dt">int</span> len <span class="op">=</span> sock<span class="op">.</span>read<span class="op">({</span>buffer<span class="op">});</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    sock<span class="op">.</span>write<span class="op">({</span>buffer<span class="op">,</span>len<span class="op">});</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    log<span class="op">(</span>buffer<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We create a <code>buffer</code>, then call the <code>read</code> that reads packets from the NIC and stores them in the buffer. The return value <code>len</code> will tell us how many bytes we read. Then, we shrink the <code>buffer</code> - we create a smaller one with <code>len</code> bytes and we write it back. Finally, we perform some logging. If we run it, it will probably work, but we certainly don’t want to write a server like this. Say one of the clients requests communication and we are in a session. They say, they are ready to send the data, so we are blocking on the <code>read</code>, but maybe they send us this data in 2 minutes, or 5 minutes or even more. And other clients keep waiting.</p>
<p>What we could do is start this session and run it in a separate thread. And this would work, because if this thread is blocked, and if there are other threads in this server, they would run in exchange during the wait time. If we have a threadpool, we’ll just grab a thread from the threadpool, tell whatever system manages the pool to run this <code>session(Socket)</code> function there.</p>
<p>This solution is still far from ideal. These are operating system emulated threads and the OS will have to manage which threads get CPU time. It will have to preempt one thread, run another. This preemption will occur at random moments, when we least expect it. We could have data-races and likely require protection of a critical section/resource using mutexes.</p>
<p>One alternative is to use an asynchronous framework and rewrite our code as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">struct</span> State<span class="op">{</span> Socket sock<span class="op">;</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span> <span class="op">};</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    </span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co">// Heap allocate the state</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">auto</span> state <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>State<span class="op">&gt;(</span>sock<span class="op">,</span> buffer<span class="op">);</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">auto</span> on_read_finished_callback <span class="op">=</span> <span class="co">/* ... */</span></span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co">// Perform an asynchronous read </span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    state<span class="op">-&gt;</span>socket<span class="op">.</span>async_read<span class="op">(</span> state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb8-11"><a href="#cb8-11"></a>                             on_read_finished_callback <span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>async_read()</code> call is a request to the framework, which says that we are interested in data being read to our buffer at some point convenient to the client. When this succeeds, call our <code>on_read_finished_callback</code>. So, we are just making this association at this point and the server can move on to doing other stuff.</p>
<p>The <code>read</code> operation may fail for a number of reasons, so a good approach would be supply two arguments to the <code>on_read_finished_callback</code>: (i) An error code (ii) The number of bytes received, if there were no errors. We can try to implement it, by checking the error-code.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="kw">struct</span> State<span class="op">{</span> Socket sock<span class="op">;</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span> <span class="op">};</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    </span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="co">// Heap allocate the state</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="kw">auto</span> state <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>State<span class="op">&gt;(</span>sock<span class="op">,</span> buffer<span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="kw">auto</span> on_read_finished_callback <span class="op">=</span> <span class="op">[&amp;</span>state<span class="op">](</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>        error_code ec<span class="op">,</span> </span>
<span id="cb9-9"><a href="#cb9-9"></a>        <span class="dt">size_t</span> len</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="op">)</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>        <span class="kw">auto</span> done <span class="op">=</span> <span class="co">/* ... */</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>        <span class="cf">if</span><span class="op">(!</span>ec<span class="op">)</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>        <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>            <span class="co">// Perform an asynchronous write</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>            state<span class="op">-&gt;</span>socket<span class="op">.</span>async_write<span class="op">(</span> </span>
<span id="cb9-17"><a href="#cb9-17"></a>                state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb9-18"><a href="#cb9-18"></a>                done </span>
<span id="cb9-19"><a href="#cb9-19"></a>            <span class="op">);</span>    </span>
<span id="cb9-20"><a href="#cb9-20"></a>        <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22"></a></span>
<span id="cb9-23"><a href="#cb9-23"></a>    <span class="co">// Perform an asynchronous read </span></span>
<span id="cb9-24"><a href="#cb9-24"></a>    state<span class="op">-&gt;</span>socket<span class="op">.</span>async_read<span class="op">(</span> state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb9-25"><a href="#cb9-25"></a>                             on_read_finished_callback <span class="op">);</span></span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, we don’t have exception handling, because we have spread our logic over a number of callbacks. We are only left with <code>if</code> statements. If the reading all went fine, we can write the data back by shrinking the buffer, requesting that the <code>write</code> is performed at some time, not necessarily now - maybe later. When this <code>write</code> is performed, we would like to call another callback <code>done</code>. We don’t wait until this callback is called or <code>write</code> is performed. At this point, we just make an association. It is possible, that at a future time, the <code>write</code> succeeds and then the callback <code>done</code> is called. So, we have to define it.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">void</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">struct</span> State<span class="op">{</span> Socket sock<span class="op">;</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span> <span class="op">};</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    </span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="co">// Heap allocate the state</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">auto</span> state <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>State<span class="op">&gt;(</span>sock<span class="op">,</span> buffer<span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">auto</span> on_read_finished_callback <span class="op">=</span> <span class="op">[</span>state<span class="op">](</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>        error_code ec<span class="op">,</span> </span>
<span id="cb10-9"><a href="#cb10-9"></a>        <span class="dt">size_t</span> len</span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="op">)</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>        <span class="kw">auto</span> done <span class="op">=</span> <span class="op">[</span>state<span class="op">](</span>error_code ec<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">)</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>        <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>            <span class="cf">if</span><span class="op">(!</span>ec<span class="op">)</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>                log<span class="op">();</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>        <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>        <span class="cf">if</span><span class="op">(!</span>ec<span class="op">)</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>        <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>            <span class="co">// Perform an asynchronous write</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>            state<span class="op">-&gt;</span>socket<span class="op">.</span>async_write<span class="op">(</span> </span>
<span id="cb10-21"><a href="#cb10-21"></a>                state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb10-22"><a href="#cb10-22"></a>                done </span>
<span id="cb10-23"><a href="#cb10-23"></a>            <span class="op">);</span>    </span>
<span id="cb10-24"><a href="#cb10-24"></a>        <span class="op">}</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>    <span class="op">}</span></span>
<span id="cb10-26"><a href="#cb10-26"></a></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="co">// Perform an asynchronous read </span></span>
<span id="cb10-28"><a href="#cb10-28"></a>    state<span class="op">-&gt;</span>socket<span class="op">.</span>async_read<span class="op">(</span> state<span class="op">-&gt;</span>buffer<span class="op">,</span> </span>
<span id="cb10-29"><a href="#cb10-29"></a>                             on_read_finished_callback <span class="op">);</span></span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>done</code> has a similar structure. It takes two arguments - the error code that tells if the <code>write</code> went fine and the number of bytes written <code>len</code>. If there were no errors on <code>write</code> and everything went fine, we can do the logging. Implicitly,</p>
<p>So, the <code>session</code> makes two associations:</p>
<p><span class="math display">\[
\begin{align*}
\text{On finishing read} &amp;\mapsto \texttt{on\_finished\_read\_callback} \\
\text{On finishing write} &amp;\mapsto \texttt{done} \\
\text{Accepting a new client connection} &amp;\mapsto \texttt{session}
\end{align*}
\]</span></p>
<p>And implicitly there is a third association even though we cannot see it here - this entire function <code>session</code> is most likely a callback, in response to an event like <span class="math inline">\(\text{On client connection established}\)</span>. So, the server will be many different associations of events to callbacks at different levels.</p>
<p>Pay attention to the <code>state</code>. We said that, we wanted to allocate it on the heap and manage it through a <code>shared_ptr</code>. We pass this <code>shared_ptr&lt;State&gt;</code> by value to every single callback. This way, I make sure that the last one who touches this session turns off the lights and deallocates <code>state</code>.</p>
<p>While this is a toy-example, in real production code, there can be a long sequence of steps and calling lambdas inside lambdas can obfuscate the meaning of the code. We already see a weird inversion of control flow, when reading the code.</p>
<p>One thing to note before I go to coroutines is that, even though those things happen asynchronously, there is a sequence to it, that is not violated. We only perform a <code>write</code> when we know that the <code>read</code> has succeeded. We only perform the <code>log</code> after the <code>write</code> has succeeded.</p>
<p><span class="math display">\[
\texttt{read} \to \texttt{write} \to \texttt{log}
\]</span></p>
<p>As an application programmer we determine, when we yield control to the system other sessions. It’s not that the system pre-empts this task.</p>
<p>A coroutine implementation of the same echo’ing session would look like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>Task<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> session<span class="op">(</span>Socket sock<span class="op">){</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="dt">int</span> len <span class="op">=</span> <span class="cf">co_await</span> sock<span class="op">.</span>async_read<span class="op">({</span>buffer<span class="op">});</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="cf">co_await</span> sock<span class="op">.</span>async_write<span class="op">({</span>buffer<span class="op">,</span>len<span class="op">});</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    log<span class="op">(</span>buffer<span class="op">);</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This looks very similar to the sequential code, except that we use this <code>co_await</code> keyword. You have clear indication of the points where the coroutine will be suspended. Also, note that previously the function <code>session</code> returned <code>void</code>. Now, we are returning something - a <code>Task&lt;void&gt;</code>. This will be a handle to the coroutine and it’s how the outside world will be communicating with the coroutine.</p>
<p><strong>Suspended computation</strong>. A second use-case is that coroutines support lazy evaluation. Just as in the fibonacci example, sometimes we want to avoid doing unecessary evaluation. Lazy evaluation doesn’t do any work unless it’s absolutely necessary. This can also potentially make your code more efficient. Lazy evaluation also supports programming with infinite lists.</p>
</section>
</section>
<section id="the-simplest-coroutine" class="level2">
<h2 class="anchored" data-anchor-id="the-simplest-coroutine">The simplest coroutine</h2>
<p>The following code is the simplest implementation of a coroutine:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="dt">void</span> coro_func<span class="op">(){</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    coro_func<span class="op">();</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/W3GoWPoEs">Compiler Explorer</a></p>
<p>Our first coroutine will just return nothing. It will not do anything else. Sadly, the preceding code is too simple for a functional coroutine and it will not compile. When compiling with <code>gcc 15.2</code>, we get the following error:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb13-1"><a href="#cb13-1"></a>&lt;source&gt;: In function 'void coro_func()':</span>
<span id="cb13-2"><a href="#cb13-2"></a>&lt;source&gt;:4:5: error: unable to find the promise type for this coroutine</span>
<span id="cb13-3"><a href="#cb13-3"></a>    4 |     co_return;</span>
<span id="cb13-4"><a href="#cb13-4"></a>      |     ^~~~~~~~~</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Looking at C++ reference, we see that the return type of a coroutine must define a type named <code>promise_type</code>.</p>
<section id="the-promise_type" class="level3">
<h3 class="anchored" data-anchor-id="the-promise_type">The <code>promise_type</code></h3>
<p>Why do we need a promise? The <code>promise_type</code> is the second important piece in the coroutine mechanism. We can draw an analogy from futures and promises which are essential blocks for achieving asynchronous programming in C++. The future is the thing, that the function that does the asynchronous computation, hands out back to the caller, that the caller can use to retrieve the result by invoking the <code>get()</code> member function. The future has the role of the return object. But, you need something that remains on the producer-side. The asynchronous function holds on to the promise, and that’s where it puts the results that will be given to the caller, when it calls <code>get()</code> on the future. The idea behind the <code>promise_type</code> for coroutines is similar. The promise is where the coroutine’s return value is stored, and it provides functions to control the coroutine’s behavior at startup and completion of t he coroutine. The promise is the interface through which the caller interacts with the coroutine.</p>
<p>Following the reference advice, we can write a new version of our coroutine.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">struct</span> Task</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="op">};</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="op">};</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    coro_func<span class="op">();</span></span>
<span id="cb14-15"><a href="#cb14-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/G957defsr">Compiler Explorer</a></p>
<p>Note that the return type of a coroutine can have any name (I call it <code>Task</code>, so that it makes intuitive sense). Compiling the preceding code again gives us errors. All errors are about missing functions in the <code>promise_type</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb15-1"><a href="#cb15-1"></a>&lt;source&gt;: In function 'Task coro_func()':</span>
<span id="cb15-2"><a href="#cb15-2"></a>&lt;source&gt;:11:5: error: no member named 'return_void' in</span>
<span id="cb15-3"><a href="#cb15-3"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span>
<span id="cb15-4"><a href="#cb15-4"></a>   11 |     co_return;</span>
<span id="cb15-5"><a href="#cb15-5"></a>      |     ^~~~~~~~~</span>
<span id="cb15-6"><a href="#cb15-6"></a>&lt;source&gt;:10:6: error: no member named 'unhandled_exception' in</span>
<span id="cb15-7"><a href="#cb15-7"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span>
<span id="cb15-8"><a href="#cb15-8"></a>   10 | Task coro_func(){</span>
<span id="cb15-9"><a href="#cb15-9"></a>      |      ^~~~~~~~~</span>
<span id="cb15-10"><a href="#cb15-10"></a>&lt;source&gt;:10:6: error: no member named 'get_return_object' in</span>
<span id="cb15-11"><a href="#cb15-11"></a>'std::__n4861::__coroutine_traits_impl&lt;Task, void&gt;::promise_type' {aka 'Task::promise_type'}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the important functions of the <code>promise_type</code> is that it determines what happens at certain key points in the coroutine’s life. It determines, what happens at the startup and completion of execution of the coroutine.</p>
</section>
<section id="implementing-the-promise_type" class="level3">
<h3 class="anchored" data-anchor-id="implementing-the-promise_type">Implementing the <code>promise_type</code></h3>
<p>The first thing that the compiler expects from us the <code>get_return_object()</code> function. The return type of this function is the same as the return type of the coroutine.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;coroutine&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">struct</span> Task<span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">struct</span> <span class="dt">promise_type</span><span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>        Task get_return_object<span class="op">(){</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"get_return_object()"</span><span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>            <span class="cf">return</span> Task<span class="op">{</span> <span class="op">*</span><span class="kw">this</span> <span class="op">};</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>        <span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a>        <span class="dt">void</span> return_void<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"return_void()"</span><span class="op">);</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>        <span class="op">}</span></span>
<span id="cb16-14"><a href="#cb16-14"></a></span>
<span id="cb16-15"><a href="#cb16-15"></a>        <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"unhandled_exception()"</span><span class="op">);</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>        <span class="op">}</span></span>
<span id="cb16-18"><a href="#cb16-18"></a></span>
<span id="cb16-19"><a href="#cb16-19"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>initial_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb16-20"><a href="#cb16-20"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"initial_suspend()"</span><span class="op">);</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb16-22"><a href="#cb16-22"></a>        <span class="op">}</span></span>
<span id="cb16-23"><a href="#cb16-23"></a></span>
<span id="cb16-24"><a href="#cb16-24"></a>        <span class="bu">std::</span>suspend_always<span class="op"> </span>final_suspend<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb16-25"><a href="#cb16-25"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"final_suspend()"</span><span class="op">);</span></span>
<span id="cb16-26"><a href="#cb16-26"></a>            <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb16-27"><a href="#cb16-27"></a>        <span class="op">}</span></span>
<span id="cb16-28"><a href="#cb16-28"></a>    <span class="op">};</span></span>
<span id="cb16-29"><a href="#cb16-29"></a></span>
<span id="cb16-30"><a href="#cb16-30"></a>    <span class="kw">explicit</span> Task<span class="op">(</span><span class="dt">promise_type</span><span class="op">&amp;){</span></span>
<span id="cb16-31"><a href="#cb16-31"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Task(promise_type&amp;)"</span><span class="op">);</span></span>
<span id="cb16-32"><a href="#cb16-32"></a>    <span class="op">}</span></span>
<span id="cb16-33"><a href="#cb16-33"></a></span>
<span id="cb16-34"><a href="#cb16-34"></a>    <span class="op">~</span>Task<span class="op">()</span> <span class="kw">noexcept</span><span class="op">{</span></span>
<span id="cb16-35"><a href="#cb16-35"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"~Task()"</span><span class="op">);</span></span>
<span id="cb16-36"><a href="#cb16-36"></a>    <span class="op">}</span></span>
<span id="cb16-37"><a href="#cb16-37"></a><span class="op">};</span></span>
<span id="cb16-38"><a href="#cb16-38"></a></span>
<span id="cb16-39"><a href="#cb16-39"></a>Task coro_func<span class="op">(){</span></span>
<span id="cb16-40"><a href="#cb16-40"></a>    <span class="cf">co_return</span><span class="op">;</span></span>
<span id="cb16-41"><a href="#cb16-41"></a><span class="op">}</span></span>
<span id="cb16-42"><a href="#cb16-42"></a></span>
<span id="cb16-43"><a href="#cb16-43"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb16-44"><a href="#cb16-44"></a>    coro_func<span class="op">();</span></span>
<span id="cb16-45"><a href="#cb16-45"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><a href="https://compiler-explorer.com/z/xoqanYjMT">Compiler Explorer</a></p>
<p>Output:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource shell number-lines code-with-copy"><code class="sourceCode"><span id="cb17-1"><a href="#cb17-1"></a>get_return_object()</span>
<span id="cb17-2"><a href="#cb17-2"></a>Task(promise_type&amp;)</span>
<span id="cb17-3"><a href="#cb17-3"></a>initial_suspend()</span>
<span id="cb17-4"><a href="#cb17-4"></a>~Task()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>get_return_object()</code> method is implicitly called when the coroutine starts executing. Its upto the <code>promise_type</code> to provide an implementation of this method that constructs the return object that will be handed back to the caller. The <code>Task</code> object is stored on the heap. You don’t see this in the source code anywhere. When the coroutine reaches its first suspension point, and control flow is returned back to the caller, then the caller will receive this object.</p>
<p>The next thing we need to specify is the <code>return_void()</code> function. This is a customization point for handling what happens when we reach the <code>co_return</code> statement in the function body. There is also a corresponding <code>return_value()</code>, if you don’t have an empty <code>co_return</code> statement, but we’ll look at this at length later ahead.</p>
<p>The next one we need is <code>unhandled_exception()</code> and similar to the <code>return_void()</code>, this function is a customization point for handling, what happens when the coroutine throws an exception. We leave it empty for now.</p>
<p>We need to implement two more functions <code>initial_suspend()</code> and <code>final_suspend()</code>. These are basically the customization points that allow us to execute some code, both when the coroutine first starts executing and shortly before the coroutine ends execution. Here, we are returning <code>std::suspend_always</code> which basically means that at these points, I want to go into suspension. In a typical implementation, you either return <code>std::suspend_always</code>, which means you pause execution at this point and hand control back to the caller always, or you return <code>std::suspend_never</code>, which basically means you just go on and continue executing the coroutine.</p>
<p>Note that, <code>final_suspend()</code> is not printed in the output, because the coroutine is paused at <code>initial_suspend()</code> and since I never resumed it, I don’t see the output on the console.</p>
</section>
</section>
<section id="a-yielding-coroutine" class="level2">
<h2 class="anchored" data-anchor-id="a-yielding-coroutine">A yielding coroutine</h2>
<p>The do-nothing coroutine was great to get a gut intuitive feel for the basic mechanics of writing low-level coroutines in C++. Let’s implement another coroutine that can send data back to the caller.</p>
<p>In this second example, we implement a coroutine that produces a message. It will be the hello world of coroutines. The coroutine will say hello and the caller function will print the message received from the coroutine.</p>
<p>To implement this functionality, we need to establish a communication channel from the coroutine to the caller. This channel is the mechanism that allows the coroutine to pass values to the caller and receive information from it.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="quasar-chunawala/quantdev" data-repo-id="R_kgDOL2t5-A" data-category="General" data-category-id="DIC_kwDOL2t5-M4ClndQ" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>