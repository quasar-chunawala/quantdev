---
title: "Implementing `vector<T>`"
author: "Quasar"
date: "2025-12-15"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Implementing `vector<T>`

## The problem statement

> #### Your Task

Implement your own version of a vector with the following methods:

- `push_back` – Adds an element to the back.
- `at` – Retrieves an element by index.
- `getSize` – Gets the size of the container.
- `getCapacity` – Gets the capacity of the container.
- `shrinkToFit` – Shrinks the capacity to equal the size of the container.
- `pop_back` – Removes the last element in the container. Will never be called on an empty container.

> #### Requirements

- Do not worry about memory alignment or advanced optimizations.
- Do not use `std::vector` in your `dev::vector` implementation.
- Your vector's capacity must start at 1.
- The capacity should triple every time it is reached.

For more such C++ coding tasks, visit [getcracked.io](https://getcracked.io/problem/1/implement-vector). 

# Writing your own `vector<T>` training implementation

> ### *If you know `std::vector`, you know half of C++.*
>
> ### - Bjarne Stroustrup

The most fundamental STL data-structure is the `vector`. In this article, I am going to explore writing a custom implementation of the `vector` data-structure. The standard library implementation `std::vector` is a work of art, it is extremely efficient at managing memory and has been tested ad nauseam. It is much better, in fact, than a homegrown alternative would be. 

Why then write our own custom `vector`? 
- Writing a naive implementation is challenging and rewarding. It is a lot of fun!
- Coding up these training implementations, thinking about corner cases, getting your code reviewed, revisiting your design is very effective at understanding the inner workings of STL data-strucures and writing good C++ code. 
- Its a good opportunity to learn about low-level memory management algorithms. 

We are not aiming for an exhaustive representation or implementation, but we will write test cases for all basic functionalities expected out of a `vector` like data-structure.

Informally, a `std::vector<T>` represents a dynamically allocated array that can grow as needed. As with any array, a `std::vector<T>` is a sequence of elements of type `T` arranged contigously in memory. We will put our homegrown version of `vector<T>` under the `dev` namespace. 

## Unit tests for `vector<T>`

For low-level data-structures such as the `vector`, let's write the unit-tests upfront before the implementation. This will help us think through the interface and corner cases. Tests will also serve as documentation of the expected functionality.

The internal representation of a `vector` like type has a book-keeping node that consists of:
- A pointer to the raw data (a block of memory that will hold elements of type `T`)
- Size of the container(the number of elements in the container)
- Capacity

![](vector.png){width=800px height=250px}

It's important to distinguish between `size` and `capacity`. `size` is the number of elements currently in the container. When `size == capacity`, the container becomes full and will need to grow, which means allocating more member, copying the elements from the old storage to the new storage and getting rid of the old storage. 

Given this background, we assume that the `vector` is equipped with basic getters such as:

- `std::size_t size()`
- `std::size_t capacity()`
- `bool empty()` 
- `bool is_full()`

The `vector` should support various constructors.

```cpp
TEST(VectorTest, DefaultConstructorTest) {
    dev::vector<int> v;
    EXPECT_EQ(v.empty(), true);
}

TEST(VectorTest, InitializerListTest){
    dev::vector<int> v{1, 2, 3, 4, 5};
    EXPECT_EQ(!v.empty(), true);
    EXPECT_EQ(v.size(), 5);
    EXPECT_TRUE(v.capacity() > 0);
    for(auto i{0uz}; i < v.size(); ++i){
        EXPECT_EQ(v.at(i), i+1);
    }
}

TEST(VectorTest, ParameterizedConstructorTest){
    dev::vector v(10, 5.5);
    EXPECT_EQ(v.size(), 10);
    for(auto i{0uz}; i < v.size(); ++i){
        EXPECT_EQ(v[i], 5.5);
    }
}

TEST(VectorTest, CopyConstructorTest){
    dev::vector v1{ 1.0, 2.0, 3.0, 4.0, 5.0 };
    dev::vector v2(v1);

    EXPECT_EQ(v1.size() == v2.size(), true);

    for (int i{ 0 }; i < v1.size(); ++i)
    {
        EXPECT_EQ(v2[i], i+1);
        EXPECT_EQ(v1[i], v2[i]);
    }
}

TEST(VectorTest, MoveConstructorTest){
    dev::vector<int> v1{ 1, 2, 3 };
    dev::vector<int> v2(std::move(v1));
    EXPECT_EQ(v1.size(), 0);
    EXPECT_EQ(v1.capacity(), 0);
    EXPECT_EQ(v2.size(), 3);
    for(auto i{0uz}; i<v2.size(); ++ i)
        EXPECT_EQ(v2[i], i + 1);
}

TEST(VectorTest, CopyAssignmentTest)
{
    dev::vector<int> v1{ 1, 2, 3 };
    dev::vector<int> v2;
    v2 = v1;

    EXPECT_EQ(v1.size(), v2.size());
    EXPECT_EQ(v1.capacity(), v2.capacity());
    for (int i = 0; i < v1.size(); ++i) {
        EXPECT_EQ(v1[i], i+1);
        EXPECT_EQ(v1[i], v2[i]);
    }
}

TEST(VectorTest, MoveAssignmentTest)
{
    dev::vector<int> v1{ 1, 2, 3 };
    dev::vector<int> v2;
    v2 = std::move(v1);

    EXPECT_EQ(v1.size(), 0);
    EXPECT_EQ(v1.capacity(), 0);
    EXPECT_EQ(v2.size(), 3);
    for (int i = 0; i < v1.size(); ++i) {
        EXPECT_EQ(v2[i], i+1);
    }
}
```
The `vector` data-structure should support element access through the array subscript operator `[]`, just like C-style arrays. The `T& at(std::size_t idx)` could also be used to access the element at index `idx` with bounds checking.

```cpp
TEST(VectorTest, AtTest)
{
    dev::vector<int> v{ 1, 2, 3 };
    EXPECT_EQ(v.at(0), 1);
    EXPECT_EQ(v.at(1), 2);
    EXPECT_EQ(v.at(2), 3);

    EXPECT_THROW(v.at(3), std::out_of_range);
}

TEST(VectorTest, SubscriptOperatorTest)
{
    dev::vector<int> v{ 1, 2, 3 };
    for (int i{0uz}; i < v.size(); ++i) {
        EXPECT_EQ(v[i], i+1);
    }
}
```

We expect the container to perform the book-keeping of size and capacity correctly.

```cpp
TEST(VectorTest, EmptyTest)
{
    dev::vector<int> v;
    EXPECT_EQ(v.empty(), true);

    v.push_back(42);
    EXPECT_EQ(v.empty(), false);
}

TEST(VectorTest, SizeAndCapacityTest)
{
    dev::vector<int> v;
    EXPECT_EQ(v.size(), 0);
    EXPECT_GE(v.capacity(), 0);

    v.push_back(42);
    EXPECT_EQ(v.size(), 1);
    EXPECT_GT(v.capacity(), 0);

    v.push_back(v.back());
    EXPECT_EQ(v.size(), 2);
    EXPECT_EQ(v[1], 42);
}

```

We expect the container to support the getter methods `front()` and `back()`. 

```cpp
TEST(VectorTest, FrontAndBackTest)
{
    dev::vector<int> v{ 1, 2, 3 };
    EXPECT_EQ(v.front(), 1);
    EXPECT_EQ(v.back(), 3);
}
```

The container should support `reserve(size_t new_capacity)` and `resize(size_t new_size)`. These are explained at length further ahead.

```cpp
TEST(VectorTest, ReserveTest)
{
    dev::vector<int> v1;
    v1.reserve(10);
    EXPECT_GE(v1.capacity(), 10);
    EXPECT_EQ(v1.size(), 0);

    dev::vector<int> v2{1, 2, 3, 4, 5, 6, 7};
    size_t old_capacity = v2.capacity();
    EXPECT_GE(v2.capacity(), 7);
    EXPECT_EQ(v2.size(), 7);
    size_t new_capacity = 2 * old_capacity;
    v2.reserve(new_capacity);
    EXPECT_GE(v2.capacity(), new_capacity);
    EXPECT_EQ(v2.size(), 7);
    for(auto i{0uz}; i < v2.size(); ++i)
        EXPECT_EQ(v2[i], i + 1);
}

TEST(VectorTest, ResizeTest)
{
    dev::vector<int> v{ 1, 2, 3 };
    v.resize(5);

    EXPECT_EQ(v.size(), 5);
    for(auto i{0uz}; i<3; ++i)
        EXPECT_EQ(v[i], i + 1);

    EXPECT_EQ(v[3], 0);
    EXPECT_EQ(v[4], 0);

    v.resize(2);
    EXPECT_EQ(v.size(), 2);
    EXPECT_EQ(v[0], 1);
    EXPECT_EQ(v[1], 2);
}
```

The container should support appending elements or remove elements at the back. 

```cpp
TEST(VectorTest, PushBackTest)
{
    dev::vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);

    EXPECT_EQ(v.size(), 3);
    for(auto i{0uz}; i<v.size(); ++i)
        EXPECT_EQ(v[i], i + 1);
}

TEST(VectorTest, PushBackSelfReferenceTest)
{
    // The design of push_back/insert is slightly hard to get right.
    // If the vector is full, then you reallocate(grow) the vector.
    // If the value to be added is a reference to an existing
    // vector element, then value in vec.push_back(value) may become
    // a dangling reference, if it refers to the old storage (an element of the vector
    // itself e.g. vec.back()). This test is meant for such an edge case.
    dev::vector<int> vec{ 1 };
    for (auto i{0uz}; i < 64; ++i) {
        vec.push_back(vec.back());
        EXPECT_EQ(vec.back(), 1);
    }
}

TEST(VectorTest, EmplaceBackTest)
{
    struct Point
    {
        int x, y;
        Point(int a, int b)
          : x(a)
          , y(b)
        {
        }
    };

    dev::vector<Point> v;
    v.emplace_back(1, 2);
    v.emplace_back(3, 4);

    EXPECT_EQ(v.size(), 2);
    EXPECT_EQ(v[0].x, 1);
    EXPECT_EQ(v[0].y, 2);
    EXPECT_EQ(v[1].x, 3);
    EXPECT_EQ(v[1].y, 4);
}
```
[TODO] Add implementation for insert, pop_back()
## `vector` member data

We start with coding up the `vector` as a class template. It is templated by the type  `T` of the elements stored in the container. We also define various  type aliases.

```cpp
namespace dev {
    template <typename T>
    class vector {
        using value_type = T;
        using size_type = std::size_t;
        using pointer = T*;
        using const_pointer = const T*;
        using reference = T&;
        using const_reference = const T&;
        using iterator = pointer;
        using const_iterator = const_pointer;
        constexpr static std::size_t initial_capacity{1};
        constexpr static unsigned short growth_factor{2};

    private:
        pointer m_data;
        size_type m_size;
        size_type m_capacity;
    };
}
```


C++ containers usually expose iterators as part of their interface and ours will be no exception. We define type aliases for the `const` and non-`const` iterator types, as this makes it simpler to implement alternatives.

```cpp
template <typename T>
class vector {
    // ...
public:

    iterator begin(){ return m_data; }
    const_iterator begin() const{ return m_data; }
    iterator end(){ return begin() + m_size; }
    const_iterator end() const{ return begin() + m_size; }
// ...
```

## Basic services of a vector-like class

### Implementing `front()`, `back()` and `operator[](size_t idx)`

There is more to writing a convenient dynamic array type. For example, member functions that let you access the elements at front or rear-end of the vector are to be expected. Similarly, an implementation of `operator[]` to access the element at a specific index in the array is also expected.

```cpp
// ...
reference operator[](size_type idx){
    return m_data[idx];
}

const_reference operator[](size_type idx) const{
    return m_data[idx];
}

// precondition: !empty()
reference front(){ return (*this)[0]; }
const_reference front() const { return (*this)[0]; }
reference back(){ return (*this)[m_size - 1]; }
const_reference back() const{ return (*this)[m_size - 1]; }
```

Comparing two `vector<T>` objects for equivalence or lack thereof is a relatively easy matter if we use algorithms:

```cpp
//...
bool operator==(const vector& other){
    return size() == other.size() && 
        std::equal(begin(), end(), other.begin());
}
```

### Implementing `reserve()`

`reserve(size_type new_capacity)` increases the capacity of the vector(the total number of elements that the vector can hold without requiring reallocation) to a value that's greater or equal to `new_capacity`. If `new_capacity` is greater than the current `capacity()`, new storage is allocated, otherwise the function does nothing.

We introduce the helper functions `allocate_helper` and `copy_old_storage_to_new`. 

```cpp
// Dynamically allocates a chunk of uninitialized memory on the heap
// that can hold `new_capacity` number of elements.
// Allocation excepts are propogated to the caller.
pointer allocate_helper(size_type new_capacity){
    return static_cast<pointer>(operator new(sizeof(value_type) * new_capacity));
}

void deallocate_helper(pointer ptr){
    operator delete(ptr);
}

// Copies elements from old storage to new
// If T's copy/move ctor throws, the objects already constructed are
// destroyed and the exception is propagated to the caller.
void copy_old_storage_to_new(pointer source_first, size_t num_elements, pointer destination_first){
    if constexpr(std::is_nothrow_move_constructible_v<T>){
        std::uninitialized_move(source_first, source_first + num_elements, destination_first);
    }
    else{
        try{
            std::uninitialized_copy(source_first, source_first + num_elements, destination_first);
        }catch(std::exception& ex){
            throw ex;
        }
    }
}

void reserve(size_type new_capacity){
    if(new_capacity <= capacity())
        return;
    
    auto ptr_new_blk = allocate_helper(new_capacity);
    try{
        copy_old_storage_to_new(m_data, m_size, ptr_new_blk);
    }catch(std::exception& ex){
        deallocate_helper(ptr_new_blk);
        throw ex;   // rethrow
    }
    
    std::destroy(m_data, m_data + m_size);
    deallocate_helper(m_data);
    m_data = ptr_new_blk;
    m_capacity = new_capacity;    
}
```

If `new_capacity > capacity()`, we must:

- Allocate a chunk `new_capacity * sizeof(T)` bytes large on the heap dynamically. 
- Copy the existing container elements from the old storage area to the new block of memory.
- Destruct the elements in the old storage and deallocate the memory occupied. 
- Update the `vector`'s `m_data` pointer and `m_capacity` field.

In general, we must separate allocation from construction. C++17 introduced the `operator new(size_t count)` and `operator new[](size_t count)`. `operator new(size_t count)` attempts to allocate `count` bytes on the heap. The newly allocated memory is **uninitialized**. This is different from the `new` expression, `new T(Args)` or `new T[]()` which performs both allocation and zero initialization (invokes the default constructor `T()`). 

After the allocation, we want to copy the elements in the range `m_data[0...m_size-1]` to `ptr_new_blk`. `copy_old_storage_to_new` is a helper function to copy `num_elements` from the memory location `source_first` to `destination_first`. 

C++17 introduced `std::uninitialized_copy` and `std::uninitialized_move` algorithms. `std::uninitialized_copy(first, last, d_first)` accepts a source range `[first,last)` and copies the elements from the source range to an uninitialized memory area beginning at `d_first`. The `std::uninitialized_move` algorithm uses move semantics. 

The beauty of these uninitialized memory algorithms are that they are exception safe. If one of the `T(const T&)` constructors invoked by `uninitialized_copy` ends up throwing, then the objects it managed to create before the exception was thrown will be destroyed in the reverse order of construction, before the exception leaves the function.

The type-trait `std::is_move_constructible_v<T>` is meta-function that returns `true`, if the argument `T` is move constructible. 

There's a general trick that you would have seen in all of this. Do not modify your object until you know, you can safely do. Try to do the potentially throwing operations first, then do the operations until you can mutate your object. You will sleep better, and the risks of object corruption will be alleviated.

### Implementing `resize()`

The distinction between `resize()` and `reserve()` is that `reserve()` only affects the capacity of the container, whereas `resize()` modifies the size and capacity both.

The `resize(size_type new_size)` method resizes the container to contain `count` elements:

- If the `new_size` is equal to the current size, do nothing. 
- If the current size is greater than the `new_size`, the container is reduced to its first `new_size` elements.
- If the current size is less than `new_size`, then:
    - Additional default-constructed elements are appended.

```cpp
void resize(size_type new_size){
    size_type current_size = m_size;
    if(new_size == current_size)
        return;

    if(new_size < current_size)
    {
        // Reduce the container to count elements
        std::destroy(m_data + new_size, m_data + m_size);
    }

    if(new_size > current_size)
    {
        reserve(new_size);

        // Default construct elements at indicates
        // [current_size,...,new_size-1]
        std::uninitialized_fill(m_data + size(), m_data + capacity(), value_type{});
    }
    m_size = new_size;
}    
```

## How to think about adding elements to our container?

We will code up a `push_back(T&&)` member function that accepts a universal reference `T&&`. If `T` is move constructible, then the value will be moved. If `T` is copy constructible then the value will be copied. 

The `emplace_back(Args...)` will take a variadic pack of constructor arguments, and then perfectly forward them to the constructor of a `T` object, that will be placed at the end of the container. A reference to the newly constructed object is returned by `emplace_back()`, for convenience, in case the user-code would like to use it right away.

We would like to first check whether the container is full. We have a dichotomy. If the container is full, we take the so-called slow path, else we take the fast lane.

### `push_back_slow_path(value)`

In this case, we would like to grow our container; we allocate more memory, than what the container currently holds. We leave the memory uninitialized. Memory allocation, can of course, fail. 

We then add the new value at the index `m_size`. Appending the new element may fail.

We copy/move construct the existing elements of the container from the old storage to the new block of storage. 

If all three steps were successful, we deallocate the old storage and return it back before replacing the values in the member variables `m_data`, `m_size` and `m_capacity`.

If either of the last couple of steps fail, we free the newly obtained block of storage. 

### `push_back_fast_path(value)`

In this case, we simply copy/move construct `value` at the end of the container and update the size of the container. 

### Edge-case 

Consider the following edge-case, where the `value` to be added is an element of the vector itself. If there is a reallocation, then the elements of the container are relocated to a new region. So, `value` might become a dangling reference. 

```cpp
dev::vector<int> vec{ 1 };
for (int i = 0; i < 10; ++i) {
    vec.push_back(vec.back());
    EXPECT_EQ(vec.back(), 1);
}
```
Our design takes care of this edge case.

```cpp
template<typename U>
void push_back_slow_path(U&& value){
    // allocate more memory
    size_type offset = size();
    size_type new_size = m_size + 1;
    size_type new_capacity = growth_factor * capacity();
    auto ptr_new_blk = allocate_helper(new_capacity);

    try{
        // Copy-construct the new value at the index m_size
        std::construct_at(ptr_new_blk + m_size, value);
    }catch(std::exception& ex){
        deallocate_helper(ptr_new_blk);
        throw ex;   // rethrow                
    }
    
    try{
        // copy/move construct the existing elements 
        // of the container from the old storage 
        // to the new block of storage.
        copy_old_storage_to_new(m_data, m_size, ptr_new_blk);
    }catch(std::exception& ex){
        std::destroy_at(ptr_new_blk + m_size);
        deallocate_helper(ptr_new_blk);
        throw ex;   // rethrow
    }

    // deallocate the old storage, if we are here
    deallocate_helper(m_data);

    m_data = ptr_new_blk;
    ++m_size;
    m_capacity = new_capacity;
}

template<typename U>
void push_back_fast_path(U&& value){
    std::construct_at(m_data + m_size, value);
    ++m_size;
}        

template<typename U>
void push_back(U&& value)
{
    if(is_full())
    {
        push_back_slow_path(std::forward<U>(value));
    }
    else{
        push_back_fast_path(std::forward<U>(value));
    }
}
```        

### Coding up `emplace_back`

Again we have a fork - `emplace_back_slow_path` and `emplace_back_fast_path`.

```cpp
template<typename... Args>
reference emplace_back_slow_path(Args... args){
    // allocate more memory
    size_type offset = size();
    size_type new_size = m_size + 1;
    size_type new_capacity = growth_factor * capacity();
    auto ptr_new_blk = allocate_helper(new_capacity);

    try{
        // copy/move construct the existing elements 
        // of the container from the old storage 
        // to the new block of storage.
        copy_old_storage_to_new(m_data, m_size, ptr_new_blk);
    }catch(std::exception& ex){
        deallocate_helper(ptr_new_blk);
        throw ex;   // rethrow
    }

    std::construct_at(ptr_new_blk + m_size, std::forward<Args>(args)...);
    deallocate_helper(m_data);
    m_data = ptr_new_blk;
    ++m_size;
    return back();
}

template<typename... Args>
reference emplace_back_fast_path(Args... args){
    std::construct_at(m_data + m_size, std::forward<Args>(args)...);
    ++m_size;
    return back();
}

template<typename... Args>
reference emplace_back(Args... args){
    if(is_full())
        return emplace_back_slow_path(std::forward<Args>(args)...);
    else
        return emplace_back_fast_path(std::forward<Args>(args)...);
}
```

## Implementing `pop_back()`

`pop_back()` should call the destructor of the element at index `m_size - 1`. `std::destroy_at(T* p)` calls the destructor of the object pointed to by `p`. It is equivalent to `p->~T()`. We must not forget to decrement the size of the container.

```cpp
void pop_back() {
	T* ptr_to_last = m_data + m_size - 1;
	std::destroy_at(ptr_to_last);
	--m_size;
}
```

## Implementing 
## Implementing `insert(const_iterator position, It first, It last)`

The `insert` function inserts the given value into the vector before the specified `position`, possibly using move-semantics. Note that, this
kind of operation could be expensive for a vector, and if it is 
frequently used, it can trigger reallocation. 

Our `insert` function will be generic enough with the following interface:

```cpp
template<class It>
iterator insert(const_iterator pos, It first, It last)
```

It inserts the range `[first,last)` at position `pos` (immediately prior to element currently at `pos`).

There are $4$ steps to be considered here:

- How many elements should be copied or moved from the `[begin(), end())` range to the uninitialized memory block at the end of the container?
- If there are elements from the `[first,last)` sequence to insert in raw memory (there could be none), how many should be there?
- If there are elements to copy or move from `[pos,end())` sequence to copy or move as a replacement to existing objects in the container(there could be none), how many should be there?
- Finally, whatever remains to be inserted from the `[first,last)` sequence will be copied in the container starting at `pos`.

Here is a possible implementation:

```cpp
template<typename U>
iterator insert_slow_path(const_iterator insert_it, U&& value){
    // If a reallocation is triggered, all iterators are
    // invalidated and additionally `value` would also become a
    // dangling reference, if it refers to an existing element of
    // the vector.
    // TODO
}

template<typename U>
iterator insert_fast_path(const_iterator position, U&& value){
    auto pos_ = position;
    if constexpr (std::is_nothrow_move_constructible_v<T>) {
        std::uninitialized_move(end() - 1, end(), end());
        std::move_backward(pos_, end(), end());
        *pos_ = std::move(value);
    } else {
        std::uninitialized_copy(end() - 1, end(), end());
        std::copy_backward(pos_, end(), end());
        *pos_ = value;
    }
    ++m_size;
    return pos_;
}

template<typename U>
iterator insert(const_iterator position, U&& value)
{
    if(is_full())
        return insert_slow_path(position, std::forward<U>(value));
    else
        return insert_fast_path(position, std::forward<U>(value));
}
```

## Conclusion

You can find the complete source listing and unit tests online at [https://compiler-explorer.com/z/f4Esbhv6d](https://compiler-explorer.com/z/f4Esbhv6d). 

![](qr_code.png){width=200px height=200px}

## References
-  