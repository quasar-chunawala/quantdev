---
title: "Implementing `vector<T>`"
author: "Quasar"
date: "2025-12-15"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Writing your own `vector<T>` training implementation

In this blog post, we will write a naive `vector<T>` training implementation. Coding up these training implementations, handling corner cases, getting your code reviewed, revisiting your design is very effective at understanding the inner workings of STL data-strucures and writing good C++ code. I adopt a gradual refinement approach, so my first versions will be simpler but less efficient. 

> #### *If you know `std::vector`, you know half of C++.*
>
> -- Bjarne Stroustrup

Informally, a `std::vector<T>` represents a dynamically allocated array that can grow as needed. As with any array, a `std::vector<T>` is a sequence of elements of type `T` arranged contigously in memory. We will put our homegrown version of `vector<T>` under the `dev` namespace. 

The internal representation of a `vector` like type has a book-keeping node that consists of:
- A pointer to the raw data (a block of memory that will hold elements of type `T`)
- Size of the container(the number of elements in the container)
- Capacity

It's important to distinguish between `size` and `capacity`. `size` is the number of elements currently in the container. When `size == capacity`, the container becomes full and will need to grow, which means allocating more member, copying the elements from the old storage to the new storage and getting rid of the old storage. 

For those of you, who want to first attempt writing a basic implementation yourself, I present it in the form a task. 

## The problem statement

> #### Your Task

Implement your own version of a vector with the following methods:

- `push_back` – Adds an element to the back.
- `at` – Retrieves an element by index.
- `getSize` – Gets the size of the container.
- `getCapacity` – Gets the capacity of the container.
- `shrinkToFit` – Shrinks the capacity to equal the size of the container.
- `pop_back` – Removes the last element in the container. Will never be called on an empty container.

> #### Requirements

- Do not worry about memory alignment or advanced optimizations.
- Do not use `std::vector` in your `dev::vector` implementation.
- Your vector's capacity must start at 1.
- The capacity should triple every time it is reached.

For more such C++ coding tasks, visit [getcracked.io](https://getcracked.io/problem/1/implement-vector). 

## A basic implementation

Take a look at my submission. I used uninitialized memory algorithms, where necessary. 

```cpp
// Write your solution here
// C++20 for C++

#include <cstddef>
#include <cstdint>
#include <format>
#include <initializer_list>
#include <memory>
#include <print>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace getcracked {
template <typename Element>
class vector {
    constexpr static std::size_t initial_capacity{1};

   private:
    Element* m_data;
    std::size_t m_size;
    std::size_t m_capacity;

   public:
    std::size_t get_size() const { return m_size; }
    std::size_t get_capacity() const { return m_capacity; }
    vector()
        : m_data{static_cast<Element*>(operator new(sizeof(Element)))},
          m_size{0},
          m_capacity{initial_capacity} {}

    vector(size_t n, Element& initial_value)
        : m_data{static_cast<Element*>(operator new(sizeof(Element) * n))},
          m_size{0},
          m_capacity{n} {
        try {
            std::uninitialized_fill_n(m_data, n, initial_value);
            m_size = n;
        } catch (std::exception& ex) {
            operator delete(m_data);
            m_capacity = 0;
        }
    }

    vector(std::initializer_list<Element> list)
        : m_data{static_cast<Element*>(operator new(sizeof(Element) *
                                                    list.size()))},
          m_size{list.size()},
          m_capacity{list.size()} {
        try {
            if constexpr (std::is_nothrow_move_constructible_v<Element>) {
                std::uninitialized_move(list.begin(), list.end(), m_data);
            } else {
                std::uninitialized_copy(list.begin(), list.end(), m_data);
            }
        } catch (std::exception& ex) {
            operator delete(m_data);
            m_size = 0;
            m_capacity = 0;
        }
    }

    vector(const vector& other)
        : m_data{operator new(sizeof(Element) * other.get_size())},
          m_size{other.get_size()},
          m_capacity{other.get_capacity()} {
        try {
            // Perform a deep-copy of all the elements
            std::uninitialized_copy(other.m_data, other.m_data + other.m_size,
                                    m_data);
        } catch (std::exception& ex) {
            operator delete(m_data);
            std::string error_msg =
                std::format("Error while copying in copy ctor {}", ex.what());
            throw std::logic_error(error_msg);
        }
    }

    vector(vector&& other) noexcept
        : m_data{std::exchange(other.m_data, nullptr)},
          m_size{std::exchange(other.m_size, 0)},
          m_capacity{std::exchange(other.m_capacity, 0)} {}

    void swap(vector& other) noexcept {
        std::swap(this->m_data, other.m_data);
        std::swap(this->m_size, other.m_size);
        std::swap(this->m_capacity, other.m_capacity);
    }

    vector& operator=(const vector& other) {
        vector(other).swap(*this);
        return *this;
    }

    vector& operator=(vector&& other) {
        vector(std::move(other)).swap(*this);
        return *this;
    }

    bool is_full() { return get_size() == get_capacity(); }

    void push_back(Element element) {
        std::size_t offset = get_size();
        if (m_size == m_capacity - 1) {
            // Allocate new memory
            std::size_t new_size = get_size() + 1;
            std::size_t new_capacity = 3 * m_capacity;
            Element* new_memory_block = static_cast<Element*>(operator new(
                sizeof(Element) * new_capacity));
            Element* ptr_to_new_element{nullptr};

            try {
                // Construct the new element in new memory block
                ptr_to_new_element =
                    new (new_memory_block + offset) Element(element);
            } catch (std::exception& ex) {
                operator delete(new_memory_block);
                std::string error_msg = std::format(
                    "Failed to copy-construct element : {}", ex.what());
                throw std::logic_error(error_msg);
            }

            try {
                // Copy/move- the elements from the old storage to new
                if constexpr (std::is_nothrow_move_constructible_v<Element>) {
                    std::uninitialized_move(m_data, m_data + offset,
                                            new_memory_block);
                } else {
                    std::uninitialized_copy(m_data, m_data + offset,
                                            new_memory_block);
                }
            } catch (std::exception& ex) {
                std::destroy_at(ptr_to_new_element);
                operator delete(new_memory_block);
                std::string error_msg = std::format(
                    "Failed to copy/move data from old to new storage, "
                    "exception : {}",
                    ex.what());
                throw std::logic_error(error_msg);
            }

            // Destroy the objects in the old storage
            auto p{m_data};
            for (auto p{m_data}; p < m_data + m_size; ++p) {
                p->~Element();
            }

            // Deallocate old storage
            operator delete(m_data);

            // Reassign internal buffer pointer and update size and capacity
            m_data = new_memory_block;
            m_size = new_size;
            m_capacity = new_capacity;
        } else {
            try {
                std::construct_at(m_data + offset, element);
                m_size += 1;
            } catch (std::exception& ex) {
                std::string error_msg = std::format(
                    "Failed to copy-construct element, exception : {}",
                    ex.what());
                throw std::logic_error(error_msg);
            }
        }
    }

    const Element& at(std::size_t index) const {
        if (index < 0 || index >= m_size)
            throw std::out_of_range("Array index out of bounds!");

        return m_data[index];
    }
    void shrink_to_fit() {
        // Allocate a new memory block of capacity = m_size
        Element* new_memory_block =
            static_cast<Element*>(operator new(sizeof(Element) * m_size));

        try {
            // Copy/move the elements from the old storage to new storage
            if constexpr (std::is_nothrow_move_constructible_v<Element>) {
                std::uninitialized_move(m_data, m_data + m_size,
                                        new_memory_block);
            } else {
                std::uninitialized_copy(m_data, m_data + m_size,
                                        new_memory_block);
            }
        } catch (std::exception& ex) {
            operator delete(new_memory_block);
            std::string error_msg = std::format(
                "Internal error in shrink_to_fit() : {}", ex.what());
            throw std::logic_error(error_msg);
        }

        // Destroy objects in old storage and deallocate memory
        for (auto p{m_data}; p < m_data + m_size; ++p) {
            std::destroy_at<Element>(p);
        }
        // Deallocate memory
        operator delete(m_data);

        // Reassign internal buffer pointer and set size and capacity
        m_data = new_memory_block;
        m_capacity = m_size;
    }
    void pop_back() {
        Element* ptr_to_last = m_data + m_size - 1;
        std::destroy_at(ptr_to_last);
        --m_size;
    }
};
}  // namespace getcracked

int main() {
    getcracked::vector<double> v;
    v.push_back(1);
    v.push_back(2);
    std::println("v[0] = {}", v.at(0));
    std::println("size = {}", v.get_size());
    std::println("capacity = {}", v.get_capacity());
}
```
[Compiler Explorer](https://compiler-explorer.com/z/M491zKcdz)

## Adding support for other methods

### Iterators 

C++ containers usually expose iterators as part of their interface and ours will be no exception. We will define type aliases for the `const` and non-`const` iterator types, as this makes it simpler to implement alternatives.

```cpp
// ...
template <typename T>
class vector {
    using value_type = T;
    using size_type = std::size_t;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using iterator = pointer;
    using const_iterator = const_pointer;
    constexpr static std::size_t initial_capacity{1};

private:
    pointer m_data;
    size_type m_size;
    size_type m_capacity;

public:

    iterator begin(){ return m_data; }
    const_iterator begin() const{ return m_data; }
    iterator end(){ return begin() + m_size; }
    const_iterator end() const{ return begin() + m_size; }
// ...
```
[Compiler Explorer](https://compiler-explorer.com/z/MojqWhezr)

### Basic services of a vector-like class
There is more to writing a convenient dynamic array type. For example, member functions that let you access the `first()` element or the last `back()` element or that let you access the element at a specific index in the array using square brackets are all to be expected.

```cpp
// ...
reference operator[](size_type idx){
    return m_data[idx];
}

const_reference operator[](size_type idx) const{
    return m_data[idx];
}

// precondition: !empty()
reference front(){ return (*this)[0]; }
const_reference front() const { return (*this)[0]; }
reference back(){ return (*this)[m_size - 1]; }
const_reference back() const{ return (*this)[m_size - 1]; }
```

Comparing two `vector<T>` objects for equivalence or lack thereof is a relatively easy matter if we use algorithms:

```cpp
//...
bool operator==(const vector& other){
    return size() == other.size() && 
        std::equal(begin(), end(), other.begin());
}
```

### Implementing `reserve()`

`reserve(size_type new_capacity)` increases the capacity of the vector(the total number of elements that the vector can hold without requiring reallocation) to a value that's greater or equal to `new_capacity`. If `new_capacity` is greater than the current `capacity()`, new storage is allocated, otherwise the function does nothing.

We introduce the helper functions `allocate_helper` and `copy_old_storage_to_new`. 

```cpp
// Dynamically allocates a chunk of uninitialized memory on the heap
// that can hold `new_capacity` number of elements.
// Allocation excepts are propogated to the caller.
pointer allocate_helper(size_type new_capacity){
    return static_cast<pointer>(operator new(sizeof(value_type) * new_capacity));
}

void deallocate_helper(pointer ptr){
    operator delete(ptr);
}

// Copies elements from old storage to new
// If T's copy/move ctor throws, the objects already constructed are
// destroyed and the exception is propagated to the caller.
void copy_old_storage_to_new(pointer source_first, size_t num_elements, pointer destination_first){
    if constexpr(std::is_nothrow_move_constructible_v<T>){
        std::uninitialized_move(source_first, source_first + num_elements, destination_first);
    }
    else{
        try{
            std::uninitialized_copy(source_first, source_first + num_elements, destination_first);
        }catch(std::exception& ex){
            throw ex;
        }
    }
}

void reserve(size_type new_capacity){
    if(new_capacity <= capacity())
        return;
    
    auto ptr_new_blk = allocate_helper(new_capacity);
    try{
        copy_old_storage_to_new(m_data, m_size, ptr_new_blk);
    }catch(std::exception& ex){
        deallocate_helper(ptr_new_blk);
        throw ex;   // rethrow
    }
    
    std::destroy(m_data, m_data + m_size);
    deallocate_helper(m_data);
    m_data = ptr_new_blk;
    m_capacity = new_capacity;    
}
```

### Implementing `resize()`

The `resize(size_type count)` method resizes the container to contain `count` elements:

- If the `count` is equal to the current size, do nothing. 
- 