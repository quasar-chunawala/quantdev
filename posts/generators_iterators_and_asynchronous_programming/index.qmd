---
title: "Generators, iterators and asynchronous programming"
author: "Quasar"
date: "2025-11-24"
categories: [Python]      
image: "python.svg"
toc: true
toc-depth: 3
---

# What is a generator?

A generator is a function that uses the `yield` keyword to return an item. When a generator function is called, it returns a generator object, which is a type of iterator. Here is a simple generator, that produces a sequence of numbers:

```{python}
def number_generator(n):
    for i in range(n):
        yield i

gen = number_generator(1_000_000)

print(next(gen))
print(next(gen))
print(next(gen))
```

The state of the generator is saved between `yield` calls. This allows it to resume where it left off.

The main use of generators is to save memory - instead of having a very large list of elements in memory, holding everythinat once, we have an object that knows how to produce each particular element, one at a time. This enables lazy computations of heavy objects in memory

# Example: Flattening a list of lists

A common task is to flatten a list of lists into a single list. 

Imagine you have a list of trades

```{python}

```