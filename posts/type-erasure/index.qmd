---
title: "C++ Type erasure"
author: "Quasar"
date: "2025-12-18"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

Once you instantiate a `std::function` object, how is it, that *you are able to stick objects of different actual types e.g. an anonymous lambda, a free-standing function or a function-pointer (with only a common function signature)* to it? This is achieved through **type erasure**.

Type erasure is a programming technique by which the explicit type information is removed from the program. It is a type of *abstraction* that ensures that the program does not explicitly depend on some of the data-types. You might wonder, how is it, that a program is written in a strongly typed language but does not use the actual types? 

# How does type erasure look like?

The ultimate type-erased object in C++ is `std::function`. Another one is `std::any`. Consider the following code snip:

```cpp
#include <print>
#include <functional>

void print_num(int i){
    std::println("{}", i);
}

auto display_lambda = [](int i){
    std::println("{}", i);
};

struct PrintFunctor{
    void operator()(int i){
        std::println("{}", i);
    }
};

int main()
{
    std::function<void(int)> f_print_num = print_num;
    std::function<void(int)> f_display_lambda = display_lambda;
    std::function<void(int)> f_print_functor = PrintFunctor{};
}
```
[Compiler Explorer](https://compiler-explorer.com/z/1Tz7dWqM7)

The free-standing function `print_num`, the lambda function `diplay_lambda` and the functor `PrintFunctor` are objects with different types. So, the type of object being assigned to the `std::function` changed, but on the left hand side we have the same type. `std::function<void(int)>` can store any of these callable objects. Somehow, we can stick all these different types into it. 

If you look at it from the design point of view, what it does is, it abstracts away all the behavior of the type you erase, except the set of behaviors you consider relevant. It's a very flexible abstraction. In my case, I say, what's relevant is, I can invoke this type with a `int` and I get back a `void`. 

# Type erasure - the basic mechanics 

## Step 1 - How to write a container that holds unrelated types?

On cppreference.com, `std::function` is defined as follows:

:::{.callout}
```cpp
template< class R, class... Args >
class function<R(Args...)>;
```

*The class template `std::function` is a general-purpose polymorphic function wrapper.*
:::

`std::function` has to be polymorphic, meaning it has to be able to hold completely unrelated types. They don't have to be bound by an inheritance-hierarchy or any other sort of thing. 

Our end-goal looks something like this:

```cpp
struct MagicFunctionContainer
{};

MagicFunctionContainer f1 = print_num;
MagicFunctionContainer f2 = [](int i){ std::println({}, i); };
MagicFunctionContainer f3 = PrintFunctor{};
```

We should be able to assign different objects of types like a free-standing function, a lambda expression or a functor to this `MagicFunctionContainer`. 

Let's start with designing a container, which is constructible from completely unrelated types:

```cpp
struct MagicFunctionContainer{
    template<typename Func>
    MagicFunctionContainer(Func&& func)
    : m_func{std::forward<Func>(func)} 
    {}

    void operator()(int i){
        m_func(i);
    }

    private:
    //void(*)(int) m_func;   // we need to think
                             // of m_func's type
};
```

We see that, there's this container called `MagicFunctionContainer`. The most important thing to note is that, its constructor is now a templated constructor, so you can pass any type into the `MaginFunctionContainer` constructor, and it simply forwards the object `func` into `m_func`. We need to think, what the type of `m_func` is. We see that this function container also implements a function call operator `operator()`, which accepts an integer and returns type `void`. So, when this function container object is invoked with an integer `i`, it simply calls `m_func(i)` under the hood. 

As long as we have defined the type of `m_func`, and its the correct type, this code satisfies our requirements. We now have a container, that can be constructed from completely unrelated types. How do we store these unrelated types? How do we now define what the type of `m_func` should be? The answer to this puzzle is step-2 of our design.

## Step 2 - Can `m_func` be a polymorphic pointer to a place on the heap that will hold these unrelated types?

The classic type erasure pattern can be realized by first coding up a *type-agnostic interface* (a `Concept` class). Then we use an `Impl` class that wraps up the concrete type & provides the *type-dependent implementation*. Finally, we use dynamic polymorphism via virtual functions, but the caller only sees the interface. 

```cpp
// Type erasure 101
#include <iostream>
#include <memory>

namespace dev{
    struct Concept{
        virtual void operator()(int i) = 0;
        ~virtual Concept(){}
    };

    template<typename Callable>
    struct Impl{

        Impl(const Callable& callable) 
        : m_callable{callable}
        {}

        void operator()(int i){
            m_callable(i);
        }
        
        Callable m_callable;
    };
};
```

Each time I get any new type `Callable`, I am creating an implementation `Impl<Callable>`, and passing that object into this new type.

Any type `Callable` that implements `operator()(int)` can be stored in `Impl<Callable>`. And `Impl<Callable>` inherits from `Concept`. 

Now, what we've achieved so far is, that any `Impl<Callable>` object, as long as `Callable` implements the function call operator `operator()`, accepts an `int`, returns `void` can be assigned to a pointer to `Concept`, `Concept*`. Remember, all types `Impl<Callable_1>`, `Impl<Callable_2>`, ..., `Impl<Callable_n>` inherit from `Concept`.

We can now finish the revisit the definition of `MagicFunctionContainer`. 

```cpp
struct MagicFunctionContainer{
    template<typename Func>
    MagicFunctionContainer(Func&& func)
    : m_func{new Impl<Func>(func)} 
    {}

    void operator()(int i){
        if(m_func == nullptr)
            throw std::bad_function_call();

        (*m_func)(i);
    }

    private:
    Concept* m_func{nullptr};   
};
```

In the `MagicFunctionContainer`, I have still got the templated constructor. I have still got the function call operator. But, now I have type for `m_func`. `m_func` is a pointer to `Concept`. In the templated constructor, now what I'm doing is, each time I get any type `Func` 

# Type erasure - Adding support for a custom deleter to the `shared_ptr`

Suppose we'd like to add support for a custom deleter to the `shared_ptr`. 

```cpp
#include <iostream>

template<typename T>
class shared_ptr{

    private:
    T* m_underlying_ptr;
    std::atomic<unsigned long>* m_ref_count;
    // something about the deleter

    public:
    // Templated constructor
    template<typename Deleter>
    shared_ptr(T* ptr, Deleter deleter)
    : m_underlying_ptr{ptr}
    // ???  
    {}

    // Destructor
    ~shared_ptr(){
        // Decrement the ref-count. If m_ref_count == 0, 
        // delete m_underlying_ptr using deleter 
    }

    // Pointer like functions
    const T* operator->() const{
        return m_underlying_ptr;
    }
};
```
[Compiler Explorer](https://compiler-explorer.com/z/8oq3Kf361)

We add a templated constructor `shared_ptr(T*, Deleter )` that accepts a raw pointer and a custom deleter as the second argument to the design of our `shared_ptr`.

Let's now write a `Concept` and `Impl` class that support destruction using an instance of the custom `Deleter` type.

```cpp
    struct destroy_wrapper // RAII class
    {
        /* ... */

        // Concept class
        struct destroyer_base
        {
            virtual void operator()(void* ptr) = 0;
            virtual ~destroyer_base() = default;
        };

        // Impl class
        template<typename Deleter>
        struct destroyer : public destroyer_base
        {
            explicit destroyer(Deleter deleter)
              : destroyer_base()
              , m_deleter{ deleter }
            {
            }

            void operator()(T* ptr) override { m_deleter(ptr); }

            Deleter m_deleter;
        };

        ~destroy_wrapper() {}
        std::unique_ptr<destroyer_base> m_destroyer_ptr;
    };
```

The `destroyer_base` is the *Concept* class and the `destroyer` is its type-dependent *implementation*.

The wrapper class `destroyer_wrapper` wraps objects of different  types (`destoyer<Deleter>`) into a common wrapper and treats them as though they are the same unified interface. 

THe updated design of the `shared_ptr<T>` class would look something like this:

```cpp
template<typename T>
class shared_ptr
{
    private:
    T* m_underlying_ptr;
    std::atomic<unsigned long>* m_ref_count_ptr;
    destroyer_wrapper* m_destroyer_ptr;

    public:
    // Templated constructor
    template<typename Deleter>
    shared_ptr(T* ptr, Deleter&& deleter)
    : m_underlying_ptr{ ptr }
    , m_ref_count_ptr{ nullptr }
    , m_destroyer_ptr{ nullptr }
    {
        try{
            m_destroyer_ptr = new destroy_wrapper(std::forward<Deleter>(deleter));
            m_ref_count_ptr->store(1u);
        } catch(std::exception& ex) {
            delete ptr;
            throw ex;
        }
    }

    /* ... */

    struct destroy_wrapper // RAII class
    {
        template<typename Deleter>
        explicit destroy_wrapper(Deleter&& deleter)
          : m_destroyer_ptr{ std::make_unique<destroyer>(std::forward<Deleter>(deleter)) }
        {
        }
        // destroy_wrapper is a wrapper over a unique_ptr<destroyer_base>.
        // It is intended to be move-constructible ONLY.
        destroy_wrapper(destroy_wrapper&& other) noexcept
          : m_destroyer_ptr{ std::exchange(other.m_destroyer_ptr, nullptr) }
        {
        }

        void operator()(pointer ptr)
        {
            (*m_destroyer_ptr)(ptr); // Virtual polymorphism
        }

        struct destroyer_base
        {
            virtual void operator()(pointer ptr) = 0;
            virtual ~destroyer_base() = default;
        };

        template<typename Deleter>
        struct destroyer : public destroyer_base
        {
            explicit destroyer(Deleter deleter)
              : destroyer_base()
              , m_deleter{ deleter }
            {
            }

            void operator()(pointer ptr) override { m_deleter(ptr); }

            Deleter m_deleter;
        };

        ~destroy_wrapper() {}
        std::unique_ptr<destroyer_base> m_destroyer_ptr;
    };
};
```




