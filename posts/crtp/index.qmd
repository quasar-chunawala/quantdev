---
title: "CRTP(Curiously recurring template pattern)"
author: "Quasar"
date: "2024-12-28"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
comments:
  giscus: 
    repo: quasar-chunawala/quantdev
format:
    html:
        code-tools: true
        code-block-border-left: true
        code-annotations: below
        highlight-style: pygments
---

# Introduction

Imagine you have an inheritance hierarchy to implement mathematical interpolation.

```cpp
#include <concepts>
#include <exception>
#include <vector>
#include <cmath>
#include <string>
#include <algorithm>
#include <stdexcept>
#include <iostream>
#include <memory>

template<typename I1, typename I2>
class LinearInterpolatorBase{
    public:
    std::vector<double> xValues(){
        return std::vector<double>(m_xBegin, m_xEnd);
    }
    std::vector<double> yValues(){
        return std::vector<double>(m_yBegin, m_yEnd);
    }

    void safetyCheck(){
        if(!(static_cast<int>(m_xEnd - m_xBegin) >= 2)){
            std::string errorMessage = "not enough points to interpolate : at least ";
            errorMessage += m_requiredPoints + " required, ";
            throw std::logic_error(errorMessage);
        }
        
        for(I1 i{m_xBegin}, j{m_xBegin + 1}; j!=m_xEnd; ++i, ++j){
            if(*i > *j){
                throw std::logic_error("unsorted x values");
            }
        }
    }
    
    int locate(double x){
        safetyCheck();
        return std::distance(m_xBegin, std::upper_bound(m_xBegin, m_xEnd, x));
    }

    virtual double value(double) = 0;
    
    void determineBracket(double& x1, double& x2, double &y1, double& y2, double x){
        int N = static_cast<int>(this->m_xEnd - this->m_xBegin);
        int j = this->locate(x);

        if(j == 0)
        {
            x1 = *(this->m_xBegin);
            y1 = *(this->m_yBegin);
            x2 = *(this->m_xBegin + 1);
            y2 = *(this->m_yBegin + 1);
        }else if(j == N){
            x1 = *(this->m_xEnd - 2);
            y1 = *(this->m_yEnd - 2);
            x2 = *(this->m_xEnd - 1);
            y2 = *(this->m_yEnd - 1);
        }else{
            x1 = *(this->m_xBegin + j - 1);
            y1 = *(this->m_yBegin + j - 1);
            x2 = *(this->m_xBegin + j);
            y2 = *(this->m_yBegin + j);
        }
    }
    
    LinearInterpolatorBase(I1 xBegin, I1 xEnd, I2 yBegin, I2 yEnd)
    : m_xBegin(xBegin)
    , m_xEnd(xEnd)
    , m_yBegin(yBegin)
    , m_yEnd(yEnd)
    {}
    
    protected:
    I1 m_xBegin;
    I1 m_xEnd;
    I2 m_yBegin;
    I2 m_yEnd;
    const int m_requiredPoints {2};
};

template<typename I1, typename I2>
class LinearInterpolator : public LinearInterpolatorBase<I1, I2>{
public:
    double value(double x) override{
        double x1{0.0}, x2{0.0}, y1{0.0}, y2{0.0}, y{0.0};
        this->determineBracket(x1, x2, y1, y2, x);
        
        double t {(x - x1)/(x2 - x1)};
        
        return (1 - t) * y1 + t * y2;
    }

    LinearInterpolator(I1 xBegin, I1 xEnd, I2 yBegin, I2 yEnd)
    : LinearInterpolatorBase<I1,I2>(xBegin, xEnd, yBegin, yEnd) {}
};

template<typename I1, typename I2>
class LogLinearInterpolator : public LinearInterpolatorBase<I1, I2>{
public:
    double value(double x) override{
        double x1{0.0}, x2{0.0}, y1{0.0}, y2{0.0}, y{0.0};
        this->determineBracket(x1, x2, y1, y2, x);
        
        double t {(x - x1)/(x2 - x1)};
        
        return exp((1 - t) * log(y1) + t * log(y2));
    }
    
    LogLinearInterpolator(I1 xBegin, I1 xEnd, I2 yBegin, I2 yEnd)
    : LinearInterpolatorBase<I1,I2>(xBegin, xEnd, yBegin, yEnd) {}
};



int main(int argc, const char * argv[]) {
    std::vector<double> discountFactors{
        1, 0.9523, 0.9070, 0.8683, 0.8227,0.7835,
        0.7462, 0.7106, 0.6768, 0.6446, 0.6139
    };
    
    std::vector<double> times{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    };
    
    double result{0.0};

    using VectorOfRealsIterator = std::vector<double>::iterator;

    std::shared_ptr<LinearInterpolatorBase<VectorOfRealsIterator,VectorOfRealsIterator>> interpolator{};

    interpolator = std::make_shared<LinearInterpolator<VectorOfRealsIterator,VectorOfRealsIterator>>(
        times.begin(),
        times.end(),
        discountFactors.begin(),
        discountFactors.end()
    );

    result = interpolator->value(2.5);
    std::cout << "\nResult of linear interpolation y-value = " << result;

    interpolator = std::make_shared<LogLinearInterpolator<VectorOfRealsIterator, VectorOfRealsIterator>>(
        times.begin(),
        times.end(),
        discountFactors.begin(),
        discountFactors.end()
    );

    result = interpolator->value(2.5);
    std::cout << "\nResult of log-linear interpolation y-value = " << result;
    return 0;
}
```

[Compiler Explorer](https://godbolt.org/z/orPG3ETdn)

The base class `LinearInterpolationBase` has a pure virtual function `value` and the child classes `LinearInterpolation` and `LogLinearInterpolation` will override this virtual function doing different things. This is called **dynamic polymorphism**. 

The implementation of `double value(double)` chosen at run-time is determined by the object bound to the base class pointer/reference. 

You can also overload free-standing functions or class member functions, provided they have different type/number of arguments. For example, you can over the `+` operator to support addition of two `std::vector`s component-wise. And this is the compile-time version of polymorphism, called **static polymorphism**.

Dynamic polymorphism incurs a performance cost because in order to know what functions to call, the compiler needs to build a table of pointers to virtual functions. So, there is some level of indirection when calling virtual functions polymorphically. 

Can we get the benefits of dynamic polymorphism at compile time? One way to achieve that is the Curiously Recurring Template Patter(CRTP).


