---
title: "Custom iterators and Iterator concepts"
author: "Quasar"
date: "2025-05-05"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

An iterator is a generalization of a pointer. C++ STL containers usually expose iterators as part of their interface. They abstract away lower-level implementation details of traversing through container types, thus freeing the container-user to focus on algorithm design/business logic.

# Traditional C++ iterators

Iterators have been around since before C++11, but they really hit mainstream since C++11 started shipping. The STL containers all implement their own iterators, however, it's possible for developers to write their own iterators for custom collections.

In the past, you'd implement iterators using [tagging](https://en.cppreference.com/w/cpp/iterator/iterator_tags). A tag is simply an empty struct, with no data or behavior. It is often used to perform static dispatching (compile-time polymorphism). Here is a minimalistic example:

```cpp
#include<iostream>

namespace dev{
    struct random_access_iterator_tag{};
    struct forward_iterator_tag{};

    template<typename T>
    struct vector{
        T* m_data;
        std::size_t m_size;
        std::size_t m_capacity;
        
        struct iterator{
            using iterator_category = random_access_iterator_tag;
            /* .... */
            T* m_ptr;
        };

        iterator begin(){
            return(iterator(m_data));
        }
    };

    template<typename T>
    struct list{
        struct node{
            T data;
            node* next;
        };

        node* head;
        std::size_t m_size;
        struct iterator{
            using iterator_category = forward_iterator_tag;
            /* .... */
            node* m_ptr;
        };

        iterator begin(){
            return(iterator(head));
        }
    };

    template<typename It>
    It advance(It iterator, std::size_t n, forward_iterator_tag){
        std::cout << "\n" << "Advance a foward iterator";
        return iterator;
    }

    template<typename It>
    It advance(It iterator, std::size_t n, random_access_iterator_tag){
        std::cout << "\n" << "Advance a random access iterator";
        return iterator;
    }
}

int main(){
    dev::vector<int> vec;
    dev::list<int> lst;

    auto it = vec.begin();
    dev::advance(it, 3, dev::vector<int>::iterator::iterator_category());

    auto it2 = lst.begin();
    dev::advance(it2, 3, dev::list<int>::iterator::iterator_category());
}
```
[Compiler Explorer](https://godbolt.org/z/q7YGG8oj5)

An iterator over a custom array-like sequence of elements would look like the following:

```cpp
#include <iterator>

template <class T>
struct Iterator {
    using iterator_category = std::forward_iterator_tag;
    using value_type = T;
    using difference_type = std::ptrdiff_t;
    using pointer = T*;
    using reference = T&;

    // ...rest of iterator implementation here
};
```

This requires you to write a lot of boiler-plate code. While tagging works, it puts an extra-burden on the developer.

# Modern C++ iterators

C++20 has a language feature called [concepts](https://quantdev.blog/posts/c++20-concepts/index.html) - a set of named constaints that a type should satisfy. So, we can now implement iterators based on their behavior, rather than their *identity*. This is often referred to as **duck typing**: the idea that *if an entity looks like a duck and quacks like a duck, it must be a duck.*



