---
title: "Custom iterators and Iterator concepts"
author: "Quasar"
date: "2025-05-05"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

An iterator is a generalization of a pointer. C++ STL containers usually expose iterators as part of their interface. They abstract away lower-level implementation details of traversing through container types, thus freeing the container-user to focus on algorithm design/business logic.

# Traditional C++ iterators

Iterators have been around since before C++11, but they really hit mainstream since C++11 started shipping. The STL containers all implement their own iterators, however, it's possible for developers to write their own iterators for custom collections.

In the past, you'd implement iterators using [tagging](https://en.cppreference.com/w/cpp/iterator/iterator_tags). A tag is simply an empty struct, with no data or behavior. It is often used to perform static dispatching (compile-time polymorphism). Here is a minimalistic example:

```cpp
#include<iostream>

namespace dev{
    struct random_access_iterator_tag{};
    struct forward_iterator_tag{};

    template<typename T>
    struct vector{
        T* m_data;
        std::size_t m_size;
        std::size_t m_capacity;

        iterator begin(){
            return(iterator(m_data));
        }

        struct iterator{
            using iterator_category = random_access_iterator_tag;
            /* .... */
            T* m_ptr;
        };
    }

    template<typename T>
    struct list{
        struct node{
            T data;
            node* next
        };

        node* head;
        std::size_t m_size;

        iterator begin(){
            return(iterator(head));
        }

        struct iterator{
            using iterator_category = forward_iterator_tag;
            /* .... */
            node* m_ptr;
        };
    }

    template<typename It>
    It& advance(It iterator, std::size_t n, forward_iterator_tag){
        std::cout << "\n" << "Advance a foward iterator";
        return iterator;
    }

    template<typename It>
    It& advance(It iterator, std::size_t n, random_access_iterator_tag){
        std::cout << "\n" << "Advance a random access iterator";
        return iterator;
    }
}

int main(){
    dev::vector vec;
    dev::list lst;

    auto it = vec.begin();
    dev::advance(it, 3, dev::vector::iterator::iterator_category);

    auto it2 = lst.begin();
    dev::advance(it2, 3, dev::list::iterator::iterator_category);
}
```
[Compiler Explorer](https://godbolt.org/z/q7YGG8oj5)

An iterator over a custom array-like sequence of elements would look like the following:

```cpp
#include <iterator>

template <class T>
struct Iterator {
    using iterator_category = std::forward_iterator_tag;
    using value_type = T;
    using difference_type = std::ptrdiff_t;
    using pointer = T*;
    using reference = T&;

    // ...rest of iterator implementation here
};
```

