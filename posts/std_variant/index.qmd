---
title: "`std::variant`"
author: "Quasar"
date: "2025-12-23"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Using `std::variant`
A `std::variant` is a closed-discriminated union. Variants simply have internal memory for maximum size of the underlying types plus a fixed overhead to manage which alternative is used. No heap memory is allocated. The resulting object has value semantics. Copying a variant is implemented as a deep-copy, it creates a new variant object with the current value of the alternative in its own memory.

```cpp
#include <iostream>
#include <variant>
#include <string>

int main(){
    // initialized with string alternative
    std::variant<int, std::string> var{"hi"};   
    std::cout << var.index() << "\n";

    // now holds int alternative
    var = 42;
    std::cout << var.index() << "\n";

    try{
        int i = std::get<0>(var);  // access by index
        int j = std::get<int>(var); //access by type
        std::string s = std::get<std::string>(var); //error
    }catch(const std::bad_variant_access& e){
        std::cerr << "Exception: " << e.what() << "\n";
    }
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/Ehqhq3T51)

Output:
```shell
Program returned: 0
Program stdout

1
0

Program stderr

Exception: std::get: wrong index for variant
```

The default constructor for `std::variant` always initializes the first type with the default constructor. If there is no default constructor for the first type, calling the default constructor for the variant is a compile-time error. 

If we still want to have a `std::variant`, we can use the helper type `std::monostate`. They serve as a first alternative type to make the variant type default constructible. Objects of type `std::monostate` only have $1$ state, so they always compare equal. To an extent, you can interprete this state as signalling emptiness.

```cpp
// Ref: C++17 - The complete guide
// Nikolai Josuttis
#include <variant>
#include <print>

struct NoDefConstr{
    NoDefConstr() = delete;
};

int main(){
    // different ways to check for monostate
    std::variant<std::monostate, NoDefConstr, int> v;

    if(v.index() == 0){
        std::println("has monostate");
    }
    if(!v.index()){
        std::println("has monostate");
    }
    if(std::holds_alternative<std::monostate>(v)){
        std::println("has monostate");
    }
    if(std::get_if<0>(&v)){
        std::println("has monostate");
    }
    if(std::get_if<std::monostate>(&v)){
        std::println("has monostate");
    }
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/GbrEYWh7h)


