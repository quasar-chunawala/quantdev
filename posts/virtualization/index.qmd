---
title: "The `virtual` keyword"
author: "Quasar"
date: "2025-05-22"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# `virtual` functions

The `virtual` keyword specifies that a non-static member function is `virtual` and supports dynamic dispatch. It may only appear in the initial declaration of a non-static member function (i.e., when it is declared in the class definition).

```cpp
#include <iostream>

class Base
{
    public:
    void foo(){
        std::cout << "\n" << "Base::foo()";
    }
};

class Derived : public Base{
    public:
    void foo(){
        std::cout << "\n" << "Derived::foo()";
    }
};

int main(){
    Base base_obj;
    Derived derived_obj;
    Base* base_ptr{nullptr};

    base_ptr = &base_obj;
    base_ptr->foo();

    base_ptr = &derived_obj;
    base_ptr->foo();
    return 0;
}
```
Run at [Compiler Explorer](https://godbolt.org/z/jG9bG4Yrs)

Output:
```shell
Base::foo()
Base::foo()
```

The version of `foo` invoked is determined at compile time, based on the pointer type. 

If we declare the `foo()` as a virtual method, then the version of `foo()` invoked is resolved dynamically on-the-fly depending on **the type of object being pointed to** (*pointee*).

```cpp
#include <iostream>

class Base
{
    public:
    virtual void foo(){
        std::cout << "\n" << "Base::foo()";
    }
};

class Derived : public Base{
    public:
    void foo() override{    //override is optional
        std::cout << "\n" << "Derived::foo()";
    }
};

int main(){
    Base b;
    Derived d;
    
    // Virtual function call through reference
    Base& br = b;   // the type of br is Base&
    Base& dr = d;   // the type of dr is Base&
    br.foo();       // Calls Base::foo()
    dr.foo();       // Calls Derived::foo()

    // Virtual function call through pointers
    Base* bp = &b;  // type of bp is Base*
    Base* dp = &d;  // type of dp is Base* as well
    bp->foo();      // Calls Base::foo()
    dp->foo();      // Calls Derived::foo()

    // Non-virtual function calls
    br.Base::foo();
    dr.Base::foo();
    return 0;
}
```

Run at [Compiler Explorer](https://godbolt.org/z/aYhbofMPb)

Output:
```shell
Base::foo()
Derived::foo()
Base::foo()
Derived::foo()
Base::foo()
Base::foo()
```

A derived class `virtual` function is considered an override if and only if it has the same

- name
- parameter type list (but not the return type)
- cv-qualifiers
- ref-qualifiers

```cpp
#include <iostream>

class Base
{
    public:
    virtual void vf(){
        std::cout << "\n" << "Base::vf()";
    }
};

class Derived : public Base{
    public:
    void vf() const{
        std::cout << "\n" << "Derived::vf() const";
    }
};

int main(){
    Base b;
    Derived d;
    const Derived const_d;

    Base* bp{nullptr};

    bp = &b;
    bp->vf();

    bp = &d;
    bp->vf();
    d.vf();
    return 0;
}
```

Output:
```shell
Base::vf()
Base::vf()
Derived::vf() const
```

In the above code snippet, the compiler does not treat `void Derived::vf() const` as an override for the base class virtual member function `void Base::vf()`. 

## Dynamic dispatch

A member function defined as `virtual` in the base class will be `virtual` in all child classes. 

```cpp
#include<iostream>
struct A{
    virtual void vf(){
        std::cout << "\n" << "A::vf()";
    }

    void g(){
        std::cout << "\n" << "A::g()";
    }
};
 
struct B : A{
    void vf() override{
        std::cout << "\n" << "B::vf()";
    }

    void g(){
        std::cout << "\n" << "B::g()";
    }
};

struct C : B{
    void vf() override{
        std::cout << "\n" << "C::vf()";
    }

    void g(){
        std::cout << "\n" << "C::g()";
    }
};

struct D : C{
    void g(){
        std::cout << "\n" << "D::g()";
    }
};

int main()
{
    A a; B b; C c; D d;
    A* a_as_aptr = &a;
    A* b_as_aptr = &b;
    A* c_as_aptr = &c;
    A* d_as_aptr = &d;

    a_as_aptr->vf();
    b_as_aptr->vf();
    c_as_aptr->vf();
    d_as_aptr->vf();

    a_as_aptr->g();
    b_as_aptr->g();
    c_as_aptr->g();
    d_as_aptr->g();
}
```

Run at [Compiler Explorer](https://godbolt.org/z/zxeo53ah6)

Output:
```shell
A::vf()
B::vf()
C::vf()
C::vf()
A::g()
A::g()
A::g()
A::g()
```

Because `vf()` is a virtual function, the dynamic type (type of the pointee object) is used at run-time to resolve calls to `b_as_aptr->vf()` or `c_as_aptr->vf()`. With non-virtual functions such as `g()`, the compiler uses the static type to determine what function to call, and it can do so at compile-time.

## `override`: a useful feature to prevent bugs

Every time you define a method in the derived class that override `virtual` member function in the base class, as a good practice, tag it `override`. This way, you show that your intention for the derived class is to override the behavior of `vf` in the base class.

```cpp
#include<iostream>
struct Base{
    virtual void vf(){
        std::cout << "\n" << "void Base::vf()";
    }
};

struct Derived : public Base{
    void vf() override{
        std::cout << "\n" << "void Derived::vf()";
    }
};
```

If a function is declared with specifier `override` but does not override a base class `virtual` member function, the program is ill-formed and will not compile.

```cpp
#include<iostream>
struct Base{
    virtual void vf(){
        std::cout << "\n" << "void Base::vf()";
    }
};

struct Derived : public Base{
    void vf(long) override{
        std::cout << "\n" << "void Derived::vf()";
    }
};
```
Run at [Compiler Explorer](https://godbolt.org/z/jGcW14Gfs)

`Base::vf()` does not need to be accessible or visible to be overriden. `Base::vf()` can be declared as `private`, or `Base` can be inherited using `private` inheritance.

```cpp
#include<iostream>
class B
{
    virtual void do_f(){ // private member
        std::cout << "\n" << "B::do_f()";
    }
    public:
    void f() { do_f(); } // public interface
};
 
class D : public B
{
    void do_f() override{ // overrides B::do_f
        std::cout << "\n" << "D::do_f()";
    }
};
 
int main()
{
    D d;
    B* bp = &d;
    bp->f(); // internally calls D::do_f();
}
```
Run at [Compiler Explorer](https://godbolt.org/z/Ge9vob6hG)

# `virtual` destructors

Consider the following code snippet, where we intend to use a class hierarchy polymorphically:

```cpp
#include<iostream>
struct A{
    A(){ std::cout << "\n" << "A()"; }
    ~A(){ std::cout << "\n" << "~A()"; }
};

struct B : A{
    B(){ std::cout << "\n" << "B()"; }
    ~B(){ std::cout << "\n" << "~B()"; }
};

struct C : B{
    C(){ std::cout << "\n" << "C()"; }
    ~C(){ std::cout << "\n" << "~C()"; }
};

int main(){
    A* c_as_aptr{new C()};
    delete c_as_aptr;
    return 0;
}
```
Run at [Compiler Explorer](https://godbolt.org/z/GoTGsrKq8)

Output:
```shell
A()
B()
C()
~A()
```

`new C()` dynamically allocates memory on the heap and default-initializes a `C()` object in this memory block. The address of the newly constructed object is stored in `c_as_aptr` pointer variable.

If we comment out line 19, we shall leak memory. All calls to `new` or `new[]` must be matched by corresponding calls to `delete` or `delete[]`. 

`delete T` for a type `T` calls the destructor `~T()` and deallocates the memory space occupied by `T`. 

Since the base-class destructor `~A()` is a non-virtual function, `delete c_as_aptr` has undefined behavior. In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak.

Always make base classes' destructors virtual when they're meant to be manipulated polymorphically.

```cpp
#include<iostream>
struct A{
    A(){ std::cout << "\n" << "A()"; }
    virtual ~A(){ std::cout << "\n" << "~A()"; }
};

struct B : A{
    B(){ std::cout << "\n" << "B()"; }
    ~B(){ std::cout << "\n" << "~B()"; }
};

struct C : B{
    C(){ std::cout << "\n" << "C()"; }
    ~C(){ std::cout << "\n" << "~C()"; }
};

int main(){
    A* c_as_aptr{new C()};
    delete c_as_aptr;
    return 0;
}
```
Run at [Compiler Explorer](https://godbolt.org/z/zh5rT9T5d)

Output:
```shell
A()
B()
C()
~C()
~B()
~A()
```

# `virtual` inheritance and the diamond problem

Unlike non-virtual inheritance described above, `virtual` inheritance uses the keyword `virtual` as the access specifier, when inheriting from a base class. 

The difference between conventional inheritance and `virtual` inheritance is that `virtual` inheritance allows a diamond class hierarchy and child classes inherit only one copy of the `virtual` base class. 

Consider the following code snippet:

```cpp
struct A{};
struct B : A {};
struct C : A {};
struct D : B, C {};
```

Here, `D` inherits indirectly from `A`, it inherits a copy of class `A` from via `B` and a second copy of class `A` via `C`. So, `D` inherits two copies of class `A`. 

```shell
A   A
|   |
B   C
 \ /
  D
```

```cpp
#include<iostream>
struct A{
    A(){ std::cout << "\n" << "A()";}
    virtual ~A(){ std::cout << "\n" << "~A()"; }
};

struct B : A{
    B(){ std::cout << "\n" << "B()";}
    virtual ~B(){ std::cout << "\n" << "~B()"; }
};

struct C : A{
    C(){ std::cout << "\n" << "C()";}
    virtual ~C(){ std::cout << "\n" << "~C()"; }
};

struct D : B, C{
    D(){ std::cout << "\n" << "D()";}
    virtual ~D(){ std::cout << "\n" << "~D()"; }
};

int main(){
    D d;
    return 0;
}
```
Run at [Compiler Explorer](https://godbolt.org/z/Mf4bjo3xK)

Output:
```shell
A()
B()
A()
C()
D()
~D()
~C()
~A()
~B()
~A()
```

To solve this problem, we must make `A` as a `virtual` base class for both `B` and `C`. `D` inherits from both `B` and `C`. This time, because `A` is inherited virtually by `B` and `C` only one instance of the `A` subobject will be created for `D.

```cpp
#include<iostream>
struct A{
    A(){ std::cout << "\n" << "A()";}
    virtual ~A(){ std::cout << "\n" << "~A()"; }
};

struct B : virtual public A{
    B(){ std::cout << "\n" << "B()";}
    virtual ~B(){ std::cout << "\n" << "~B()"; }
};

struct C : virtual public A{
    C(){ std::cout << "\n" << "C()";}
    virtual ~C(){ std::cout << "\n" << "~C()"; }
};

struct D : public B, public C{
    D(){ std::cout << "\n" << "D()";}
    virtual ~D(){ std::cout << "\n" << "~D()"; }
};

int main(){
    D d;
    return 0;
}
```
Run at [Compiler Explorer](https://godbolt.org/z/9ME45Gbod)

Output:
```shell
A()
B()
C()
D()
~D()
~C()
~B()
~A()
```

# Class Hierarchy, Virtual Tables, Virtual Table Table

Consider the following class hierarchy:

```cpp
struct Package{
    double x;
    double y;
    double z;
    Package(double x, double y, double z) 
    : x(x)
    , y(y)
    , z(z)
    {}

    virtual double volume(){
        return (x * y * z);
    }

    virtual double weight(){
        return volume() * 1.05;
    }

    virtual ~Package() {}
};

struct Cube : Package{
    Cube(double side)
    : Package( side, side, side)
    {}
    virtual double volume() override{
        return (x * x * x);
    }
};

struct StandardPackage : Cube{
    StandardPackage() 
    : Cube(5.0)
    {}

    virtual ~StandardPackage() {}
};

struct Consignment : Package{
    Consignment(double x, double y, double z)
    : Package(x, y, z)
    {}
    const double packing_material_factor{1.25};
        virtual double weight(){
        return volume() * 1.05 * packing_material_factor;
    }
};

int main(){
    Consignment c(2.0, 3.0, 5.0);
    return 0;
}
```

We could dump the class hierarchy information including the virtual table information, using the `gcc` compiler flag `-fdump-lang-class`.

```shell
[quantdev@quasar-arch virtual_tables]$ g++ -g -fdump-lang-class main.cpp -o main
[quantdev@quasar-arch virtual_tables]$ cat main.cpp.001l.class
Vtable for Package
Package::_ZTV7Package: 6 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI7Package)
16    (int (*)(...))Package::volume
24    (int (*)(...))Package::weight
32    (int (*)(...))Package::~Package
40    (int (*)(...))Package::~Package

Class Package
   size=32 align=8
   base size=32 base align=8
Package (0x0x7b9f43bd8000) 0
    vptr=((& Package::_ZTV7Package) + 16)

Vtable for Cube
Cube::_ZTV4Cube: 6 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI4Cube)
16    (int (*)(...))Cube::volume
24    (int (*)(...))Package::weight
32    (int (*)(...))Cube::~Cube
40    (int (*)(...))Cube::~Cube

Class Cube
   size=32 align=8
   base size=32 base align=8
Cube (0x0x7b9f43a0ebc8) 0
    vptr=((& Cube::_ZTV4Cube) + 16)
Package (0x0x7b9f43bd8120) 0
      primary-for Cube (0x0x7b9f43a0ebc8)

Vtable for StandardPackage
StandardPackage::_ZTV15StandardPackage: 6 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI15StandardPackage)
16    (int (*)(...))Cube::volume
24    (int (*)(...))Package::weight
32    (int (*)(...))StandardPackage::~StandardPackage
40    (int (*)(...))StandardPackage::~StandardPackage

Class StandardPackage
   size=32 align=8
   base size=32 base align=8
StandardPackage (0x0x7b9f43beb000) 0
    vptr=((& StandardPackage::_ZTV15StandardPackage) + 16)
Cube (0x0x7b9f43beb068) 0
      primary-for StandardPackage (0x0x7b9f43beb000)
Package (0x0x7b9f43bd81e0) 0
        primary-for Cube (0x0x7b9f43beb068)

Vtable for Consignment
Consignment::_ZTV11Consignment: 6 entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI11Consignment)
16    (int (*)(...))Package::volume
24    (int (*)(...))Consignment::weight
32    (int (*)(...))Consignment::~Consignment
40    (int (*)(...))Consignment::~Consignment

Class Consignment
   size=40 align=8
   base size=40 base align=8
Consignment (0x0x7b9f43bebaf8) 0
    vptr=((& Consignment::_ZTV11Consignment) + 16)
Package (0x0x7b9f43bd8240) 0
      primary-for Consignment (0x0x7b9f43bebaf8)
```   

`Package::_ZTV7Package: 6 entries` says the name of the `vtable`, which is a static array, is `Package::_ZTV7Package` and there are $6$ function pointer entries in this static array. The offset of each entry is $8$ bytes.

## References {.appendix}

- [Virtual Tables](https://leimao.github.io/blog/CPP-Virtual-Table/).`