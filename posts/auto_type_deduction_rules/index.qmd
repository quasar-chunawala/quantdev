---
title: "`auto` type deduction rules"
author: "Quasar"
date: "2025-12-21"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

This weekend, I tried to solve a fun puzzle - [the C++ `auto` type deduction gauntlet](https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/) and thought of creating a quick cheatsheet on `auto` type deduction rules. I encourage you to give it a shot.

`auto` is a placeholder type that gets replaced typically by deduction from an initializer.

Whenever you have: 

```cpp
auto [some_modifiers] x = expression;
```

you have three general cases:

- `auto x` : The object being assigned is allowed to decay. We strip the RHS `expression` of all CV-qualifiers such as `const` and reference modifiers to deduce the *by-value* type of `x`. CV qualifiers applied to pointed-to types are maintained.
- `auto& x` or `auto&& x` : It preserves references and CV-qualifiers. 
- `const auto& x` : We specify the qualifiers, `auto` simply deduces the base type. 


# Exercises to flex your understanding of `auto` deduction rules

Let's determine for each of the problems:

- The deduced type
- The value category
- What CV qualifiers are applicable

As the author of the puzzles states, let's note that these are meant to test your understanding and some examples won't compile.

## Basics

```cpp
auto v = 5;
```

This is fairly straight-forward. The deduced type is `int`. The value category of `v` is *lvalue*.                                                                                                                                                                                                                                           
```cpp
auto v = 0.1;
```

Floating-point values default to the larger `double`, rather than `float`. The value category of `v` is *lvalue*. 

```cpp
int x;
auto v = x;
```

The deduced type is `int` and the value category of `v` is *lvalue*.

```cpp
auto i{0uz};
```

The `u` suffix is used for unsigned integer literals and the `z` suffix is used for the signed version of `std::size_t`. The suffix `uz` deduces to `std::size_t`. 

The type `size_t` is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.

```cpp
auto v=5, w=0.1
```

I didn't get this puzzle. But, this will fail to compile. All types in an expression defined with `auto` have be the same.

```cpp
int x;
auto v = &x;
```

`&` is the address-of operator. So, the type of `v` is deduced as pointer-to-int `int*`. The value category of `v` is *lvalue*.

```cpp
int x[5];
auto v = x;
```

`x` is an array of $5$ `int`s, its type is `int [5]`. C-style arrays decay to a pointer. So, the type of `v` is `int*`. `v` is an *lvalue*.

```cpp
auto v = nullptr;
```

`nullptr` is a value of type `std::nullptr_t`.

```cpp
auto v = {1, 2, 3};
```

$1$, $2$ and $3$ are `int`s. So, the type of `v` is deduced as `std::initializer_list<int>`. If the curly-braced initializer list were `{1, 2.5, 4}`, type deduction would fail, because we require all types in an initializer list to be the same.

```cpp
auto v{1, 2, 3};
```

Curly braced direct initialization only works with a single scalar value e.g. `auto v{1}`. 

```cpp
int foo(int x){
    return x;
}

auto v = foo;
```

`v` is deduced as a function pointer, `int (*) int`. According to the C++ standard, a function is an object that occupies memory storage and has a lifetime. Hence, `foo` is an *lvalue* expression. 

```cpp
int x{22};
const int* pcx = &x;
auto ppcx = &pcx;
```

CV-qualifiers applied to pointed-to are maintained. So, the type of `ppcx` is deduced as `const int**`. 

## Intermediate

We now explore how references and CV-qualifiers are handled.

```cpp
volatile const int x = 1;
auto v = x;
```

We strip all modifiers off `x`, so that results in an `int`. Thus, `auto` is deduced as `int`. `auto` always drops top-level CV qualifiers.

```cpp
volatile const int x = 1;
auto v = &x;
```

I didn't quite get this one. It turns out that CV qualifiers applied to pointed-to. So, type of `x` is deduced as `volatile const int*`. The next code snip also shows the same:

```cpp
#include <cassert>
#include <type_traits>

int main(){
    const int& x{42};
    auto& y = x;
    static_assert(std::is_same_v<decltype(y), const int&>);
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/hb39vqYeE)

```cpp
int x;
int& y = x;
auto v = y;
```

`y` is an *lvalue reference* to `x`. The type of `y` decays to `int`. 

```cpp
int x;
auto& v = x;
```

The type of `v` is deduced as `int&`. `v` is an *lvalue reference*.

```cpp
int x[5];
auto& v = x;
```

`auto` is deduced as `int [5]`. The type of `v` is a reference to an array of $5$ `int`s.

```cpp
int foo(const int x) {
    return x;
}
auto v = foo;
```

Functions are *lvalues* and the function name is a pointer to function object in memory. CV-qualifiers on parameters are thrown away during function resolution. Hence, `auto` is deduced as `int (*)(int)`.

## Advanced

```cpp
int x;
auto&& v = x;
```

`auto&& v` is a forwarding reference. `x` is an *lvalue* and *lvalues* bind to *lvalue* references. Here, we get an *lvalue reference*. 

```cpp
auto x = [] () -> int { 
    return 1;
};
auto&& v = x();
```

The return value of the function call is a *prvalue*. It will bind to an *rvalue reference*. So, the type of `v` is deduced as `int&&`.

```cpp
int x;
auto y = [&] () -> int& { 
    return x;
};
auto&& v = y();
```

The result of the function call `y()` is an *lvalue*, so the type of `v` is deduced to be `int&`.

```cpp
struct Foo {};
auto&& v = Foo{};
```

The call to the constructor `Foo{}` creates a temporary `Foo` instance - a *prvalue*. Hence, the type of `v` is deduced as `Foo&&`.

# References

- *[`decltype(auto)`: An overview of How, Why and Where](https://www.youtube.com/watch?v=E5L66fkNlpE) by Jason Turner*.