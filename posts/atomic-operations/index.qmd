---
title: "C++ Atomics"
author: "Quasar"
date: "2025-03-08"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

Atomic operations are indivisible. Consider, for instance a shared variable `counter` that is initialized to `0`. Consider the assembly instructions corresponding to the increment operation `count++`.

```cpp
int counter {0};

int main(){
    counter++;

    return 0;
}
```
[Play on Compiler Explorer](https://godbolt.org/z/cjhYK3hv9)

Look at the assembler code generated by the compiler and the instructions the CPU executes.

```fasm
counter:
        .zero   4
main:
        push    rbp
        mov     rbp, rsp
        mov     eax, DWORD PTR counter[rip]
        add     eax, 1
        mov     DWORD PTR counter[rip], eax
        mov     eax, 0
        pop     rbp
        ret
```

The code increments a global counter. The statement on line `6`, copies the value stored in the `counter` to the `eax` register, line `7` adds `1` to the value stored in `eax`, and finally line `8` copies back the contents of the `eax` register to the `counter` variable. So, a thread could execute line `6` and then be scheduled out, and another thread execute all threee instructions after that. When the first thread finishes increment the result, the counter will be increment just once and thus the result will incorrect. 

The following code does the same: it increments a global counter. This time, though, we use an atomic type and operations. 

```cpp
#include <atomic>
std::atomic<int> counter {0};

int main(){
    counter++;
    return 0;
}
```
[Play on Compiler Explorer](https://godbolt.org/z/rs9Wrzz3M)

I will explain the `std::atomic<int>` type and the atomic increment operation later. The generated assembly code is the following:

```fasm
lock add        DWORD PTR counter[rip], 1
```

Just one instruction has been generated to add `1` to the value stored in the `counter` variable. The lock prefix here means that the following instruction (in this case `add`) is going to be executed atomically. Hence, a thread cannot be interrupted in the middle of incrementing the counter. 

Atomic operations allow threads to read, modify and write indivisibly and can also be used as synchronization primitives. Atomic operations must be provided by the CPU (as in the `lock add` instruction).