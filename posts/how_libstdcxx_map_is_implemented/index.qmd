---
title: "How libstdc++ `std::unordered_map` is implemented?"
author: "Quasar"
date: "2025-12-16"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

We all love maps. A map is simply a data-structure that allows you to associate a key with some kind of value. They are fast and help to solve a large number of problems. Have you wondered what the internal implementation of a map looks like? In this post, I am going to explore the implementation details of unordered associative containers from the standard library(GCC's `libstdc++` implementation). 

Currently there are four types of unordered associative containers:

- `std::unordered_map`
- `std::unordered_set`
- `std::unordered_multimap`
- `std::unordered_multiset`

Usually, they are implemented on top of some kind of container. I am going to jump into the implementation of this `HashTable` container directly, because that's where all the interesting stuff is hidden.

I'll focus on the key-value containers with a unique set of keys(`std::unordered_map` and `std::unordered_set`) which have mostly similar logic.

GCC's implementation can be found in the [`hashtable.h` header](https://github.com/gcc-mirror/gcc/blob/127cd406/libstdc++-v3/include/bits/hashtable.h). There are a lot of names with leading underscores. Not everyone is used to such code, but the standard library implementers have no choice, but to avoid collisions with user-defined names.

# Data Layout

## Nodes

One of the basic building blocks of the `_Hashtable` is a node. Each node is allocated from the heap and stores container data along with metadata information to maintain the hash table data-structure.

The node itself is a compound entity and contains several parts, some of them, optional. The design of the node `structs` brings to mind Russian dolls, because they are nested to each other. 

:::{text-center}
![Russian dolls](Russian-Matroshka.jpg){scale=50% fig-align="center"}
:::

The more complex node type(with more data) is inherited from the simpler node type(with a little bit less data). Let us walk through the components bottom up(from simpler to complex).

First, `_Hash_node_base` is defined in the following way. It has only `_M_nxt` field, which is a pointer to the next node of the hash table.

```cpp
struct _Hash_node_base
{
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
};
```

The next one `_Hash_node_value_base` is a little bit more interesting(see the actual code [here](https://github.com/gcc-mirror/gcc/blob/b9b7981f3d6919518372daf4c7e8c40dfc58f49d/libstdc%2B%2B-v3/include/bits/hashtable_policy.h#L318-L345)). `_Hash_node_value_base` is responsible for storing the actual element value in the `_M_storage` member variable. It also provides accessor methods to retrieve the stored value.

```cpp
template<typename _Value>
struct _Hash_node_value_base
{
    using value_type = _Value;

    __gnu_cxx::__aligned_buffer<_Value> _M_storage;

    // ...
};
```

It is a templated class with `_Value` template parameter that represents the `value_type`. `_Value` type is wrapped into `__gnu_cxx::__aligned_buffer` (thin wrapper around `std::aligned_storage`) to decouple memory allocation from actual object creation.

The next struct is `_Hash_node_code_cache` and it implements hash value caching logic. When searching for a key in an unordered map, (i) we need to compute the hash-code of the search key, $h(k)$, (ii) find the right bucket `idx = h(k) % table_size` and then (iii) walk the collision chain comparing each node's key with you key $k$. When keys are large or complex like `std::string`, using the equality predicate and doing full key comparisons for every node in the chain is expensive. So, we can choose the cach the hash code with each node:

```cpp
template<typename _Value, bool __cache>
struct _Hash_node_code_cache {
    size_t _M_hash_code;  // Stored hash value
};

// Specialization when caching is disabled
template<typename _Value>
struct _Hash_node_code_cache<_Value, false> {
  // Empty - no overhead
};
```

This way Empty Base Class Optimization(EBCO) can be leveraged, since `_Hash_node_code_cache` will be extended by inheritance. And that's exactly what `_Hash_node_value` is doing:

```cpp
template<typename _Value, bool _Cache_hash_code>
  struct _Hash_node_value
  : _Hash_node_value_base<_Value>
  , _Hash_node_code_cache<_Cache_hash_code>
  { };
```

The size of the `_Hash_node_value` will be the same as size of `_Hash_node_value_base<_Value>` in case template argument `_Cache_hash_code` is `false` as `_Hash_node_code_cache` will be an empty struct.

The final piece of the puzzle is the `_Hash_node` that combines everything above together:

```cpp
 template<typename _Value, bool _Cache_hash_code>
struct _Hash_node
: _Hash_node_base
, _Hash_node_value<_Value, _Cache_hash_code>
{
    _Hash_node*
    _M_next() const noexcept
    { return static_cast<_Hash_node*>(this->_M_nxt); }
};
```

Below is a picture of the `_Hash_node` struct data layout to better visualize what's going on. 

```
┌──────────────────────────────────────────────────────────────┐
│ _Hash_node<Value>                                            │
├──────────────────────────────────────────────────────────────┤
│ inherits from _Hash_node_base                                │
|--------------------------------------------------------------|
│       _Hash_node_base*          _M_nxt; // ptr to next node  │
├──────────────────────────────────────────────────────────────┤
| inherits from _Hash_node_value                               |
|--------------------------------------------------------------|
|   inherits from _Hash_node_value_base                        |
|--------------------------------------------------------------|
│       aligned_buffer<Value>     _M_storage;    // The value  │
├--------------------------------------------------------------┤
|   inherits from_Hash_node_code_cache                         |
|--------------------------------------------------------------|
│       size_t                    _M_hash_code;  // Cached hash│
└──────────────────────────────────────────────────────────────┘
```

Summarizing, _Hash_node (directly or inherited from base structs) contains the following data.

- `_Hash_node_base* _M_nxt` is a pointer to the next element in the linked list of hash table elements.
- `__gnu_cxx::__aligned_buffer<_Value> _M_storage` — node data itself. For example for `std::unordered_map<std::string, int>` container `_Value` template argument is `std::pair<const std::string, int>`.
- `std::size_t _M_hash_code` optional cached value of key's hash.