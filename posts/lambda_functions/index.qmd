---
title: "Lambda Functions"
author: "Quasar"
date: "2025-12-13"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

I've got my hands on the [C++ lambda story](https://leanpub.com/cpplambda) by [Bart≈Çomiej Filipek](https://leanpub.com/u/fenbf) and want to try out a few of the examples. 

## Lambdas in C++11

An example of the most minimal lambda expression is:

```cpp
// 1. the simplest lambda
[]{};
```

`[]` section is called the lambda introducer and the empty `{}` part is for the function body. The `[]` does not only introduce the lambda but also holds the list of *captured variables*. It's called the *capture clause*. 

By capturing a variable, you create a member copy of that variable in the closure type. Then, inside the lambda body, you can access it. 


```cpp
// with a parameter
auto area = [](double radius){
    return std::pi * radius * radius;
}
```

The arguments are passed into a lambda function like any regular function. The return type is not needed as the compiler will automatically deduce it.

```cpp
auto norm = [](std::vector<double> v) -> double{
    double result{0};
    for(auto i{0uz}; i < v.size(); ++i)
    {
        result += v[i] * v[i];
    }
    return sqrt(result);
}
```

In the above example, we explicitly set a return type. The trailing return type is also available for regular function declaration since C++11.

```cpp
auto f = [x](double a, double b) mutable{
    ++x;
    return a < b;
};

auto g = [](float param) noexcept{
    rrtutn param * param;
};

auto h = [](int a, int b) mutable noexcept{
    ++x;
    return a < b;
};
```

Before the body of the lambda, you can use other specifiers. In the code, we used `mutable` (so that we can change the captured variable) and also `noexcept`. The third lambda uses `mutable` and `noexcept` and they have to appear in that order (you cannot write `noexcept mutable` as the compiler will reject it). 

While the `()` part is optional, if you want to apply `mutable` or `noexcept` then `()` needs to be in the expression. 

## Core Definitions

The core definition from the C++ standard from [expr.prim.lambda#2](https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#2) says:

> The evaluation of a lambda-expression results in a *prvalue* temporary. This temporary is called the *closure object*.

From the above definition, we can understand that the compiler generates a unique wrapper class (closure type) from a lambda expression. 

Consider the following code snip:

```cpp
#include <cmath>

auto cum_normal_cdf = [](double x){
    return 0.5 * (1.0 - std::erf(-x/std::sqrt(2.0)))
}
```

[CppInsights](https://cppinsights.io/s/4f8ddfcc) reveals that the C++ compiler creates the following class, where the function call operator `()` is overloaded.

```shell
class __lambda_4_23
{
  public: 
  inline /*constexpr */ double operator()(double x) const
  {
    return 0.5 * (1.0 - erf(-x / sqrt(2.0)));
  }  
  
};

__lambda_4_23 cum_normal_cdf = __lambda_4_23{};
```

