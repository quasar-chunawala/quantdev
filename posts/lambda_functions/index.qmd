---
title: "Lambda Functions"
author: "Quasar"
date: "2025-12-13"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Introduction

I've got my hands on the [C++ lambda story](https://leanpub.com/cpplambda) by [Bart≈Çomiej Filipek](https://leanpub.com/u/fenbf) and want to try out a few of the examples. 

# Lambdas in C++11

An example of the most minimal lambda expression is:

```cpp
// 1. the simplest lambda
[]{};
```

`[]` section is called the lambda introducer and the empty `{}` part is for the function body. 

By capturing a variable, you create a member copy of that variable in the closure type. Then, inside the lambda body, you can access it. 


```cpp
// with a parameter
auto area = [](double radius){
    return std::pi * radius * radius;
}
```

The arguments are passed into a lambda function like any regular function. The return type is not needed as the compiler will automatically deduce it.

```cpp
auto norm = [](std::vector<double> v) -> double{
    double result{0};
    for(auto i{0uz}; i < v.size(); ++i)
    {
        result += v[i] * v[i];
    }
    return sqrt(result);
}
```

In the above example, we explicitly set a return type. The trailing return type is also available for regular function declaration since C++11.

```cpp
auto f = [x](double a, double b) mutable{
    ++x;
    return a < b;
};

auto g = [](float param) noexcept{
    rrtutn param * param;
};

auto h = [](int a, int b) mutable noexcept{
    ++x;
    return a < b;
};
```

Before the body of the lambda, you can use other specifiers. In the code, we used `mutable` (so that we can change the captured variable) and also `noexcept`. The third lambda uses `mutable` and `noexcept` and they have to appear in that order (you cannot write `noexcept mutable` as the compiler will reject it). 

While the `()` part is optional, if you want to apply `mutable` or `noexcept` then `()` needs to be in the expression. 

## Core Definitions

The core definition from the C++ standard from [expr.prim.lambda#2](https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#2) says:

> The evaluation of a lambda-expression results in a *prvalue* temporary. This temporary is called the *closure object*.

From the above definition, we can understand that the compiler generates a unique wrapper class (closure type) from a lambda expression. 

Consider the following code snip:

```cpp
#include <cmath>

auto cum_normal_cdf = [](double x){
    return 0.5 * (1.0 - std::erf(-x/std::sqrt(2.0)))
}
```

[CppInsights](https://cppinsights.io/s/4f8ddfcc) reveals that the C++ compiler creates the following class, where the function call operator `()` is overloaded.

```shell
class __lambda_4_23
{
  public: 
  inline /*constexpr */ double operator()(double x) const
  {
    return 0.5 * (1.0 - erf(-x / sqrt(2.0)));
  }  

  /* ... */
};

__lambda_4_23 cum_normal_cdf = __lambda_4_23{};
```

## Constructors and copying

In the specification of the feature at [expr.prim.lambda](https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#19), we can also read the following:

> The closure-type associated with a lambda expression has a deleted default constructor and a deleted copy assignment operator. 

That's why you cannot write:

```cpp
double x{10}, y{20};
auto foo = [&x, &y]{ ++x; ++y; };
decltype(foo) fooCopy;
```
[Compiler Explorer](https://compiler-explorer.com/z/7q9bbhro1)

```shell
<source>: In function 'int main()':
<source>:9:19: error: use of deleted function 'main()::<lambda()>::<lambda>()'
    9 |     decltype(foo) fooCopy;
      |                   ^~~~~~~
<source>:5:23: note: a lambda closure type has a deleted default constructor
    5 |     auto foo = [&x, &y] {
      |                       ^
<source>:9:19: note: use '-fdiagnostics-all-candidates' to display considered candidates
    9 |     decltype(foo) fooCopy;
      |  
```

However, we can copy lambdas:

```cpp
#include <cmath>
#include <print>
#include <type_traits>

using Point = std::pair<double, double>;

int main() {
    auto distance = [](Point x, Point y) noexcept {
        return sqrt(pow((x.first - y.first), 2) +
                    pow((x.second - y.second), 2));
    };

    Point p{3.0, 4.0};
    Point origin{0.0, 0.0};
    std::print("Distance to (3,4) from the origin = {}", distance(p, origin));

    auto distance_copy = distance;
    static_assert(std::is_same_v<decltype(distance), decltype(distance_copy)>);
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/nf7MWaY4z)

## Captures

The `[]` does not only introduce the lambda but also holds the list of *captured variables*. It's called the *capture clause*. By capturing a variable from outside the scope of the lambda, you create a non-static data member in the closure type. Then, inside the lambda body, you can access it. 

The syntax for captures in C++11 are:

| Syntax | Description |
|--------|-------------|
| `[&]` | Capture by reference all automatic storage duration variables declared in the reaching scope. |
| `[=]` | Capture by value (create a copy) all automatic storage duration variables declared in the reaching scope. |
| `[x, &y]` | Capture `x` by value, capture `y` by reference |
| `[args...]` | Capture a template argument pack all by value |
| `[&args...]` | Capture a template argument pack all by reference |
| `[this]` | Captures the `this` pointer inside the member function |

: Lambda capture syntax in C++ {#tbl-lambda-syntax}

Note that for `[=]` and `[&]` cases, the compiler generates data members for all used variables inside the lambda body. This is a convenient syntax where you don't want to explicitly mention which variables you capture.

## The `mutable` keyword

By default the `operator()` of the closure type is marked as `const` and you cannot modify the captured variables inside the body of the lambda. If you want to change this behavior, you need to add the `mutable` keyword after the parameter list. This syntax removes the `const` from the call operator declaration in the closure type.

If you have a simple lambda expression with a `mutable`:

```cpp
int x{1};
auto foo = [x]() mutable { ++x; };
```

It will be expanded into the following function object:

```shell
struct __lambda_x1 {
    void operator()() { ++x; }
    int x;
};
```

The call operator can change the value of the member-fields(capture variables).

```cpp
#include <iostream>

int main() {
    const auto print = [](const char* str, int x, int y) {
        std::cout << str << ": " << x << " " << y << "\n";
    };

    int x{1}, y{1};
    print("in main", x, y);
    auto foo = [x, y, &print]() mutable {
        ++x;
        ++y;
        print("in foo", x, y);
    };
    foo();
    print("in main()", x, y);
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/9Tncca1do)

Output:
```shell
in main: 1 1
in foo: 2 2
in main(): 1 1
```

In the above example, we can change the values of `x` and `y`. Since those are only the copies of `x` and `y` from the enclosing scope, we don't see their new values after `foo` is invoked. 

On the other hand, if you capture by reference, you don't need to apply the `mutable` keyword to modify the value. This is because the captured data members are references which means that you cannot rebound them to a new object anyway, but you can change the referenced values. 

```cpp
#include <iostream>

int main() {
    int x{1};
    std::cout << x << "\n";
    const auto foo = [&x]() noexcept { ++x; };
    foo();
    std::cout << x << "\n";
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/Yjjqdd3zf)

Output:
```shell
Program stdout
1
2
```

In the above example, the lambda is not specified with `mutable` but it can change the referenced value.

One important thing is that when you apply `mutable`, then you canot mark your resulting closure object with `const` as it prevents you from invoking the lambda!

```cpp
int x{10};
const auto lam = [x]() mutable { ++x; };
// lam(); // compile eror
```

The last line won't compile as we cannot call a non-`const` member function on a `const` object. 

## Capturing Global Variables

If you have a global variable and you use `[=]` in your lambda, you might think that your global object is also captured by value. But, it's not. 

```cpp
#include <iostream>

int global{10};

int main() {
    std::cout << global << "\n";
    auto foo = [=]() mutable noexcept { ++global; };
    foo();
    std::cout << global << "\n";
    const auto increaseGlobal = []() noexcept { ++global; };
    increaseGlobal();
    std::cout << global << "\n";
    const auto moreIncreaseGlobal = [global]() noexcept { ++global; };
    moreIncreaseGlobal();
    std::cout << global << "\n";
}
```
[Compiler Explorer](https://compiler-explorer.com/z/aTG3qP5vM)

Output:
```shell
10
11
12
13
```

In the above example, we have defined a static variable `global` and then used it with several lambdas defined in the `main()` function. If you run the code, then no matter the way you captgure, it will always point to the global object, and no local copies will be created.

Line 13 of the code causes the compiler to generate the following warning:

```shell
source>: In function 'int main()':
<source>:13:38: warning: capture of variable 'global' with non-automatic storage duration
   13 |     const auto moreIncreaseGlobal = [global]() noexcept { ++global; };
```

It's because only variables with automatic storage duration can be captured. 

If you use `[=]` explicitly, the compiler won't help you and it generates an error.

## Capturing `static` variables

Similar to capturing global variables, you'll get the same issues with `static` objects:

```cpp
#include <iostream>

void bar(){
    static int static_int{10};
    std::cout << static_int << "\n";
    auto foo = [=]() mutable noexcept{ ++static_int; };
    foo();
    std::cout << static_int << "\n";
    const 
}
```