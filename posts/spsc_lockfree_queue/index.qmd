---
title: "Lock-free SPSC Queue"
author: "Quasar"
date: "2025-12-05"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Designing the `spsc_queue` data-structure

I would like to present my implementation for an SPSC lock-free queue in this blog-post.

```{python}
%load_ext itikz
```

## What makes an operation atomic?

When a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:

- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). 
- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. 

## Setup - How the queue works

- Bounded size. The elements are stored in a fixed-length buffer.
- Single-producer, Single-consumer applications. 
- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.

The `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:

- `m_head` - The index of the `front` element, if any.
- `m_tail` - The index where a new element would be inserted at the back of the queue.

In an initially empty container, both the `m_head` and `m_tail` start at zero:

:::{text-center}
```{python}
# | code-fold: true
# | code-summary: "Show the code"
%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone
\begin{tikzpicture}[font=\small\ttfamily]
    \fill[white] (-2, 0.5) rectangle (8.5, -4.8);
    % Title
    \node[anchor=north] at (4, 0) {\textbf{SPSC Ring Buffer (Empty)}};
    
    % Index labels
    \node[anchor=east] at (-0.2, -1.5) {Index:};
    \foreach \i in {0,...,7} {
        \node at (\i, -1.5) {\i};
    }
    
    % Buffer cells
    \node[anchor=east] at (-0.2, -2.5) {Buffer:};
    \foreach \i in {0,...,7} {
        \draw (\i-0.4, -2.2) rectangle (\i+0.4, -2.8);
    }
    
    % Pointers
    \draw[->, thick] (0, -3.2) -- (0, -2.8);
    \node[anchor=north] at (0, -3.2) {m\_head = 0};
    \node[anchor=north] at (0, -3.6) {m\_tail = 0};
    
    % Status
    \node[anchor=north] at (4, -4.2) {Status: Empty (m\_head == m\_tail)};
\end{tikzpicture}
```
:::

Then I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. 

For example, if do `push_back(1)` the queue looks something like this. 

:::{text-center}
```{python}
# | code-fold: true
# | code-summary: "Show the code"
%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone
\begin{tikzpicture}[font=\small\ttfamily]
    \fill[white] (-2, 0.5) rectangle (8.5, -4.8);
    % Title
    \node[anchor=north] at (4, 0) {\textbf{SPSC Ring Buffer (1 element)}};
    
    % m_head pointer (above)
    \node[anchor=south] at (0, -0.8) {m\_head = 0};
    \draw[->, thick] (0, -1.0) -- (0, -1.4);
    
    % Index labels
    \node[anchor=east] at (-0.2, -1.5) {Index:};
    \foreach \i in {0,...,7} {
        \node at (\i, -1.5) {\i};
    }
    
    % Buffer cells
    \node[anchor=east] at (-0.2, -2.5) {Buffer:};
    \foreach \i in {0,...,7} {
        \draw (\i-0.4, -2.2) rectangle (\i+0.4, -2.8);
    }
    % Fill first cell
    \fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);
    \node at (0, -2.5) {1};
    
    % m_tail pointer (below)
    \draw[->, thick] (1, -3.2) -- (1, -2.8);
    \node[anchor=north] at (1, -3.2) {m\_tail = 1};
    
    % Status
    \node[anchor=north] at (4, -3.8) {Status: 1 element (m\_tail > m\_head)};
\end{tikzpicture}
```
:::

Here's the queue with a few more elements added:

:::{text-center}
```{python}
# | code-fold: true
# | code-summary: "Show the code"
%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone
\begin{tikzpicture}[font=\small\ttfamily]
    \fill[white] (-2, 0.5) rectangle (8.5, -4.8);
    % Title
    \node[anchor=north] at (4, 0) {\textbf{SPSC Ring Buffer (4 elements)}};
    
    % m_head pointer (above)
    \node[anchor=south] at (0, -0.8) {m\_head = 0};
    \draw[->, thick] (0, -1.0) -- (0, -1.4);
    
    % Index labels
    \node[anchor=east] at (-0.2, -1.5) {Index:};
    \foreach \i in {0,...,7} {
        \node at (\i, -1.5) {\i};
    }
    
    % Buffer cells
    \node[anchor=east] at (-0.2, -2.5) {Buffer:};
    \foreach \i in {0,...,7} {
        \draw (\i-0.4, -2.2) rectangle (\i+0.4, -2.8);
    }
    % Fill cells 0-3
    \fill[lightgray!30] (-0.4, -2.2) rectangle (0.4, -2.8);
    \fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);
    \fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);
    \fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);
    \node at (0, -2.5) {1};
    \node at (1, -2.5) {2};
    \node at (2, -2.5) {3};
    \node at (3, -2.5) {5};
    
    % m_tail pointer (below)
    \draw[->, thick] (4, -3.2) -- (4, -2.8);
    \node[anchor=north] at (4, -3.2) {m\_tail = 4};
    
    % Status
    \node[anchor=north] at (4, -3.8) {Status: 4 elements (m\_tail > m\_head)};
\end{tikzpicture}
```
:::

Once I have got some elements into the queue, I can go ahead and call the `pop()` function, which is going to try to read and remove the first element from the front of the queue.

If the queue isn't empty, it :

- Advances `m_head` thereby implicitly discard the element at the front of the queue

:::{text-center}
```{python}
# | code-fold: true
# | code-summary: "Show the code"
%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone
\begin{tikzpicture}[font=\small\ttfamily]
    \fill[white] (-2, 0.5) rectangle (8.5, -4.8);
    % Title
    \node[anchor=north] at (4, 0) {\textbf{SPSC Ring Buffer (3 elements)}};
    
    % m_head pointer (above)
    \node[anchor=south] at (1, -0.8) {m\_head = 1};
    \draw[->, thick] (1, -1.0) -- (1, -1.4);
    
    % Index labels
    \node[anchor=east] at (-0.2, -1.5) {Index:};
    \foreach \i in {0,...,7} {
        \node at (\i, -1.5) {\i};
    }
    
    % Buffer cells
    \node[anchor=east] at (-0.2, -2.5) {Buffer:};
    \foreach \i in {0,...,7} {
        \draw (\i-0.4, -2.2) rectangle (\i+0.4, -2.8);
    }
    % Fill cells 1-3
    \fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);
    \fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);
    \fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);
    \node at (1, -2.5) {2};
    \node at (2, -2.5) {3};
    \node at (3, -2.5) {5};
    
    % m_tail pointer (below)
    \draw[->, thick] (4, -3.2) -- (4, -2.8);
    \node[anchor=north] at (4, -3.2) {m\_tail = 4};
    
    % Status
    \node[anchor=north] at (4, -3.8) {Status: 3 elements (m\_tail > m\_head)};
    \node[anchor=north] at (4, -4.2) {Note: Index 0 is now "stale" (logically removed)};
\end{tikzpicture}
```
:::

Most of the time, when we advance an index like this, it is a simple increment. But, as I stated earlier, the buffer slots are used in a a circular fashion. If that increment would place that `index` out of bounds, it wraps around to the zeroeth slot (that's what makes it a ring) of the queue buffer.

:::{text-center}
```{python}
# | code-fold: true
# | code-summary: "Show the code"
%%itikz --temp-dir --tex-packages=tikz --tikz-libraries=arrows.meta --implicit-standalone
\begin{tikzpicture}[font=\small\ttfamily]
    \fill[white] (-2, 0.5) rectangle (8.5, -4.8);
    % Title
    \node[anchor=north] at (4, 0) {\textbf{SPSC Ring Buffer (7 elements)}};
    
    % m_head pointer (above)
    \node[anchor=south] at (1, -0.8) {m\_head = 1};
    \draw[->, thick] (1, -1.0) -- (1, -1.4);
    
    % Index labels
    \node[anchor=east] at (-0.2, -1.5) {Index:};
    \foreach \i in {0,...,7} {
        \node at (\i, -1.5) {\i};
    }
    
    % Buffer cells
    \node[anchor=east] at (-0.2, -2.5) {Buffer:};
    \foreach \i in {0,...,7} {
        \draw (\i-0.4, -2.2) rectangle (\i+0.4, -2.8);
    }
    % Fill cells 1-7
    \fill[lightgray!30] (0.6, -2.2) rectangle (1.4, -2.8);
    \fill[lightgray!30] (1.6, -2.2) rectangle (2.4, -2.8);
    \fill[lightgray!30] (2.6, -2.2) rectangle (3.4, -2.8);
    \fill[lightgray!30] (3.6, -2.2) rectangle (4.4, -2.8);
    \fill[lightgray!30] (4.6, -2.2) rectangle (5.4, -2.8);
    \fill[lightgray!30] (5.6, -2.2) rectangle (6.4, -2.8);
    \fill[lightgray!30] (6.6, -2.2) rectangle (7.4, -2.8);
    \node at (1, -2.5) {2};
    \node at (2, -2.5) {3};
    \node at (3, -2.5) {5};
    \node at (4, -2.5) {8};
    \node at (5, -2.5) {13};
    \node at (6, -2.5) {21};
    \node at (7, -2.5) {34};
    
    % m_tail pointer (below)
    \draw[->, thick] (0, -3.2) -- (0, -2.8);
    \node[anchor=north] at (0, -3.2) {m\_tail = 0};
\end{tikzpicture}
```
:::

As we'll see, it turns out that the indices `m_head` and `m_tail` will need to be `atomic` objects. We'll understand why this is the case.

The storage for a ring buffer consists of a fixed-capacity array of elements and the indices for `head` and `tail`. We shall write `spsc_queue` as a templated class having the capacity as a template parameter. 

```cpp
template<typename T, size_t capacity>
class spsc_queue{
    private:
    // The capacity must be a power of two.
    static_assert((capacity & (capacity - 1)) == 0);    
    T m_buffer[capacity];
    size_t m_head;
    size_t m_tail;
    public:
        /* ... */
};
```

We would like to enforce the capacity to be a power of $2$ for efficiency reasons. Remember, that with this design, there's always atleast one unused element in the array, because `m_head == m_tail + 1` is the queue full condition. So, the effective capacity equals `capacity - 1`. 

## The `class` interface

Here is the class interface:

```cpp
template<typename T, size_t capacity>
class spsc_queue{
    private:
    // The capacity must be a power of two.
    static_assert((capacity & (capacity - 1)) == 0);    
    T m_buffer[capacity];
    size_t m_head;
    size_t m_tail;
    public:
        /* ... */
};
```