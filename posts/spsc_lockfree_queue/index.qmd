---
title: "Lock-free SPSC Queue"
author: "Quasar"
date: "2025-12-05"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Designing the `spsc_queue` data-structure

I would like to present my implementation for an SPSC lock-free queue in this blog-post.

## What makes an operation atomic?

When a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:

- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). 
- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. 

## Setup - How the queue works

- Bounded size. The elements are stored in a fixed-length buffer.
- Single-producer, Single-consumer applications. 
- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.

The `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:

- `m_head` - The index of the `front` element, if any.
- `m_tail` - The index where a new element would be inserted at the back of the queue.

In an initially empty container, both the `m_head` and `m_tail` start at zero:

```
┌─────────────────────────────────────────────────────────────┐
│                   SPSC Ring Buffer (Empty)                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │    │    │    │    │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲                                                │
│            │                                                │
│        m_head = 0                                           │
│        m_tail = 0                                           │
│                                                             │
│   Status: Empty (m_head == m_tail)                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Then I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. 

For example, if do `push_back(1)` the queue looks something like this. 

```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (1 element)                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │ 1  │    │    │    │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲    ▲                                           │
│            │    │                                           │
│        m_head   m_tail = 1                                  │
│         = 0                                                 │
│                                                             │
│   Status: 1 element (m_tail > m_head)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Here's the queue with a few more elements added:

```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (4 elements)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │ 1  │ 2  │ 3  │ 5  │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲                   ▲                            │
│            │                   │                            │
│        m_head = 0          m_tail = 4                       │
│                                                             │
│   Status: 4 elements (m_tail > m_head)                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```