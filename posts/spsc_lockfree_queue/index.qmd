---
title: "Lock-free SPSC Queue"
author: "Quasar"
date: "2025-12-05"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Designing the `spsc_queue` data-structure

I would like to present my implementation for an SPSC lock-free queue in this blog-post.

## What makes an operation atomic?

When a programmer says that an operation is atomic, there are atleast two properties to which they might be referring:

- *Non-preemptible* - The operation can't be pre-empted in the middle (e.g. by another thread). 
- *Synchronizable* - The results of the operation can be made visible to other threads of execution in a controllable fashion. 

## Setup - How the queue works

- Bounded size. The elements are stored in a fixed-length buffer.
- Single-producer, Single-consumer applications. 
- Circular buffer. The `head` and `tail` cursors after reaching the maximum index of the buffer wrap around to the start of the buffer.

The `spsc_queue` type contains a fixed-length array - a buffer to store the elements of the queue and it also contains two indices into the array:

- `m_head` - The index of the `front` element, if any.
- `m_tail` - The index where a new element would be inserted at the back of the queue.

In an initially empty container, both the `m_head` and `m_tail` start at zero:

```
┌─────────────────────────────────────────────────────────────┐
│                   SPSC Ring Buffer (Empty)                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │    │    │    │    │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲                                                │
│            │                                                │
│        m_head = 0                                           │
│        m_tail = 0                                           │
│                                                             │
│   Status: Empty (m_head == m_tail)                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Then I have a `spsc_queue::push_back()` function that is used to append a new element to the queue. If the queue is not full, this operation should succeed, and it will go ahead and write a new element to the tail location and move the `m_tail` index forward. 

For example, if do `push_back(1)` the queue looks something like this. 

```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (1 element)                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │ 1  │    │    │    │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲    ▲                                           │
│            │    │                                           │
│        m_head   m_tail = 1                                  │
│         = 0                                                 │
│                                                             │
│   Status: 1 element (m_tail > m_head)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Here's the queue with a few more elements added:

```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (4 elements)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │ 1  │ 2  │ 3  │ 5  │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲                   ▲                            │
│            │                   │                            │
│        m_head = 0          m_tail = 4                       │
│                                                             │
│   Status: 4 elements (m_tail > m_head)                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Once I have got some elements into the queue, I can go ahead and call the `pop()` function, which is going to try to read and remove the first element from the front of the queue.

If the queue isn't empty, it :

- Advances `m_head` thereby implicitly discard the element at the front of the queue


```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (3 elements)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │    │ 2  │ 3  │ 5  │    │    │    │    │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│                 ▲              ▲                            │
│                 │              │                            │
│            m_head = 1       m_tail = 4                      │
│                                                             │
│   Status: 3 elements (m_tail > m_head)                      │
│   Note: Index 0 is now "stale" (logically removed)          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Most of the time, when we advance an index like this, it is a simple increment. But, as I stated earlier, the buffer slots are used in a a circular fashion. If that increment would place that `index` out of bounds, it wraps around to the zeroeth slot (that's what makes it a ring) of the queue buffer.

```
┌─────────────────────────────────────────────────────────────┐
│                 SPSC Ring Buffer (7 elements)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│            m_head = 1                                       │
│                 │                                           │
│                 ▼                                           │
│   Index:   0    1    2    3    4    5    6    7             │
│          ┌────┬────┬────┬────┬────┬────┬────┬────┐          │
│  Buffer: │    │ 2  │ 3  │ 5  │ 8  │ 13 │ 21 │ 34 │          │
│          └────┴────┴────┴────┴────┴────┴────┴────┘          │
│            ▲                                                │
│            │                                                │
│       m_tail = 0                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

As we'll see, it turns out that the indices `m_head` and `m_tail` will need to be `atomic` objects. We'll understand why this is the case.

The storage for a ring buffer consists of a fixed-capacity array of elements and the indices for `head` and `tail`. We shall write `spsc_queue` as a templated class having the capacity as a template parameter. 

```cpp
template<typename T, size_t capacity>
class spsc_queue{
    private:
    // The capacity must be a power of two.
    static_assert((capacity & (capacity - 1)) == 0);    
    T m_buffer[capacity];
    size_t m_head;
    size_t m_tail;
    public:
        /* ... */
};
```

We would like to enforce the capacity to be a power of $2$ for efficiency reasons. Remember, that with this design, there's always atleast one unused element in the array, because `m_head == m_tail + 1` is the queue full condition. So, the effective capacity equals `capacity - 1`. 

## The `class` interface

Here is the class interface:

```cpp
template<typename T, size_t capacity>
class spsc_queue{
    private:
    // The capacity must be a power of two.
    static_assert((capacity & (capacity - 1)) == 0);    
    T m_buffer[capacity];
    size_t m_head;
    size_t m_tail;
    public:
        /* ... */
};
```


