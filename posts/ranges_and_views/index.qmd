---
title: "C++ Ranges"
author: "Quasar"
date: "2025-01-31"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# C++ Ranges

## What is a range?

A **range** is a programmatic abstraction for a sequence of elements, bounded by two iterators(one to the first element of the sequence and one to the last element). 

Containers such as `std::vector`, `std::list` and `std::map` are concrete implementations of the range abstraction. The standard algorithms are generic. They are container agnostic. They know nothing about `std::vector`, `std::map` or `std::list`. They handle range abstractions with the help of a pair of iterators.  However, this has a shortcoming: we always need a `begin()` and `end()` iterator from a container. Here are some examples:

```cpp
// sort a vector
std::vector v{1, 2, 3, 4, 5};
std::sort(v.begin(), v.end());

// count the even numbers of an array
std::array<int, 5>a{1, 5, 3, 2, 4};
auto even_count = std::count_if(
    a.begin(),
    a.end(),
    [](int const n){ return n % 2 == 0; }
);
```

There are few cases when we only need to process a part of the container's elements. In the vast majority of the cases, we need to write `v.begin()` and `v.end()` over and over again. Ideally, we would prefer to shorten all this and be able to write the following:

```cpp
// sort a vector
std::vector v{1, 2, 3, 4, 5};
std::sort(v.begin(), v.end());

// count the even numbers of an array
std::array<int, 5>a{1, 5, 3, 2, 4};
auto even_count = std::count_if(
    a.begin(),
    a.end(),
    [](int const n){ return n % 2 == 0; }
);
```

On the other hand, we often need to compose multiple operations together. Most of the time that involves many operations and code that is too verbose even when using standard algorithms. Consider the following example: given a sequence of integers, we want to print to the console the square of all even numbers, except the first two, in descending order of their value (not their position in the sequence). There are multiple ways to solve this problem. Here is one possible solution:

```cpp
std::vector<int> v{1, 5, 3, 2, 8, 7, 6, 4};

// copy only the even elements
std::vector<int> temp;
std::copy_if(v.begin(), v.end(), std::back_inserter(temp), [](int n){
    return n % 2 == 0;
});

// sort the elements
std::sort(temp.begin(), temp.end(), [](int a, int b){ return a > b; });

// remove the first two
temp.erase(temp.begin() + temp.size() - 2, temp.end());

// transform the elements
std::transform(temp.begin(), temp.end(), [](int const n){ return n*n; });

// print each element
std::for_each(temp.begin(), temp.end(), [](int n){ std::println("{}, n"); });
```

While anyone familiar with standard algorithms can read this code, there are several downsides. Its a lot of code to write and also requires a temporary container  with repetitive calls to `begin()` and `end()`. All of the computation is done eagerly, so the  intermediate results of each step are held in memory.

Most people would easily understand the following version of the previous code and also prefer to write it as such:

```cpp
std::vector<int> v{1, 5, 3, 2, 8, 7, 6, 4};

using std::ranges = stdr;
using std::ranges::views = stdv;

stdr::sort(v);

auto r = v  | filter([](int n) { return n % 2 == 0; })
            | drop(2)
            | reverse
            | transform([](int n){ return n*n; });
```

This is what the C++20 standard provides with the help of the ranges library. This has two main components:

- **Range algorithms**, which enable us to operate on concrete ranges (standard containers or ranges) and not on abstract ranges delimited by a pair of iterators
- **Views or range adapters**, which represent non-owning iterable sequences. They enable us to compose operations more easily such as in the last example.

## Understanding range concepts and views

The term *range* refers to an abstraction that defines a sequence of elements bounded by start and end iterators. A range, therefore, represents an iterable sequence of elements. However, such a sequence can be defined in several ways:

- With a `begin` iterator and an `end` sentinel. Such a sequence is iterated from beginning to the end. A **sentinel** is an object that indicates the end of the sequence. It can have the same type as the iuterator type or it can be of a differnt type.
- With a start object and a size(number of elements), representing a so-called counted sequence. Such a sequence is iterated $N$ times (where $N represents the size) from the start. 
- With a start and a predicate, representing a so-called conditionally termninated sequence. Such a sequence is iterated from the start until the predicate returns false.
- With only a start value, representing a so-called unbounded sequence. Such a sequence can be iterated indefinitely. 

All these kinds of iterable sequences are considered ranges. Because a range is an abstraction, the C++20 library defines a series a of concepts to describe the requirements for range types. These are available in the `<ranges>` header and the `std::ranges` namespace. The following table presents a list of range concepts:

Name Description


# References {.appendix}

- *[Ranges and Iterators for numerical Problems](https://youtu.be/qXdPFj-FTcA?si=3xX3r8eIF4TlWXwr), Karsten Ahnert at Meeting C++ 2014*
- *[What is a range in C++](https://www.youtube.com/watch?v=UsyA7zEC0DE&t=989s), Simon Toth, C++ on the Sea, 2024*