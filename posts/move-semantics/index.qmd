---
title: "Move semantics and perfect forwarding"
author: "Quasar"
date: "2024-10-26"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

## Value Categories

In C++, every expression is either an *lvalue* or an *rvalue*. 

An *lvalue* denotes an object whose resources cannot be reused. The object is an *lvalue*, if you can't take the guts(resources) out of this object and donate it to someone else. *lvalue*s include expressions that designate objects by their name. For example, in the expression `double y = f(x)`, `y` is an *lvalue*. Moreover, *lvalue*s have persistent storage and an identifiable memory address. For instance, if I declare `std::vector<double> v{1.0,2.0,3.0,4.0,5.0};`, then `v[0]` is an *lvalue*.

An *rvalue* denotes an object whose resources can be reused. The object is an *rvalue*, if you can take the guts(resources) out of it and donate it to another object. *rvalue*s typically include temporary objects as they can't manipulated at the place they are created and are likely to be destroyed soon. For instance, if declare `int x = 5;`, `5` is an *rvalue*. Moreover, in the statement `double y = f(x);`, the expression `f(x)` is an *rvalue*. 

C++ defines the following value categories:

- *lvalues*: expressions for locations of long-living objects or functions. These objects have identity, persist in memory and are addressable.
- *prvalues*: expressions for short-living values for initializations. *prvalues* themselves do not exist somewhere in memory, they do not denote objects. They are an abstract recipee for initializing an object of type `T`. 
- *xvalue*: A special location, representing a (long-living) object, whose resources/values are no longer needed. The guts of this object can be stolen. 

## Copy elison

Copy elison omits copy and move constructors, resulting in zero-copy pass-by-value semantics.

### Mechanics

The basic mechanics of **Return Value Optimization**(RVO) is as follows:

- The caller allocates space on the stack for the return value, passes the address to the callee.
- The callee constructs the result directly in that space.

In the below code snip, 

```cpp
#include <print>
#include <iostream>

struct X{
    X(double val) : m_val{val} { std::cout << "\n" << "constructed at " << this; }
    X(const X&){ std::println("X(const X&)"); }
    X(X&&){ std::println("X(X&&)"); }
    ~X(){ std::cout << "\n" << "destructed at " << this; }
    double m_val;
};

void f(X arg){
    std::cout << "\n" << "&arg = " << &arg;
}

X g(){
    X obj = X(10);  // copy elison initializing obj
                    // from temporary
    return obj;     // NRVO
}

X h(){
    return X(15);   // URVO
}

int main(){
    f(X(42));
    X v1{g()};  // Copy elison initializing v1 from the result of g()
    std::cout << "\n" << "&v1 = " << &v1;
    X v2{h()};  // Copy elison initializing v2 from the result of h()
    std::cout << "\n" << "&v2 = " << &v2;
    return 0;
}
```
[Compiler Explorer](https://compiler-explorer.com/z/oMr16KTof)

It is important to note that:

- A *prvalue* is an expression that is not materialized until it is needed. It has no identity and is not an object. It is not addressable. URVO applies to *prvalues*.
- An *lvalue* is an expression that has an identity. 

