---
title: "Challenging exercises in Template Metaprogramming"
author: "Quasar"
date: "2025-08-23"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Challenging exercises in Template Metaprogramming

## Typelists and `std::index_sequence`

For type metaprogramming, the central data structures are the *typelist* and `std::index_sequence`. A `TypeList` is just a static list of types. A `std::index_sequence` is an integer sequence known at compile-time. `TypeList`s and `std::index_sequence`s differ from run-time data structures, such as `std::list`, in that they don't allow mutation. Adding an element to a `TypeList`, does not change the original `TypeList`: rather it creates a new typelist without modifying the original. If you are familar with functional programming languages like Haskell and F\#, there's a lot of parallel between working with typelists in C++ and lists in those languages.

## Implementing a `TypeList`

A `TypeList` is implemented as a class template. A particular instance of a typelist is a template specialization that encodes the contents of the typelist as template arguments.

```cpp
template<typename... Ts>
struct TypeList{
    using type = TypeList<Ts...>;
    static constexpr auto value = TypeList<Ts...>{};
};

using SignedIntegralTypes = TypeList<signed char, short, 
                            int, long, long long>;
```

`make_index_sequence` metafunction is used to create an integer sequence.

```cpp
constexpr std::index_seq seq = std::make_index_sequence<1,2,3,4,5>{};
```

## Manipulating `TypeList` and `index_sequence`

Manipulating the typelist and `index_sequence` typically requires breaking the typelist into parts, generally by separting the first element in the list (the head) from the remaining elements in the list (the tail). 

```cpp
// front implementation
template<typename List>
struct front;

template<typename Head, typename... Tail>
struct front<TypeList<Head,Tail...>>{
    using type = Head;
    static constexpr auto value = Head{};
};

template<typename List>
struct seq_front;

template<size_t First, size_t... Rest>
struct seq_front<std::index_sequence<First,Rest...>>{
    static constexpr size_t value = First;
};

int main(){
    static_assert(std::is_same_v<front<TypeList<int,float>>::type, int>);
    constexpr auto seq_front_result = seq_front<std::index_sequence<1,5,8,12>>::value;
    std::cout << std::format("\nseq_front result = {}", seq_front_result);
}
```

[Compiler Explorer](https://compiler-explorer.com/z/1W5rMr3nr)

The above implementation splits the typelist elements into the head and tail and then forms a new `TypeList` specialization from the elements in the tail.

## Implementing `pop_front`

The `pop_front` metafunction removes the first element from the typelist. Its implementation splits the typelist elements into the head and tail and then forms a new typelist from the elements in the tail.

```cpp
template<typename List>
struct pop_front;

template<typename Head, typename... Tail>
struct pop_front<TypeList<Head,Tail...>>{
    using type = TypeList<Tail...>;
    static constexpr auto value = TypeList<Tail...>{};
};

template<typename List>
struct seq_pop_front;

template<size_t First, size_t... Rest>
struct seq_pop_front<std::index_sequence<First,Rest...>>{
    using type = std::index_sequence<Rest...>;
    static constexpr auto value = std::index_sequence<Rest...>{};
};
```

[Compiler Explorer](https://compiler-explorer.com/z/565qdc3cY)

## Implementing `push_front`

We can also insert elements onto the front of the typelist by capturing all of the existing elements into a template parameter pack, then creating a new `TypeList` specialization containing all of those elements:

```cpp
template<typename Element, typename List>
struct push_front;

template<typename T, typename... Ts>
struct push_front<T, TypeList<Ts...>>{
    using type = TypeList<T,Ts...>;
    static constexpr auto value = TypeList<T,Ts...>{};
};

template<size_t I, typename IndexSequenceT>
struct seq_push_front;

template<size_t I, size_t... Is>
struct seq_push_front<I, std::index_sequence<Is...>>{
    using type = std::index_sequence<I,Is...>;
    static constexpr auto value = std::index_sequence<I,Is...>{};
};

template<size_t I, typename IndexSequence>
using seq_push_front_t = seq_push_front<I,IndexSequence>::type;
```

## Implementing `push_back`

```cpp
// push_back implementation
template<typename Element, typename List>
struct push_back;

template<typename Element>
struct push_back<Element, TypeList<>>{
    using type = TypeList<Element>;
};

template<typename Element, typename... Ts>
struct push_back<Element, TypeList<Ts...>>{
    using type = TypeList<Ts...,Element>;
};

// push_back implementation for index_sequence
template<size_t I, typename IndexSequence>
struct seq_push_back;

template<size_t I, size_t... Is>
struct seq_push_back<I, std::index_sequence<Is...>>{
    using type = std::index_sequence<Is...,I>;
    static constexpr auto value = std::index_sequence<Is...,I>{};
};

template<size_t I, typename IndexSequence>
using seq_push_back_t = seq_push_back<I,IndexSequence>::type;
```

## Typelist algorithms

The fundamental typelist operations `front`, `push_front`, `back` and `push_back` can be composed to create more interesting typelist manipulations. For example, we can replace the first element in a typelist by applying `push_front` to the result of `pop_front`.

Going further, we can implement algorithms - searches, transformations, reversals as metafunctions operating on typelists.

### Indexing

One of the most fundamental operations on a typelist is to extract a specific element of the list. Let us code up a metafunction to extract the $N$th element.

```cpp
template<size_t I, typename List>
struct nth_element;

template<typename First, typename... Rest>
struct nth_element<1,TypeList<First, Rest...>>{
    using type = First;
};

template<size_t N, typename First, typename... Rest>
struct nth_element<N, TypeList<First, Rest...>> : nth_element<N-1, TypeList<Rest...>>{};

template<size_t N, typename List, size_t... Is>
struct seq_nth_element;

template<size_t I, size_t... Is>
struct seq_nth_element<1,std::index_sequence<I,Is...>>{
    static constexpr auto value = I;
};

template<size_t N, size_t I, size_t... Is>
struct seq_nth_element<N, std::index_sequence<I,Is...>> : seq_nth_element<N-1,std::index_sequence<Is...>>{};
```

[Compiler Explorer](https://compiler-explorer.com/z/oWanY6Y78)

### Implementing `find_if`

Many typelist algorithms search for data within the typelist. This too can be easily achieved with a recursive template metaprogram.

```cpp
#include <utility>
#include <memory>
#include <format>
#include <iostream>

template<typename List, template<size_t I> typename Predicate, size_t... Is>
struct seq_find_if;

template<template<size_t > typename Predicate>
struct seq_find_if<std::index_sequence<>,Predicate> {
    using type = std::false_type;
};

template<size_t First, template<size_t > typename Predicate, size_t... Is>
struct seq_find_if<std::index_sequence<First, Is...>,Predicate> {
    static constexpr bool is_true = Predicate<First>::value;
    static constexpr bool more_elements_to_check = (sizeof...(Is) > 0);
    using type = std::conditional<
        is_true, 
        std::integral_constant<size_t,First>, 
        typename std::conditional<more_elements_to_check, typename seq_find_if<std::index_sequence<Is...>,Predicate>::type, std::false_type>::type
    >::type;
};

template<size_t N>
struct my_predicate{
    using type = std::conditional<(N % 2 == 0),std::true_type, std::false_type>::type;
    static constexpr bool value = (N % 2 == 0);
};

int main(){
    static_assert(std::is_same_v<
        seq_find_if<std::index_sequence<1,2,3,4>,my_predicate>::type,
        std::integral_constant<size_t,2>
    >);
}
```
[Compiler Explorer](https://compiler-explorer.com/z/rEvb6d9eG)

### Reversing a `TypeList` and `index_sequence`

When typelists have some ordering among their elements, it is convenient to be able to reverse the ordering of the elements in the typelist when applying some algorithms. The `reverse` algorithm implements this metafunction:

```cpp
template<typename List>
struct reverse;

// basis case
template<typename Head>
struct reverse<TypeList<Head>>{
    using type = TypeList<Head>;
};

template<typename... Ts>
struct reverse<TypeList<Ts...>>{
    using front_el = front<TypeList<Ts...>>::type;
    using tail = pop_front<TypeList<Ts...>>::type;
    using type = push_back<front_el, typename reverse<tail>::type>::type;
};
```

[Compiler Explorer](https://compiler-explorer.com/z/5j4nTqacz)

```cpp
template<typename IndexSequence>
struct seq_reverse;

template<size_t Head>
struct seq_reverse<std::index_sequence<Head>>{
    using type = std::index_sequence<Head>;
    static constexpr auto value = std::index_sequence<Head>{};
};

template<size_t Head, size_t... Tail>
struct seq_reverse<std::index_sequence<Head,Tail...>>{
    using type = seq_push_back<Head,typename seq_reverse<std::index_sequence<Tail...>>::type>::type;
};
```

[Compiler Explorer](https://compiler-explorer.com/z/437zq688q)

### Implementing `transform`



## Implementing `transform` for a `std::tuple{t1,t2,...,tn}`

```cpp
template<typename TupleT, typename Func, size_t... Is>
constexpr auto transform_impl(TupleT tup, Func func, std::index_sequence<Is...> indexes){
    return std::make_tuple(func(std::get<Is>(tup))...);
}

// transform
template<typename TupleT, typename Fn>
constexpr auto transform(Fn func, TupleT tup)
{
    constexpr auto index_seq = std::make_index_sequence<std::tuple_size_v<TupleT>>{};
    return transform_impl(tup, func, index_seq);
}
```

## Implementing `select_tuple` for a `std::tuple{t1,...,tn}`

```cpp
// select_tuple
template<typename TupleT, size_t... Is>
constexpr auto select_tuple(TupleT tuple, std::index_sequence<Is...> idx_sequence)
{
    return std::make_tuple((std::get<Is>(tuple))...);
}
```

## Reversing a tuple

```cpp
template<typename TupleT, size_t... Is>
constexpr auto reverse_tuple_impl(TupleT tuple, std::index_sequence<Is...> idx_seq){
    constexpr auto rev_idx_seq = reverse_index_sequence<std::index_sequence<Is...>>::value;
    return select_tuple(tuple, rev_idx_seq);
}

template<typename TupleT>
constexpr auto reverse_tuple(TupleT tuple){
    constexpr std::index_sequence idx_sequence = std::make_index_sequence<std::tuple_size_v<TupleT>>{};
    return reverse_tuple_impl(tuple, idx_sequence);
}
```

## Implementing tuple concatenation

```cpp
template<typename TupleT1, typename TupleT2, size_t... I1s, size_t... I2s>
constexpr auto cat_tuple_impl(TupleT1 tuple1, TupleT2 tuple2, std::index_sequence<I1s...> seq1, std::index_sequence<I2s...> seq2){
    return std::make_tuple(std::get<I1s>(tuple1)...,std::get<I2s>(tuple2)...);
}

template<typename TupleT1, typename TupleT2>
constexpr auto cat_tuple(TupleT1 t1, TupleT2 t2)
{
    constexpr std::index_sequence seq1 = std::make_index_sequence<std::tuple_size_v<TupleT1>>{};
    constexpr std::index_sequence seq2 = std::make_index_sequence<std::tuple_size_v<TupleT2>>{};
    return cat_tuple_impl(t1, t2, seq1, seq2);
}
```

## Implementing `zip` for a pair of tuples

```cpp
template<typename TupleT1, typename TupleT2, size_t... I1s, size_t... I2s>
constexpr auto zip_tuple_impl(TupleT1 tuple1, TupleT2 tuple2, std::index_sequence<I1s...> seq1, std::index_sequence<I2s...> seq2){
    return std::make_tuple(std::make_tuple(std::get<I1s>(tuple1), std::get<I2s>(tuple2))...);
}

template<typename TupleT1, typename TupleT2>
constexpr auto zip_tuple(TupleT1 t1, TupleT2 t2){
    constexpr std::index_sequence seq1 = std::make_index_sequence<std::tuple_size_v<TupleT1>>{};
    constexpr std::index_sequence seq2 = std::make_index_sequence<std::tuple_size_v<TupleT2>>{};
    return zip_tuple_impl(t1, t2, seq1, seq2);
}
```






