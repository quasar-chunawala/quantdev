---
title: "Challenging exercises in Template Metaprogramming"
author: "Quasar"
date: "2025-08-23"
categories: [C++]      
image: "cpp.jpg"
toc: true
toc-depth: 3
---

# Challenging exercises in Template Metaprogramming

## Typelists and `std::index_sequence`

For type metaprogramming, the central data structures are the *typelist* and `std::index_sequence`. A `TypeList` is just a static list of types. A `std::index_sequence` is an integer sequence known at compile-time. `TypeList`s and `std::index_sequence`s differ from run-time data structures, such as `std::list`, in that they don't allow mutation. Adding an element to a `TypeList`, does not change the original `TypeList`: rather it creates a new typelist without modifying the original. If you are familar with functional programming languages like Haskell and F\#, there's a lot of parallel between working with typelists in C++ and lists in those languages.

## Implementing a `TypeList`

A `TypeList` is implemented as a class template. A particular instance of a typelist is a template specialization that encodes the contents of the typelist as template arguments.

```cpp
template<typename... Ts>
struct TypeList{
    using type = TypeList<Ts...>;
    static constexpr auto value = TypeList<Ts...>{};
};

using SignedIntegralTypes = TypeList<signed char, short, 
                            int, long, long long>;
```

`make_index_sequence` metafunction is used to create an integer sequence.

```cpp
constexpr std::index_seq seq = std::make_index_sequence<1,2,3,4,5>{};
```

## Manipulating `TypeList` and `index_sequence`

Manipulating the typelist and `index_sequence` typically requires breaking the typelist into parts, generally by separting the first element in the list (the head) from the remaining elements in the list (the tail). 

```cpp
template<typename List>
struct front;

template<typename Head, typename... Tail>
struct front<TypeList<Head,Tail...>>{
    using type = Head;
    static constexpr auto value = Head{};
};

template<typename List>
struct seq_front;

template<size_t First, size_t... Rest>
struct seq_front<std::index_sequence<First,Rest...>>{
    static constexpr size_t value = First;
};

int main(){
    static_assert(std::is_same_v<front<TypeList<int,float>>::type, int>);
    constexpr auto seq_front_result = seq_front<std::index_sequence<1,5,8,12>>::value;
    std::cout << std::format("\nseq_front result = {}", seq_front_result);
}
```

[Compiler Explorer](https://compiler-explorer.com/z/1W5rMr3nr)

The above implementation splits the typelist elements into the head and tail and then forms a new `TypeList` specialization from the elements in the tail.

## Implementing `pop_front`

The `pop_front` metafunction removes the first element from the typelist. Its implementation splits the typelist elements into the head and tail and then forms a new typelist from the elements in the tail.

```cpp
template<typename List>
struct pop_front;

template<typename Head, typename... Tail>
struct pop_front<TypeList<Head,Tail...>>{
    using type = TypeList<Tail...>;
    static constexpr auto value = TypeList<Tail...>{};
};

template<typename List>
struct seq_pop_front;

template<size_t First, size_t... Rest>
struct seq_pop_front<std::index_sequence<First,Rest...>>{
    using type = std::index_sequence<Rest...>;
    static constexpr auto value = std::index_sequence<Rest...>{};
};
```

[Compiler Explorer](https://compiler-explorer.com/z/565qdc3cY)

## Implementing `push_front`

We can also insert elements onto the front of the typelist by capturing all of the existing elements into a template parameter pack, then creating a new `TypeList` specialization containing all of those elements:

```cpp
template<size_t I, typename IndexSequenceT>
struct seq_push_front;

template<size_t I, size_t... Is>
struct seq_push_front<I, std::index_sequence<Is...>>{
    using type = std::index_sequence<I,Is...>;
    static constexpr auto value = std::index_sequence<I,Is...>{};
};

template<size_t I, typename IndexSequence>
using seq_push_front_t = seq_push_front<I,IndexSequence>::type;
```

The below helper functions are extremely useful when working with tuples.

```cpp


template<size_t I, typename IndexSequence>
struct push_back_index_sequence;

template<size_t I, size_t... Is>
struct push_back_index_sequence<I, std::index_sequence<Is...>>{
    using type = std::index_sequence<Is...,I>;
    static constexpr auto value = std::index_sequence<Is...,I>{};
};

template<typename IndexSequence>
struct pop_front_index_sequence;

template<size_t First, size_t... Rest>
struct pop_front_index_sequence<std::index_sequence<First,Rest...>>{
    using type = std::index_sequence<Rest...>;
    static constexpr auto value = std::index_sequence<Rest...>{};
};

template<size_t First, size_t... Rest>
constexpr size_t get_front_index_sequence(std::index_sequence<First,Rest...> idx_seq){
    return First;
}

template<size_t I, typename IndexSequence>
using push_back_index_sequence_t = push_back_index_sequence<I,IndexSequence>::type;

template<typename IndexSequence>
struct reverse_index_sequence;

template<size_t Head>
struct reverse_index_sequence<std::index_sequence<Head>>{
    using type = std::index_sequence<Head>;
    static constexpr auto value = std::index_sequence<Head>{};
};

template<size_t Head, size_t... Tail>
struct reverse_index_sequence<std::index_sequence<Head,Tail...>> : push_back_index_sequence<Head, typename reverse_index_sequence<std::index_sequence<Tail...>>::type>{};
```

## Implementing `transform` for a `std::tuple{t1,t2,...,tn}`

```cpp
template<typename TupleT, typename Func, size_t... Is>
constexpr auto transform_impl(TupleT tup, Func func, std::index_sequence<Is...> indexes){
    return std::make_tuple(func(std::get<Is>(tup))...);
}

// transform
template<typename TupleT, typename Fn>
constexpr auto transform(Fn func, TupleT tup)
{
    constexpr auto index_seq = std::make_index_sequence<std::tuple_size_v<TupleT>>{};
    return transform_impl(tup, func, index_seq);
}
```

## Implementing `select_tuple` for a `std::tuple{t1,...,tn}`

```cpp
// select_tuple
template<typename TupleT, size_t... Is>
constexpr auto select_tuple(TupleT tuple, std::index_sequence<Is...> idx_sequence)
{
    return std::make_tuple((std::get<Is>(tuple))...);
}
```

## Reversing a tuple

```cpp
template<typename TupleT, size_t... Is>
constexpr auto reverse_tuple_impl(TupleT tuple, std::index_sequence<Is...> idx_seq){
    constexpr auto rev_idx_seq = reverse_index_sequence<std::index_sequence<Is...>>::value;
    return select_tuple(tuple, rev_idx_seq);
}

template<typename TupleT>
constexpr auto reverse_tuple(TupleT tuple){
    constexpr std::index_sequence idx_sequence = std::make_index_sequence<std::tuple_size_v<TupleT>>{};
    return reverse_tuple_impl(tuple, idx_sequence);
}
```

## Implementing tuple concatenation

```cpp
template<typename TupleT1, typename TupleT2, size_t... I1s, size_t... I2s>
constexpr auto cat_tuple_impl(TupleT1 tuple1, TupleT2 tuple2, std::index_sequence<I1s...> seq1, std::index_sequence<I2s...> seq2){
    return std::make_tuple(std::get<I1s>(tuple1)...,std::get<I2s>(tuple2)...);
}

template<typename TupleT1, typename TupleT2>
constexpr auto cat_tuple(TupleT1 t1, TupleT2 t2)
{
    constexpr std::index_sequence seq1 = std::make_index_sequence<std::tuple_size_v<TupleT1>>{};
    constexpr std::index_sequence seq2 = std::make_index_sequence<std::tuple_size_v<TupleT2>>{};
    return cat_tuple_impl(t1, t2, seq1, seq2);
}
```

## Implementing `zip` for a pair of tuples

```cpp
template<typename TupleT1, typename TupleT2, size_t... I1s, size_t... I2s>
constexpr auto zip_tuple_impl(TupleT1 tuple1, TupleT2 tuple2, std::index_sequence<I1s...> seq1, std::index_sequence<I2s...> seq2){
    return std::make_tuple(std::make_tuple(std::get<I1s>(tuple1), std::get<I2s>(tuple2))...);
}

template<typename TupleT1, typename TupleT2>
constexpr auto zip_tuple(TupleT1 t1, TupleT2 t2){
    constexpr std::index_sequence seq1 = std::make_index_sequence<std::tuple_size_v<TupleT1>>{};
    constexpr std::index_sequence seq2 = std::make_index_sequence<std::tuple_size_v<TupleT2>>{};
    return zip_tuple_impl(t1, t2, seq1, seq2);
}
```






